TODO

 * Use "!:" tags in IL and environment (check perf.)

 * Exports, Imports, Rewind

   - Make symbols Private by default; explicit &public.
   - Export ONLY PUBLIC values when no macros or inline funcs are exported.
   - Embed current file name in env as EMarker (or using dynamic var during
     expansion). Better reporting of errors during macro expansion
     (e.g. undefined symbols)

 * data: distinguish ctors from records
 * (data NAME CTOR...) reflection

     (data-type VALUE)     -->  (DataType name arity ctor dtor)
       (DTOR VALUE)        -->  [MEMBER ...]
       (CTOR MEMBER...)    -->  VALUE

     (is-data? CTOR value)
     (data-tag CTOR)
     (data-tag value)
     (data-constructor tag/value)
     (data-tags)  -->  { tag: [typename args...], ...}  for all tags in scope

 * (case EXPR
      (CONST          EXPR)    ;; match constant exactly (nil, for example)
      ((CtorA "str" y) EXPR)   ;; match constant member
      (["A" a b]      EXPR)    ;; deconstruct vectors & match constants (always succeeds)
      (`SYNTAX        EXPR)    ;; ?
      ...)

 * use data/case in parser

 * Custom constructors

   (data (Bind key value)
     rec (concat [key] "!=" [value])
     (key (first (subst "!=" " " rec)))
     (value (nth 2 (subst "!=" "! " rec)))
     (match (findstring "!=" rec)))

   (data (Bind key value)
     (concat [key] "!=" [value])
     (lambda (rec)
       [ (first (subst "!=" " " rec)) (nth 2 (subst "!=" "! " rec)) ])
     (lambda (rec)
       (findstring "!=" rec)))

 * (? lambda ...)  -->  (call "^tv" "any" (any ...))
   or:  (call "^yt" "any" (lambda (args) (any args)) ...)

 * Obtain value of builtin.  E.g. word -> "$(word $1,$2)"
   May fix (? builtin ...).

 * Bugs (see gen-test.scm)

 * Avoid function/builtin conflicts

    (define (word a b) 1)    Actually defines variable, but...
    (word 1 2)               Does not call defined function, and ...
    (word 1)                 Stop. (!)

 * check arg counts for all functions (not just inline functions)
    - export/import arg count

 * Parse hash syntax

 * WARN when shadowing variables!
    - most common error case (esp. builtins) (esp. in REPL)
    - allow `(let ((x x)) ...)` or `&shadow` exceptions

 * scam -x

   Make `require` work with source files in `scam [-x] FILE ...` commands.
   Build with `scam -o .scam/NAME` & then run.

 * c0 functions:  return [IL ...env] consistently.   When `inblock` is nil,
  `...env` can be nil.

 * arbitrary precision floating point
    - fp divide w/ specified precision
    - bug: (^ 2 100)  [in fp]

 * "rest" and "spread" with "..." syntax

   More efficient append, vararg, apply, etc..

       [a b args... c]  ==>  (append [a b] args [c])
       (f a b args...)  ==>  (apply f [a b args...])
                        ==>  (apply f (append [a b] args))

   (define (f a v...)
      (g b a v...))

     (c1 "VA $ 7") ->  $(call ^d,$7) $(call ^d,^8) $9
     (c1 "VA $ 6") ->  $(foreach n,6 7 8,$(call ^d,$($n)))

     spread 7..9:  $(call ^n,1,REST),$(call ^n,2,REST),$(wordlist 3,9999,REST)
     $(call ^n,2,$(call ^d,$7) ... )       --> $7
     $(call ^n,2,<WORD> $(call ^d,$8) ...) --> $8
     ["f" "^n" "Q 1" ["VA" "$" 6]]         --> ["R" "$8"]
     $(wordlist 3,9999,<WORD> <WORD> $(wordlist A,B,R)) --> $(wordlist A,B,R))
     ["F" "wordlist" "Q 3" "Q 9999" ["VA" "$" 6]]       --> ["R" "$9"]

 * aliases: (define `X Y) should bind Y's defn (minus 'priv' bit) to X
   ... but this would break rewind.

 * Integrate `strlen` with core.scm and use `strlen` to report column
   for errors.

 * looping constructs / named lambda

   http://www.scheme.com/tspl4/control.html#./control:h4

     let:  (let name ((var expr) ...) body...)

        (define (factorial n)
           (let f ((i n) (a 1))
             (if (> i 0)
                 (f (- i 1) (* a i))
                 a)))

     do:   (do ((var init update) ...) (test result ...) expr ...)

        (define (factorial n)
            (do ([i n (- i 1)]
                 [a 1 (* a i)])
                ((zero? i) a))))

 * .min -> .make

 * Move syntax quoting to scam-ct

 * .out/a/scam ends up using NS='~' runtime, and also building and loading
   its own runtime for .out/b/scam with NS='~' (!).

   Big complication: Modules may use a runtime in their own namespace, or
   the compiler's own namespace.  [Inherent in a compiler being able to
   target another namespace, and to compile sources that don't supply their
   own namespace.]

   Maybe

   Namespacing the RT would be nice, but that is a feature of SCAM language,
   so that would imply writing the RT in SCAM, which implies it depends on
   the previous stage's runtime!  For which COMPLETE namespacing would be
   nice, but that complicates codegen.

   Multiple execution/compilation models (-x, -e, -o, make-driven
   vs. synchronous, user-provided vs. compiler-embedded modules) have made
   this more "interesting" than it otherwise would have to be.

   `base` env should really be "builtin" env, a property of codegen.  gen1
   does not need an env parameter, but could use a constant global env.
   Maybe an (RT ...) IL node and (ERT ...) binding would be appropriate.

     (RT "d" ...) for (Call (concat NS "^d") ...)

   Like builtins, they would not use the arg9 convention.

   Those *actually* used in codegen:
      ^u, ^d, ^n, ^set, ^fset, ^Y, ^E, ^av, ^t, ^require, ^start


   -----

   Assume compiler c0, compiled from unknown sources.  Everything about
   *how* it works is a mystery; the language definition is all that is
   known.  All it does is compile sources to programs in the default
   (un-prefixed) namespace.  Our first step:

   $ c0 -o c1 c.scm

   Presumably, this program will include a runtime that was bundled with c0,
   suitably namespaced to avoid collisions with our program's functions.
   But we can't even assume that it has a runtime.  Certainly it does not
   use the runtime in the c1 sources.

   Ideally, c1 would be fully functional, so that we could proceed to:

   $ c1 -o prog prog.scm

   ...but we aren't ready to, because *our* compiler -- the c1 source code
   -- makes use of a runtime that must be bundled with any program we
   generated.  That runtime is a separate source file, also written in SCAM.
   It cannot be compiled with c0, because c0 generates only programs, not
   discrete modules.  Even if it did, the discrete module would presumably
   have external dependencies the way *our* generate code will have
   dependencies on our runtime.  Just as our generated code will drag along
   our runtime, c0's might drag along a copy of its runtime, and after a few
   generations things can get quite large and conflicts get harder to avoid.

   So we need c1 to compile its own runtime.  Maybe a special command-line
   option will suffice for this "mode" of operation:

   $ c1 --boot -o prog prog.scm

   It will have to be careful to avoid having runtime code depending on
   things not yet defined later in the runtime, but with knowledge of c1
   codegen and runtime we could achieve this.  Once built, it will bundle
   the runtime with the program it generates, leaving it with a standalone
   program.

   We still want to arrive at a standalone *compiler*, and in addition to
   having its embedded runtime requirements met, it will also want to
   extract a copy of that runtime from itself for bundling with programs it
   generates.

   That, in turn, generates namespacing concerns.  We want compiled code to
   be able to run alongside compiler code in one instance of Make -- the
   '-e' and interactive modes require this.  That means the generated code
   uses a different namespace (the default namespace).  That means the
   compiler must get OUT OF the default namespace.  And then how can it
   share the runtime (on one namespace) with the generated code?

   Currently in SCAM:

    - c1 (c1a) compiles c1b, and c1b uses a special namespace ("~" prefix).

    - c1b can then generate code in the deafult namespace.

    - However, once we promote c1b to be the new "c0", we will have a c0
      that internally uses the "~" namespace.  And therefore the next c1a
      will end up using a "~" runtime, the same as the next c1b that c1a
      generates.  This can cause problems when c1a executes code it
      generated for c1b.


Optimizations
----

 * Tracing `scam` itself is problematic because the processing occurs after
   `main` exits (in the rule-processing phase).

 * (case NAME    -->  (foreach TMP (or (word 1 VALUE) "!.")
       (Foo a)    -->    (if (filter "TAG" TMP) ...))
        a         -->    (word 2 (^u TMP))  or  (word 2 VALUE)
   (case EXPR    -->  (foreach TMP [VALUE]
      (Foo a b)  -->    (if (filter "TAG!0%" "%") TMP) ...))  [always args]
      (Bar)      -->    (if (filter "TAG" "%") TMP) ...))     [no args]

 * Output a very limited environment when a module does not export macros or
   inline functions. (Any examples?)

 * Constant propagation:  (Call PURE CONST...) -->   (Const (PURE CONST...))

   Functions are PURE if they have no side-effects and produce a value that
   is purely a function of their inputs.  (No references to globals or I/O,
   and no calls to functions that might do so.)

   Properties of function nodes should be computed from the bottom-up to
   avoid repeatedly revisiting the same node. (Same for other nodes that
   contain other nodes.)

    - const?      [if so, will already be a Const node]
    - nil?        always evaluates to ""  (use in file code gen, blocks, conditionals..)
    - true?       always evaluates to non-empty string  (e.g. demote)
    - wordy?      result has no spaces or tabs?
    - vectory?    "!" occurs *only* in [" " "\t" "!" ""]
    - plain?      Contains no "!", spaces, tabs.
    - nout?       evaluation will NOT have side-effects (set, info, shell, ...)
    - nin?        result IS a purely function of inputs (does NOT read globals)

    wordy? and vectory? and true?  ==>  (demote (promote x)) == x
    nout? and nin?                 ==>  PURE

 * IF constant propagation:

    (if TRUE a b) -->  (Block TRUE a)
    (if VOID a b) -->  (Block VOID b)

 * IF strength reduction:

    (if (nth N VEC) ...)       -->  (if (subst "!." "" (word N VEC)) ...)
    (if (subst X TRUE Y) ...)  -->  (if (begin X TRUE Y) ...)

 * Block reduction:

     (Block PRE... POST)  -->  (Discard PRE)... POST

     (Discard NOUT)  --> ""  [all consts are NOUT]
     (Discard (Concat A B C)) -->  (Discard A) (Discard B) (Discard C)

 * IF-NOT reduction:  (if (not x) a b) -->  (if x b a)
 * IF-YES reduction:  (if (if C 1) a b) -->  (if C a b)

     Rule:    (if (if C A B) X Y)   --> (if C (if A X Y) (if B X Y))    [if A and B are true or nil]
     IF-NOT:  (if (if C nil 1) X Y) --> (if C (if nil X Y) (if 1 X Y))  [+const prop]
     IF-YES:  (if (if C TRUE) X Y)  --> (if X (if TRUE X Y) (if nil Y)) [+const prop]

 * IF CSE:  (if COND (f A) (f B))  -->  (f (if COND A B))

     Special case:  (if PURE 1 1) -->  (begin PURE 1)  -->  1

     This can be applied recursively to break apart complex commonality.
     Not good when A or B are constants and `f` is evaluatable.

 * Misc...

     (word N (wordlist A B VEC))      -->  nil  ...or...  (word N+A-1 VEC)
     (wordlist A B (wordlist C D VEC) --> (wordlist A+C-1 (min B D-C+1) VEC)

     (demote WORD)          -->  (subst "!" "!1" WORD)  [when word is not nil]
     (demote PLAIN)         -->  PLAIN
     (promote PLAIN)        -->  PLAIN

     (subst PURE PURE nil)  -->  nil
     (word PURE nil)        -->  nil

     (eq A B) ==
       (findstring A (findstring B A))  -->  (filter A B)
         When: A and B are words, and A does not contain "%" (e.g. $(words))

     (eq CONST (nth N V)) -->  (eq (demote CONST) (word N V))
                          -->  (filter (demote CONST) (word N V))

     (f (if COND X Y))   -->   (if COND (f X) (f Y))
       ... reduces when X or Y are constants e.g. demote
       (demote (if COND C1 C2)   -->  (if COND C3 C4)
       (if (not COND) A B) ==
          (if (if COND nil 1) EXPR)  -->  (if COND (if nil EXPR) (if 1 EXPR))


 * Extraction and naming of anonymous functions.  The main motivation is to
   make nested "let" blocks more efficient.  Currently size expands
   exponentially ... which directly impacts performance.  Deeper nesting is
   also a performance hit.

    A) Convert lambda literals to variable references:

          f = ...LAMBDA...  -->   tmpvar = $(unescape LAMBDA)
                                  f = ...$(value tmpvar)...

       Up-value references make this impossible, since the values are not
       known at tmpvar assignment time.

       This assumes compilation for file context.  In expression context
       we could do something like:

          ...LAMBDA...  -->  $(set tmpvar,LAMBDA)...$(value tmpvar)...

       ... but this will be unhelpful if the `set` is immediately prior to
       the value (the assignment has to be less nested).  Also, the assignment
       must be idempotent; any up-values will potentially corrupt the result.

    B) Lambda-call reduction:

          $(call ^Y,$(value x),...)  -->  $(call x,...)

    C) Up-value elimination:

        A: (let ((x y)) ...a...)     -->  (let ((x y) (a a)) ...a...)
        B: ((lambda (x) ...a...) y)  -->  ((lambda (x y) ...a...) y a)

            $(call ^Y,$1,...,$$1$(call escape,$2)...)
        --> $(call ^Y,$1,$2,...,$$1$$2...)

       This would have to be done at the gen0 phase (without knowledge of
       file vs. expression context), but it improves performance
       independently of A & B, so it would be good anyway.  (But this can be
       done manually by the programmer, so maybe isn't as urgent.)


    Looking at the `let` case in particular (where we know A and B are
    relevant):

    text:   (define (f) (let ((a VAL)) BODY))
    nodes:  [["F" "call" "Q ^fset" "Q f" ["X" ["Y" ["X" BODY] VAL]]]
    file:   f = $(call ^Y,VAL,,,,,,,,,ESC_BODY)


    One special case that might be easy to approach is when a function
    begins with `let` (so the generated code begins a lambda call).  This is
    fairly frequent, but doesn't cover a majority.  Another common case is
    `(if arg1 (let ...))` and there are lots of other cases.


* Misc
    * Interleave compile with parsing of top-level expressions.
    * Improve void-node?  (void? (if c a b)) --> (and (void? a) (void? b))
    * Identify arguments using special IL record (vs. R)
         A n level           ->   local (arg)       $n


----------------------------------------------------------------
Examples to be written:

 - cleanPath
 - numerical ordering
 - regular expressions
 - makefile lisp templating
 - syracuse / ackerman / HOTPO
 - web server

----------------------------------------------------------------
Root causes of some BUGS I've encountered:

 * Wrong number of arguments (misplaced parentheses)  X2

   e.g.: (if ( ... ) ( ... ))
   vs:   (if ( ... )) ( ... )

         (f (g a b c) d)
   vs:   (f (g a) b c d)

 * Used `func` instead of `"func"`

 * Undefined variable name (at least 6 times)

 * Shadowed "eval" with user-defined function!

----------------------------------------------------------------

The following provide all of the capabilities that SCAM needs:

     * (if a b c)
     * (subst a b c)
     * (word n s)
     * (f ...) : calling a lambda expression.
     * (set a b)     [needed only for Make interop]

The following functions make some common operations more efficient (but can
be fiendishly difficult to employ correctly):

    wordlist, filter, filter-out, patsubst, findstring, foreach, join

; (define (concat a b)  (u (subst "!*" (d b) (subst 1 (d a) "1!*")))

; (define (eq a b)
;    (not (and (or a b)
;              (or (subst b "" a)
;                  (subst a "" b)))))

; (define (findstring a b)  (if (not (eq (subst a "" b) b)) a))

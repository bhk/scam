TODO

 * Make `require` work with source files in `scam [-x] FILE ...` commands.

 * (data (Symbol pos name)
         (String pos text)
         (List pos nodes)
         ...)

   Maybe:
     (data? CTOR value)
     (data-tag CTOR)
     (data-tag value)
     (data-constructor tag/value)
     (data-tags)  -->  { tag: [typename args...], ...}  for all tags in scope

    - Use `case` to deconstruct
    - Display constructors in `format`
    - Encode using nth-rest rather than (nth N .):  &vector nodes
    - Encode using word rather than (nth N .):  &word pos

 * (case EXPR
      ((CtorA x y)    EXPR)     ; `a` and `b` bound
      ((CtorB? node)  EXPR)     ; `node.a` and `node.b` bound
      (["A" a b]      EXPR)     ; `a` and `b` bound
      (CONST          EXPR)
      (`SYNTAX        EXPR)
      (else           EXPR))

 * Move syntax quoting to scam-ct

 * Parse hash syntax (?)

 * builtin enhancements

    word                     ... attempt to obtain value of builtin: "word"
    (call "word" 1)          Stop. (!)
    (define (word a b) 1)    Actually defines variable, but...
    (word 1 2)               Does not call defined function, and ...
    (word 1)                 Stop. (!)

 * WARN when shadowing variables!
    - most common error case (esp. builtins) (esp. in REPL)
    - allow `(let ((x x)) ...)` or `&shadow` exceptions

 * scam -x: build with `scam -o .scam/NAME` & then run

 * Bugs (see gen-test.scm)

 * Deconstruction of vectors in assignments

      (let ([one two] ...) ...)
      (let ([one rest...] ...) ...)

 * c0 functions:  return [IL ...env] consistently.   When `inblock` is nil,
  `...env` can be nil.

 * (expand NAME)  -->   "$(NAME)"
   (set-expand NAME)  : replaces set-global
   (set-value NAME)   : replaces set-rglobal

 * chose alias for keyword collisions (or namespace everything)
   (define (info a b) ...)  -->  "~info = ..."

 * Display of data

    - @q -->  Undo constructors  "0 1 2 3"       -->  "(Ctor 1 2 3)"
    - @q -->  Undo hashes   -->  { a: 123,  "str": 234 }
    - @f -->  Undo parsing?      "(Symbol "a")"  -->  'a  [not true undo, due to loc]

 * (? macro ...)
   (? any ...)  -->  (call "^tv" "any" (any ...))
                or:  (call "^yt" "any" (lambda (args) (any args)) ...)

 * arbitrary precision floating point
    - fp divide w/ specified precision
    - bug: (^ 2 100)  [in fp]

 * "rest" and "spread" with "..." syntax

   More efficient append, vararg, apply, etc..

       [a b args... c]  ==>  (append [a b] args [c])
       (f a b args...)  ==>  (apply f [a b args...])
                        ==>  (apply f (append [a b] args))

   (define (f a v...)
      (g b a v...))

     (c1 "VA $ 7") ->  $(call ^d,$7) $(call ^d,^8) $9
     (c1 "VA $ 6") ->  $(foreach n,6 7 8,$(call ^d,$($n)))

     spread 7..9:  $(call ^n,1,REST),$(call ^n,2,REST),$(wordlist 3,9999,REST)
     $(call ^n,2,$(call ^d,$7) ... )       --> $7
     $(call ^n,2,<WORD> $(call ^d,$8) ...) --> $8
     ["f" "^n" "Q 1" ["VA" "$" 6]]         --> ["R" "$8"]
     $(wordlist 3,9999,<WORD> <WORD> $(wordlist A,B,R)) --> $(wordlist A,B,R))
     ["F" "wordlist" "Q 3" "Q 9999" ["VA" "$" 6]]       --> ["R" "$9"]

 * aliases: (define `X Y) should bind Y's defn (minus 'priv' bit) to X
   ... but this would break rewind.

 * Integrate `strlen` with core.scm and use `strlen` to report column
   for errors.

 * check arg counts for all functions (not just inline functions)
    - export/import arg count

 * looping constructs
   http://www.scheme.com/tspl4/control.html#./control:h4

     let:  (let name ((var expr) ...) body...)

        (define (factorial n)
           (let f ((i n) (a 1))
             (if (> i 0)
                 (f (- i 1) (* a i))
                 a)))

     do:   (do ((var init update) ...) (test result ...) expr ...)

        (define (factorial n)
            (do ([i n (- i 1)]
                 [a 1 (* a i)])
                ((zero? i) a))))

 * .min -> .make

 * To make hashes easily sortable by key, something other than
   "!=" -- maybe "!+" -- would be required.  (This could be subst'ed
   when sorting, however.)

 * Better reporting of errors during macro expansion

   e.g. undefined symbols

   Keep line numbers in macro defn, and track host file name as arg to
   expansion.  (Or: embed reference to file in macro env entry.)


Optimizations
----

 * Constant propagation:  (Call PURE CONST...) -->   (Const (PURE CONST...))

   Functions are PURE if they have no side-effects and produce a value that
   is purely a function of their inputs.  (No references to globals or I/O,
   and no calls to functions that might do so.)

   Properties of function nodes should be computed from the bottom-up to
   avoid repeatedly revisiting the same node. (Same for other nodes that
   contain other nodes.)

    - const?      [if so, will already be a Const node]
    - nil?        always evaluates to ""  (use in file code gen, blocks, conditionals..)
    - true?       always evaluates to non-empty string  (e.g. demote)
    - wordy?      result has no spaces or tabs?
    - vectory?    "!" occurs *only* in [" " "\t" "!" ""]
    - plain?      Contains no "!", spaces, tabs.
    - nout?       evaluation will NOT have side-effects (set, info, shell, ...)
    - nin?        result IS a purely function of inputs (does NOT read globals)

    wordy? and vectory? and true?  ==>  (demote (promote x)) == x
    nout? and nin?                 ==>  PURE

 * IF constant propagation:

    (if TRUE a b) -->  (Block TRUE a)
    (if VOID a b) -->  (Block VOID b)

 * IF strength reduction:

    (if (nth N VEC) ...)       -->  (if (subst "!." "" (word N VEC)) ...)
    (if (subst X TRUE Y) ...)  -->  (if (begin X TRUE Y) ...)

 * Block reduction:

     (Block PRE... POST)  -->  (Discard PRE)... POST

     (Discard NOUT)  --> ""  [all consts are NOUT]
     (Discard (Concat A B C)) -->  (Discard A) (Discard B) (Discard C)

 * IF-NOT reduction:  (if (not x) a b) -->  (if x b a)
 * IF-YES reduction:  (if (if C 1) a b) -->  (if C a b)

     Rule:    (if (if C A B) X Y)   --> (if C (if A X Y) (if B X Y))    [if A and B are true or nil]
     IF-NOT:  (if (if C nil 1) X Y) --> (if C (if nil X Y) (if 1 X Y))  [+const prop]
     IF-YES:  (if (if C TRUE) X Y)  --> (if X (if TRUE X Y) (if nil Y)) [+const prop]

 * IF CSE:  (if x (f a) (f b))  -->  (f (if x a b))

     Special case:  (if PURE 1 1) -->  (begin PURE 1)  -->  1

     This can be applied recursively to break apart complex commonality.

 * Misc...

     (word N (wordlist A B VEC))      -->  nil  ...or...  (word N+A-1 VEC)
     (wordlist A B (wordlist C D VEC) --> (wordlist A+C-1 (min B D-C+1) VEC)

     (demote WORD)          -->  (subst "!" "!1" WORD)  [when word is not nil]
     (demote PLAIN)         -->  PLAIN
     (promote PLAIN)        -->  PLAIN

     (subst PURE PURE nil)  -->  nil
     (word PURE nil)        -->  nil

     (eq A WORD) --> (if (filter A WORD) 1)  ... (const? A), no "%" in A

     (findstring WORD (findstring A WORD))  -->  (filter WORD A)

     (eq CONST (nth N V)) -->  (eq (demote CONST) (word N V))
                          -->  (filter (demote CONST) (word N V))

     (demote (if COND X Y))   -->   (if COND (demote X) (demote Y))   [maybe reduces]


 * Extraction and naming of anonymous functions.  The main motivation is to
   make nested "let" blocks more efficient.  Currently size expands
   exponentially ... which directly impacts performance.  Deeper nesting is
   also a performance hit.

    A) Convert lambda literals to variable references:

          f = ...LAMBDA...  -->   tmpvar = $(unescape LAMBDA)
                                  f = ...$(value tmpvar)...

       Up-value references make this impossible, since the values are not
       known at tmpvar assignment time.

       This assumes compilation for file context.  In expression context
       we could do something like:

          ...LAMBDA...  -->  $(set tmpvar,LAMBDA)...$(value tmpvar)...

       ... but this will be unhelpful if the `set` is immediately prior to
       the value (the assignment has to be less nested).  Also, the assignment
       must be idempotent; any up-values will potentially corrupt the result.

    B) Lambda-call reduction:

          $(call ^Y,$(value x),...)  -->  $(call x,...)

    C) Up-value elimination:

        A: (let ((x y)) ...a...)     -->  (let ((x y) (a a)) ...a...)
        B: ((lambda (x) ...a...) y)  -->  ((lambda (x y) ...a...) y a)

            $(call ^Y,$1,...,$$1$(call escape,$2)...)
        --> $(call ^Y,$1,$2,...,$$1$$2...)

       This would have to be done at the gen0 phase (without knowledge of
       file vs. expression context), but it improves performance
       independently of A & B, so it would be good anyway.  (But this can be
       done manually by the programmer, so maybe isn't as urgent.)


    Looking at the `let` case in particular (where we know A and B are
    relevant):

    text:   (define (f) (let ((a VAL)) BODY))
    nodes:  [["F" "call" "Q ^fset" "Q f" ["X" ["Y" ["X" BODY] VAL]]]
    file:   f = $(call ^Y,VAL,,,,,,,,,ESC_BODY)


    One special case that might be easy to approach is when a function
    begins with `let` (so the generated code begins a lambda call).  This is
    fairly frequent, but doesn't cover a majority.  Another common case is
    `(if arg1 (let ...))` and there are lots of other cases.


* Misc
    * Interleave compile with parsing of top-level expressions.
    * Improve void-node?  (void? (if c a b)) --> (and (void? a) (void? b))
    * Identify arguments using special IL record (vs. R)
         A n level           ->   local (arg)       $n


----------------------------------------------------------------
Examples to be written:

 - cleanPath
 - numerical ordering
 - regular expressions
 - makefile lisp templating
 - syracuse / ackerman / HOTPO
 - web server

----------------------------------------------------------------
Root causes of some BUGS I've encountered:

 * Wrong number of arguments (misplaced parentheses)  X2

   e.g.: (if ( ... ) ( ... ))
   vs:   (if ( ... )) ( ... )

         (f (g a b c) d)
   vs:   (f (g a) b c d)

 * Used `func` instead of `"func"`

 * Undefined variable name (at least 6 times)

 * Shadowed "eval" with user-defined function!

----------------------------------------------------------------

The following provide all of the capabilities that SCAM needs:

     * (if a b c)
     * (subst a b c)
     * (word n s)
     * (f ...) : calling a lambda expression.
     * (set a b)     [needed only for Make interop]

The following functions make some common operations more efficient (but can
be fiendishly difficult to employ correctly):

    wordlist, filter, filter-out, patsubst, findstring, foreach, join

; (define (concat a b)  (u (subst "!*" (d b) (subst 1 (d a) "1!*")))

; (define (eq a b)
;    (not (and (or a b)
;              (or (subst b "" a)
;                  (subst a "" b)))))

; (define (findstring a b)  (if (not (eq (subst a "" b) b)) a))

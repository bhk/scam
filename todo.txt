TODO:

 * builtins

    (? subst a b c)           Unsupported.

    subst                     `undefined variable: "subst"`

    (call "subst" 1 2)        Error.

    (define (subst a b c) 1)  Actually defines variable, but...
    (subst 1 2 123)           Does not call `subst` var, and...
    (subst 1 2)               Error (make exits).

 * Bundle needed indirect dependencies

 * Namespaces (see below)

 * WARN when shadowing variables!
    - AT LEAST FOR BUILTINS!
    - helps with problem of redefining built-ins in REPL
    - most common error case

 * scam -x file : when file requires other files...

 * properly locate errors in macros (associate with the right file)

 * num: / --> i/,  + --> i+,  ...

WISHLIST

 * (? macro ...)

 * arbitrary precision floating point
    - fp divide w/ specified precision
    - bug: (^ 2 100)  [in fp]

 * (data (Symbol pos name)
         (String pos text)
         (List pos @nodes)
         ...)

   Requires:
    - Use `case` to deconstruct.
    - Encode using nth-rest rather than (nth N .):  @ nodes
    - Encode using word rather than (nth N .):  &word pos
    - Fix compiler version dependency implicit in macro-style definitions
      that use "`" or "`".

 * "rest" and "spread" with "..." syntax

   More efficient append, vararg, apply, etc..

       [a b args... c]  ==>  (append [a b] args [c])
       (f a b args...)  ==>  (apply f [a b args...])
                        ==>  (apply f (append [a b] args))

   (define (f a v...)
      (g b a v...))

     (c1 "VA $ 7") ->  $(call ^d,$7) $(call ^d,^8) $9
     (c1 "VA $ 6") ->  $(foreach n,6 7 8,$(call ^d,$($n)))

     spread 7..9:  $(call ^n,1,REST),$(call ^n,2,REST),$(wordlist 3,9999,REST)
     $(call ^n,2,$(call ^d,$7) ... )       --> $7
     $(call ^n,2,<WORD> $(call ^d,$8) ...) --> $8
     ["f" "^n" "Q 1" ["VA" "$" 6]]         --> ["R" "$8"]
     $(wordlist 3,9999,<WORD> <WORD> $(wordlist A,B,R)) --> $(wordlist A,B,R))
     ["F" "wordlist" "Q 3" "Q 9999" ["VA" "$" 6]]       --> ["R" "$9"]

 * aliases: (define `X Y) should bind Y's defn (minus 'priv' bit) to X
   ... but this would break rewind.

 * Identify arguments using special IL record (vs. R)
      A n level           ->   local (arg)       $n

   (To simplify optimization.)

 * Integrate `strlen` with core.scm and use `strlen` to report column
   for errors.

 * check arg counts for all functions (not just inline functions)
    - export/import arg count

 * opt: replace "!0" with "~" ?

 * opt: constant folding across 'C' nodes, ^u, ^d, ^n, pure builtins

   - reduces size of qquote results

 * opt:  (if (not x) a b)  -->  (if (if x "" 1) a b)  -->  (if x b a)

   (*if* (*if* <exp> *C1* *C2*) <a> <b>)       where C1, C2 are constants
   --> (if <exp> (if C1 <b>) (if C2 <a>))

   (if TRUENODE a b)  -->  a
   (if VOIDNODE a b)  -->  b

 * opt: transformations

    - constant folding

        $(call demote,a b)  -->  a!0b

    - (if x (f a) (f b))  -->  (f (if x a b))

        f can take many forms: $(a/b),  $(call a/b,x,y,z),  [a/b ...]
        f represents the commonality between the forms (top-down?)

    - $(call scall,$(value v),...)  -->  $(call v,...)

    - Naming anonymous functions (when there are no upvalues).

      $$1$$2  -->  $(value <tmp>)     [where <tmp> = $1$2]

      With scall elimination:

         $(call scall,$$1$$2,...)  -->  $(call <tmp>,...)

    - upvalue elimination

      A: (let ((x y)) ...a...)  -->  (let ((x y) (a a)) ...a...)
      B: ((lambda (x) ...a...) y)  -->  ((lambda (x y) ...a...) y a)

            $(call scall,$(call escape,$1)$$1,$2)
        --> $(call scall,$$2$$1,$2,$1)

 * opt: maximize void-node?

   (void-node? (if x a b)) -->
      (and (or (void-node? a) (void-node? x))
           (or (void-node? a) (true-node? x)))

 * opt: interleave compile with parsing of top-level expressions

 * { key value[,] key value }

 * deconstruction in assignments:

    (let ( ([a b c] (f x)) ... ) ...)

    (case (f x)
       (["X" ,a ,b] ...)
       (["Y" ,a ,b ,c] ...)
       (,x ...))

   ["X" ,a ,@b]  =>  (append (demote "X") (demote ,a) ,b)
   (string ,x)   =>  ["S" (demote ,x)]
                 =>  (append (demote "S") (demote ,x))
                 =>  (append "S" (demote ,x))
                 =>  (concat "S" " " (demote ,x))
   MATCH x (append C p) x
     => (if (eq (wordlist 1 (words C) x) C)
            (unpack p (wordlist (+ 1 (words C)) 99999 x)))

   MATCH x (concat "str" p) x
     => (foreach ndx (indices a) (if

   ACTUALLY... declared variables should be unadorned symbols in the "match"
   portion of the case statement.  (Think of algebraic types.)

    (case VAL
       (["X" a b c] EXPR1)
       ...
       (value ...)


    (case VAL  ((ast-string n s) EXPR) ...)
    ==> (case VAL  (["S" n s] EXPR) ...)
    ==> (cond ((eq "S" (nth 1 VAL)) (let& ((n (nth 2 VAL)) (s nth 3 VAL) EXPR))) ...)

    (eq "X" (nth 1 VAL))
    ==> (filter "S" (word 1 VAL))

    eq q (promote x)  ==>  eq (demote q) x
    eq s (word ...)   ==>  filter s (word ...)

 * .min -> .make

 * Note potentially fatal:
      > (set "")
      v0/repl.min:40: *** empty variable name.  Stop.
      make: *** [interact] Error 2

 * To make hashes easily sortable by key, something other than
   "!=" -- maybe "!+" -- would be required.  (This could be subst'ed
   when sorting, however.)

 * ?: Use "file marker" to store file name in environment.
   (avoid globals, and fix improper reporting when dealing with macros?)

 * opt: Use "require markers" to reduce size of exports


Examples to be written:

 - cleanPath
 - numerical ordering
 - sort with arbitrary function
 - sortUnique
 - regular expressions
 - makefile lisp templating
 - syracuse / ackerman / HOTPO
 - web server


Macros, Namespaces, eval-when-compile
--------------------------------

Namespaces can be introduced as optional with minimal impact.  The
compiler's own modules could use this to minimize naming conflicts -- only
"exported" symbols would have to be unique.

 * (define `(macro a b c) ...)
   - execute require'd MIN files
   - declare & define macro: defmacro
   - macroexpand
   - splicing
   - gensym
   - macrolet

 * namespaces: V0 can compile & execute V1 without clobbering V0
    - (ns "prefix")
    - (declare (f a b c) (global "FULLNAME"))
    - (declare x (global "FULLNAME"))
    - (require LIB (prefix PREFIX)? (re-export)? ...)

 * compile-time tests
     (eval-when-compie
       (expect z (f  y)))


Compile-time execution
----

A big problem for SCAM is that compile-time assignments might clobber
running compiler functions.  Namespacing (used to distinguish generations of
the compiler) could help here.

Lisp-style macros demand compile-time execution of macros, and the functions
they call.  Arbitrary restrictions on what can be called in compile time
would limit the power of the feature.  Construction of complex user-defined
data values at compile-time is also useful.

Where do we draw the line between compile-time and run-time execution?  It's
clear that `main` can be defined at compile-time and executed only at run
time.  But what about top-level code (the file body)?

 - Execute it only at run-time.  (Current SCAM; does not allow for
   user-defined macros.)

 - Execute at run time BY DEFAULT.

   ELisp: compile- vs. run (load) time

    - (eval-and-compile BODY...) is evaluated at compile-time and again
      at run-time.  (Useful mainly for side-effects?)

    - (require ...) : at compile-time loads (runs) the required file
      to obtain functions and macros.

    - (defmacro ...) : compile-time and run-time

    - (eval-when-compile BODY...) compiles to a constant.

      (eval-when-compile
         (defmacro ...))

 - Execute at compile-time BY DEFAULT.

   Think of the module source file as a constructor of a module, and
   construction being a compile-time thing.  At run-time, the modules are
   not "executed", but the values they "return" (in SCAM, this means symbols
   visible in the environment at the end of the file) are assigned.  After
   modules are loaded, `main` is called, which triggers all "execution".

   Run-time variables and compile-time variables...

   (define X (^ 2 100))  ; computed at compile-time
   (define `X (^ 2 100)) ; lazy construct (executed where used)
   (eval-when-run ???)

Compile-time environment: dependencies for compile-time execution clean.
Compilation should be doable at a different time and place, and should not
vary with other environmental conditions that might affect the run time
behavior.  Maybe this should be up to the user (but we shouldn't make his
job too hard).

Debugging: If compilation involves Turing-complete user-defined operations,
the compiler/debugger won't know how to reverse the transformation to obtain
source-level meaning.


Compile-time execution should warn about clobbering the compiler's own
functions!

1. Macros require compile-time "execution".  It defines something at
   compile-time that affects how subsequent things are compiled.

2. How does compile-time execution relate to run-time?

   We cannot expect external inputs to match exactly,so execution path may
   differ.  What if the compile-time path runs through one 'defmacro' but
   the run-time path runs through another?

     (if (eq (DEBUG 1))
         (defmacro print (a) )
       (defmacro print (a) (info a)))

3. In CL, "compiler macros" must preserve semantics and cannot extend syntax.

   Does this mean that macros are fundamentally run-time?


macros into runtime?
--------------------

 * defmacro (compile time only)

    * compiler wants "run time only" behavior: emit code that sets
      "ml-macro-X" at run time.

    * compiler may elsewhere want "compile time only" behavior (for macros
      intended only for the compiler itself).

    * user code typically wants "compile time only", but may also want
      runtime only (macros in libraries)

    * Supporting (eval-at-compile ...) would work if:

        - compiler itself must be careful to cleanly segregate
          compile-time-only from runtime-only things (to avoid conflict with
          previous compiler) -- runtime is tricky here.

        - user code must avoid stepping on compiler

 * gen0 <-> macros dependency inversion

   gen0 has run-time dependency on macros, but not compile dependency.

----------------------------------------------------------------

Root causes of some BUGS I've encountered:

 * Wrong number of arguments (misplaced parentheses)  X2

   e.g.: (if ( ... ) ( ... ))
   vs:   (if ( ... )) ( ... )

         (f (g a b c) d)
   vs:   (f (g a) b c d)

 * Used `func` instead of `"func"`

 * undefined variable name (at least 6 times)

 * .v1/parse-q.min:51: *** target pattern contains no `%'.  Stop.

   (Top-level function returning value that gets re-interpreted by make.)

 * Overloaded "eval" with user-defined function!

 * Insufficient arguments to (word, ...)  -- could check at compile time.


----------------------------------------------------------------

(transform (node)
 ( `(car ,form) `(wordlist 2 99999999 ,form) )
 ( `(car ,@other) (form-error "car takes one argument" node)))

 ( `(let* ( (,name ,value) ,@bindings ) ,body)
   `( (lambda (,name)
        (let* ,bindings ,body))
      ,value ) ))


(transform ('car name)
           `(wordlist 2 99999999 ,name))

(transform ('let* ((name value) ...bindings) ...body)
           `( (lambda (,name)
                (let* ,bindings ,@body))
              ,value ))

(transform ('let* () ...body)
           `(progn ...body))

----------------------------------------------------------------
Reflections on Self-Hosting

Care must be taken to avoid circular definitions of the sort described in
the Ken Thompson paper **Reflections on Trusting Trust" (where "\t" is
defined as "\t").  In the extreme, we could reduce the source of the
compiler to:

    (define (main ...) (compile ...))

These circularities leave the definition "lost in the mists of time".  The
behavior is not present in the source; instead, it is propagated from one
compiled compiler to its progeny.

The immediate problem (for my purposes) is that the behavior, being absent
from the source, is not subject to modification, at least not directly. Any
compiler behavior can, of course, be reinvented, but the point is not to
maintain all of the behavior in source form.  Keeping the compiler
"grounded" while self-hosting is the challenge.

This is not cut-and-dried.  After all, whenever we write a compiler for
language *in* the same language, we are obviously dealing with cyclical
definitions.  It is acknowledged that a self-hosting compiler cannot serve
as a formal definition of language semantics.

   ... although I wonder about this.  A fully "grounded" self-hosting
   compiler might actually completely constrain the language definition,
   given that it must succeed in replicating itself.


How do we clearly distinguish the desirable and undesirable
circularities?  We can say, simply, that what is desirable is to express the
behavior of a compiler in its own language, and what is undesirable is to
have behavior that is not expressed in the sources.  Is that precise enough?
Let's look at some examples.


1. "\t" defined in terms of "\t"

   This is a trivial case, but it does, indeed, leave part of the definition
   "lost in the mists of time."  Instead, the compiler might emit code point
   9 (assuming an ASCII-based encoding), or use a tab character in a literal
   string (using the encoding of the source file.)

2. While compiling one of SCAM's `(if COND A B)` forms, the compiler itself
   will execute many different `if` forms.

   This is a problem from the formal semantics point of view, if we were to
   treat the sources as a language definition.  The sources don't tell us
   what `if` means unless we already know what `if` means.

   But if we do know what `if` means, we can tell whether the compiler
   sources emobdy the definition and are fully grouned.


----------------------------------------------------------------

GNU Make presents an odd set of building blocks.  Many of its builtin
functions are special-purpose and not suitable for general purpose
programming.

   wildcard, basename, notdir, dir, shell, ...

It lacks arithmetic.  No add, subtract, or comparison operators.

It lacks a notion of "character" in its string operations: no way to extract
a character by its index, or construct a character given its code, or obtain
the code for a character.

If doesn't even have an equality primitive.

But it is Turing-complete.  And you can build all of the above-mentioned
missing capabilities.


The following provide all of the capabilities that SCAM needs:

    if, subst, <concatenation>, <call-lambda>

    eval a = b, eval a := b, value    [not needed to make a useful language]

The following functions make some common operations more efficient (but can
be fiendishly difficult to employ correctly):

    word, wordlist, filter, filter-out, patsubst, findstring, foreach, join


; (define (eq a b)
;    (if (and (or a b)
;             (or (subst b "" a)
;                 (subst a "" b)))
;       nil
;       1)

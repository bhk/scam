TODO

 * --strip-comments

 * Data records

   - eliminate "Q%" tag
   - Document (data ...) and (case ...)
   - Make use of patterns in parser (and in data/case)
   - Use "!:" in IL (for pretty-printing)

 * Better reporting of errors during macro expansion (e.g. undefined symbols)

   Keep line numbers in macro defn, and track host file name as arg to
   expansion.  (Or: embed reference to file in macro env entry.) (Or: track
   file name via markers in the environment.)

 * (data NAME CTOR...) reflection

     (data-type VALUE)     -->  (DataType name arity ctor dtor)
       (DTOR VALUE)        -->  [MEMBER ...]
       (CTOR MEMBER...)    -->  VALUE

     (is-data? CTOR value)
     (data-tag CTOR)
     (data-tag value)
     (data-constructor tag/value)
     (data-tags)  -->  { tag: [typename args...], ...}  for all tags in scope

 * (case EXPR
      (CONST          EXPR)    ;; match constant
      ((CtorA "str" y) EXPR)   ;; match constant member
      (["A" a b]      EXPR)    ;; deconstruct vectors & match constants (always succeeds)
      (`SYNTAX        EXPR)    ;; ?
      ...)

 * new keywords: private, undefine, vpath

 * Custom constructors

   (data (Bind key value)
     rec (concat [key] "!=" [value])
     (key (first (subst "!=" " " rec)))
     (value (nth 2 (subst "!=" "! " rec)))
     (match (findstring "!=" rec)))

   (data (Bind key value)
     (concat [key] "!=" [value])
     (lambda (rec)
       [ (first (subst "!=" " " rec)) (nth 2 (subst "!=" "! " rec)) ])
     (lambda (rec)
       (findstring "!=" rec)))

 * (? lambda ...)  -->  (call "^tv" "any" (any ...))
   or:  (call "^yt" "any" (lambda (args) (any args)) ...)

 * Obtain value of builtin.  E.g. word -> "$(word $1,$2)"
   May fix (? builtin ...).

 * Bugs (see gen-test.scm)

 * Avoid function/builtin conflicts

    (define (word a b) 1)    Actually defines variable, but...
    (word 1 2)               Does not call defined function, and ...
    (word 1)                 Stop. (!)

 * check arg counts for all functions (not just inline functions)
    - export/import arg count

 * Parse hash syntax

 * WARN when shadowing variables!
    - most common error case (esp. builtins) (esp. in REPL)
    - allow `(let ((x x)) ...)` or `&shadow` exceptions

 * scam -x

   Make `require` work with source files in `scam [-x] FILE ...` commands.
   Build with `scam -o .scam/NAME` & then run.

 * c0 functions:  return [IL ...env] consistently.   When `inblock` is nil,
  `...env` can be nil.

 * arbitrary precision floating point
    - fp divide w/ specified precision
    - bug: (^ 2 100)  [in fp]

 * "rest" and "spread" with "..." syntax

   More efficient append, vararg, apply, etc..

       [a b args... c]  ==>  (append [a b] args [c])
       (f a b args...)  ==>  (apply f [a b args...])
                        ==>  (apply f (append [a b] args))

   (define (f a v...)
      (g b a v...))

     (c1 "VA $ 7") ->  $(call ^d,$7) $(call ^d,^8) $9
     (c1 "VA $ 6") ->  $(foreach n,6 7 8,$(call ^d,$($n)))

     spread 7..9:  $(call ^n,1,REST),$(call ^n,2,REST),$(wordlist 3,9999,REST)
     $(call ^n,2,$(call ^d,$7) ... )       --> $7
     $(call ^n,2,<WORD> $(call ^d,$8) ...) --> $8
     ["f" "^n" "Q 1" ["VA" "$" 6]]         --> ["R" "$8"]
     $(wordlist 3,9999,<WORD> <WORD> $(wordlist A,B,R)) --> $(wordlist A,B,R))
     ["F" "wordlist" "Q 3" "Q 9999" ["VA" "$" 6]]       --> ["R" "$9"]

 * aliases: (define `X Y) should bind Y's defn (minus 'priv' bit) to X
   ... but this would break rewind.

 * Integrate `strlen` with core.scm and use `strlen` to report column
   for errors.

 * looping constructs / named lambda

   http://www.scheme.com/tspl4/control.html#./control:h4

     let:  (let name ((var expr) ...) body...)

        (define (factorial n)
           (let f ((i n) (a 1))
             (if (> i 0)
                 (f (- i 1) (* a i))
                 a)))

     do:   (do ((var init update) ...) (test result ...) expr ...)

        (define (factorial n)
            (do ([i n (- i 1)]
                 [a 1 (* a i)])
                ((zero? i) a))))

 * .min -> .make

 * Move syntax quoting to scam-ct


Optimizations
----

 * (case NAME    -->  (foreach TMP (or (word 1 VALUE) "!.")
       (Foo a)    -->    (if (filter "TAG" TMP) ...))
        a         -->    (word 2 (^u TMP))  or  (word 2 VALUE)
   (case EXPR    -->  (foreach TMP [VALUE]
      (Foo a b)  -->    (if (filter "TAG!0%" "%") TMP) ...))  [always args]
      (Bar)      -->    (if (filter "TAG" "%") TMP) ...))     [no args]

 * Output a very limited environment when a module does not export macros or
   inline functions. (Any examples?)

 * Constant propagation:  (Call PURE CONST...) -->   (Const (PURE CONST...))

   Functions are PURE if they have no side-effects and produce a value that
   is purely a function of their inputs.  (No references to globals or I/O,
   and no calls to functions that might do so.)

   Properties of function nodes should be computed from the bottom-up to
   avoid repeatedly revisiting the same node. (Same for other nodes that
   contain other nodes.)

    - const?      [if so, will already be a Const node]
    - nil?        always evaluates to ""  (use in file code gen, blocks, conditionals..)
    - true?       always evaluates to non-empty string  (e.g. demote)
    - wordy?      result has no spaces or tabs?
    - vectory?    "!" occurs *only* in [" " "\t" "!" ""]
    - plain?      Contains no "!", spaces, tabs.
    - nout?       evaluation will NOT have side-effects (set, info, shell, ...)
    - nin?        result IS a purely function of inputs (does NOT read globals)

    wordy? and vectory? and true?  ==>  (demote (promote x)) == x
    nout? and nin?                 ==>  PURE

 * IF constant propagation:

    (if TRUE a b) -->  (Block TRUE a)
    (if VOID a b) -->  (Block VOID b)

 * IF strength reduction:

    (if (nth N VEC) ...)       -->  (if (subst "!." "" (word N VEC)) ...)
    (if (subst X TRUE Y) ...)  -->  (if (begin X TRUE Y) ...)

 * Block reduction:

     (Block PRE... POST)  -->  (Discard PRE)... POST

     (Discard NOUT)  --> ""  [all consts are NOUT]
     (Discard (Concat A B C)) -->  (Discard A) (Discard B) (Discard C)

 * IF-NOT reduction:  (if (not x) a b) -->  (if x b a)
 * IF-YES reduction:  (if (if C 1) a b) -->  (if C a b)

     Rule:    (if (if C A B) X Y)   --> (if C (if A X Y) (if B X Y))    [if A and B are true or nil]
     IF-NOT:  (if (if C nil 1) X Y) --> (if C (if nil X Y) (if 1 X Y))  [+const prop]
     IF-YES:  (if (if C TRUE) X Y)  --> (if X (if TRUE X Y) (if nil Y)) [+const prop]

 * IF CSE:  (if COND (f A) (f B))  -->  (f (if COND A B))

     Special case:  (if PURE 1 1) -->  (begin PURE 1)  -->  1

     This can be applied recursively to break apart complex commonality.
     Not good when A or B are constants and `f` is evaluatable.

 * Misc...

     (word N (wordlist A B VEC))      -->  nil  ...or...  (word N+A-1 VEC)
     (wordlist A B (wordlist C D VEC) --> (wordlist A+C-1 (min B D-C+1) VEC)

     (demote WORD)          -->  (subst "!" "!1" WORD)  [when word is not nil]
     (demote PLAIN)         -->  PLAIN
     (promote PLAIN)        -->  PLAIN

     (subst PURE PURE nil)  -->  nil
     (word PURE nil)        -->  nil

     (eq A B) ==
       (findstring A (findstring B A))  -->  (filter A B)
         When: A and B are words, and A does not contain "%" (e.g. $(words))

     (eq CONST (nth N V)) -->  (eq (demote CONST) (word N V))
                          -->  (filter (demote CONST) (word N V))

     (f (if COND X Y))   -->   (if COND (f X) (f Y))
       ... reduces when X or Y are constants e.g. demote
       (demote (if COND C1 C2)   -->  (if COND C3 C4)
       (if (not COND) A B) ==
          (if (if COND nil 1) EXPR)  -->  (if COND (if nil EXPR) (if 1 EXPR))


 * Extraction and naming of anonymous functions.  The main motivation is to
   make nested "let" blocks more efficient.  Currently size expands
   exponentially ... which directly impacts performance.  Deeper nesting is
   also a performance hit.

    A) Convert lambda literals to variable references:

          f = ...LAMBDA...  -->   tmpvar = $(unescape LAMBDA)
                                  f = ...$(value tmpvar)...

       Up-value references make this impossible, since the values are not
       known at tmpvar assignment time.

       This assumes compilation for file context.  In expression context
       we could do something like:

          ...LAMBDA...  -->  $(set tmpvar,LAMBDA)...$(value tmpvar)...

       ... but this will be unhelpful if the `set` is immediately prior to
       the value (the assignment has to be less nested).  Also, the assignment
       must be idempotent; any up-values will potentially corrupt the result.

    B) Lambda-call reduction:

          $(call ^Y,$(value x),...)  -->  $(call x,...)

    C) Up-value elimination:

        A: (let ((x y)) ...a...)     -->  (let ((x y) (a a)) ...a...)
        B: ((lambda (x) ...a...) y)  -->  ((lambda (x y) ...a...) y a)

            $(call ^Y,$1,...,$$1$(call escape,$2)...)
        --> $(call ^Y,$1,$2,...,$$1$$2...)

       This would have to be done at the gen0 phase (without knowledge of
       file vs. expression context), but it improves performance
       independently of A & B, so it would be good anyway.  (But this can be
       done manually by the programmer, so maybe isn't as urgent.)


    Looking at the `let` case in particular (where we know A and B are
    relevant):

    text:   (define (f) (let ((a VAL)) BODY))
    nodes:  [["F" "call" "Q ^fset" "Q f" ["X" ["Y" ["X" BODY] VAL]]]
    file:   f = $(call ^Y,VAL,,,,,,,,,ESC_BODY)


    One special case that might be easy to approach is when a function
    begins with `let` (so the generated code begins a lambda call).  This is
    fairly frequent, but doesn't cover a majority.  Another common case is
    `(if arg1 (let ...))` and there are lots of other cases.


* Misc
    * Interleave compile with parsing of top-level expressions.
    * Improve void-node?  (void? (if c a b)) --> (and (void? a) (void? b))
    * Identify arguments using special IL record (vs. R)
         A n level           ->   local (arg)       $n


----------------------------------------------------------------
Examples to be written:

 - cleanPath
 - numerical ordering
 - regular expressions
 - makefile lisp templating
 - syracuse / ackerman / HOTPO
 - web server

----------------------------------------------------------------
Root causes of some BUGS I've encountered:

 * Wrong number of arguments (misplaced parentheses)  X2

   e.g.: (if ( ... ) ( ... ))
   vs:   (if ( ... )) ( ... )

         (f (g a b c) d)
   vs:   (f (g a) b c d)

 * Used `func` instead of `"func"`

 * Undefined variable name (at least 6 times)

 * Shadowed "eval" with user-defined function!

----------------------------------------------------------------

The following provide all of the capabilities that SCAM needs:

     * (if a b c)
     * (subst a b c)
     * (word n s)
     * (f ...) : calling a lambda expression.
     * (set a b)     [needed only for Make interop]

The following functions make some common operations more efficient (but can
be fiendishly difficult to employ correctly):

    wordlist, filter, filter-out, patsubst, findstring, foreach, join

; (define (concat a b)  (u (subst "!*" (d b) (subst 1 (d a) "1!*")))

; (define (eq a b)
;    (not (and (or a b)
;              (or (subst b "" a)
;                  (subst a "" b)))))

; (define (findstring a b)  (if (not (eq (subst a "" b) b)) a))

----------------------------------------------------------------

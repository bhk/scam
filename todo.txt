TODO

 * Rename hash to "dictionary", "hash-..." to "dict-...".

 * Allow varargs in macros:
      Maybe:  (ILocal "1+" ups)
      At macro expand time, evalutes to precisely-sized vector.

 * Call-site tracing of lambda values

   (? lambda ...)  -->  (call "^tv" "any" (any ...))
   or:  (call "^yt" "any" (lambda (args) (any args)) ...)
   fix (? builtin ...) and (? macro ...).
   &inline functions then only good for (global-name ...) or Make interop.

 * (let (([a b c] vec)) ...)  [always succeeds; no "else" condition]

 * Record reflection.  What format-record needs:

    (data? value)
    (data-type value)    -> [ctor-name arity ctor dtor]

 * (case EXPR
      ([a b]        EXPR)   ;; deconstruct vectors [succeeds when?]
      (CONST        EXPR)   ;; match constant value (nil, for example)
      ((Ctor "K" y) EXPR)   ;; match constant member
      (["A" a b]    EXPR)   ;; match constant element (always succeeds)
      ...)

 * WARN when shadowing variables
    - allow `(let ((x x)) ...)` or `&shadow` exceptions

 * looping constructs / named lambda

   http://www.scheme.com/tspl4/control.html#./control:h4

     let:  (let name ((var expr) ...) body...)

        (define (factorial n)
           (let f ((i n) (a 1))
             (if (> i 0)
                 (f (- i 1) (* a i))
                 a)))

     do:   (do ((var init update) ...) (test result ...) expr ...)

        (define (factorial n)
            (do ([i n (- i 1)]
                 [a 1 (* a i)])
                ((zero? i) a))))

 * "spread" with "..." syntax.

 * build / bundling / namespaces

   Fix circular dependency for gen-testutils.

   scam-ct should not "require" runtime.

   Include namespace in MIN file names and variable names?
    + User modules need not conflict with compiler modules.
    - When `require` is compiled, module name is resolved to a variable or
      file, using "file map" and "bundle map".  Bundle map is built into the
      compiler (mod -> varname).  File map is passed to compile-file.

   compile-file: is-boot -> boot-mode
        r = runtime (no implicit deps for this module; no bundles)
        c = ct macros (runtime is implicit; no bundles)
        1 = in boot phase (no bundles)
        nil => "normal" mode
     is-boot & mod-files -> opts

   Compile via command to enable more parallelism.

 * use & executable macros

    - .out/a/scam ends up using NS='~' runtime, and also building and
      loading its own runtime for .out/b/xxx with NS='~'.  Assuming
      namespacing is used by only the compiler, this is only a problem for
      compiler builds, and is MOSTLY handled by the current NS usage -- c0 =
      "~", c1b = "", c1b = "~", c1c = "~" but is identical to c1b -- but the
      .out/a/scam / .out/b/runtime clash remains.

    - Syntax quoting is an incomplete feature because the resulting values
      are undefined.

       1. Expose "Form" data type to target code as part of the base env.
       2. Write converter from "Form" to internal type (namespacing must
          distinguish c0's from c1's "Form").
       3. Make this a no-op when we observe that Form == internal (could be
          a compiler-specific mechanism for deeper type reflection).

    - Macros don't have a good way to generate error messages or gensym
      (needs env).

    - Even with namespacing, "global" symbols remain.  More complete
      namespacing would help, but would complicate RT.  Maybe a new IL node
      would help here (IRT, akin to IBuiltin). Those *actually* used in
      codegen:

        ^u, ^d, ^n, ^set, ^fset, ^Y, ^E, ^av, ^t, ^require, ^start

 * aliases: (define `g f) assigns g the correct value, but arity information
   is lost, and it compiles to a lambda-call, not a call-by-name.

 * Custom constructors

   (data (Bind key value)
     (rec (concat [key] "!=" [value]))
     (key (first (subst "!=" " " rec)))
     (value (nth 2 (subst "!=" "! " rec)))a
     (match (findstring "!=" rec)))

 * scam -x

   Make `require` work with source files in `scam [-x] FILE ...` commands.
   Build with `scam -o .scam/NAME` & then run.

 * arbitrary precision floating point
    - fp divide w/ specified precision
    - bug: (^ 2 100)  [in fp]

 * Integrate `strlen` with core.scm and use `strlen` to report column
   for errors.

 * do / bind / return

   (do (a b <- f1 x)
       (c <- fn2 a b)
       (return c))


Optimizations
----

 * gen0/gen1 optimizations:
    * perf measurement section in gen0-q.scm
    * c0 inblock mode: can ILEnv return just the new env items?
    * optimize c0-block-cc
    * functions vs. macros for begin-block
    * revisit `is-balanced?`... aren't more things balanced?

 * parse.scm optimizations/rework
    * perf measurement
    * parse: replace (parse-seq ...) with (parse-formsXX ...)
    * parse: (POut nextpos form), not (POut lastpos form)
    * parse: errors are not nested in forms... Keep parsing after errors?
        (POut (1+ pos) (PError pos ...))
        (POut (1+ (words subj)) (PError pos ...))
    * Add SCAM_TAGS option to optimize "Form" tags; remove string
      tag-specifiers from `data` when done.

 * Recover crafted optimizations:
     (demote (promote x))  -->  x
     (nth N (rest x))  -->  (nth N+1 x)
     (rest (rest x))   -->  (nth-rest ...)
     (demote NUMBER)   -->  number
     (if (filter "!:x" (word 1 (first vec))) ...)
       -->  (if (filter "!1:x!0% !1:x" (word 1 vec)) ...)

     Number-ness validated by ... `cond` test,  `foreach` variable, ...

 * Tracing `scam` itself is problematic because the processing occurs after
   `main` exits (in the rule-processing phase).

 * (case NAME    -->  (foreach TMP (or (word 1 VALUE) "!.")
       (Foo a)    -->    (if (filter "TAG" TMP) ...))
        a         -->    (word 2 (^u TMP))  or  (word 2 VALUE)
   (case EXPR    -->  (foreach TMP [VALUE]
      (Foo a b)  -->    (if (filter "TAG!0%" "%") TMP) ...))  [always args]
      (Bar)      -->    (if (filter "TAG" "%") TMP) ...))     [no args]

 * Output a very limited environment when a module does not export macros or
   inline functions. (Any examples?)

 * Constant propagation:  (ICall PURE CONST...) -->   (Const (PURE CONST...))

   Functions are PURE if they have no side-effects and produce a value that
   is purely a function of their inputs.  (No references to globals or I/O,
   and no calls to functions that might do so.)

   Properties of function nodes should be computed from the bottom-up to
   avoid repeatedly revisiting the same node. (Same for other nodes that
   contain other nodes.)

    - const?      [if so, will already be a Const node]
    - nil?        always evaluates to ""  (use in file code gen, blocks, conditionals..)
    - true?       always evaluates to non-empty string  (e.g. demote)
    - wordy?      result has no spaces or tabs?
    - vectory?    "!" occurs *only* in [" " "\t" "!" ""]
    - plain?      Contains no "!", spaces, tabs.
    - nout?       evaluation will NOT have side-effects (set, info, shell, ...)
    - nin?        result IS a purely function of inputs (does NOT read globals)

    wordy? and vectory? and true?  ==>  (demote (promote x)) == x
    nout? and nin?                 ==>  PURE

 * IF constant propagation:

    (if TRUE a b) -->  (IBlock TRUE a)
    (if VOID a b) -->  (IBlock VOID b)

 * IF strength reduction:

    (if (nth N VEC) ...)       -->  (if (subst "!." "" (word N VEC)) ...)
    (if (subst X TRUE Y) ...)  -->  (if (begin X TRUE Y) ...)

 * Block reduction:

     (IBlock PRE... POST)  -->  (Discard PRE)... POST

     (Discard NOUT)  --> ""  [all consts are NOUT]
     (Discard (IConcat A B C)) -->  (Discard A) (Discard B) (Discard C)

 * IF-NOT reduction:  (if (not x) a b) -->  (if x b a)
 * IF-YES reduction:  (if (if C 1) a b) -->  (if C a b)

     Rule:    (if (if C A B) X Y)   --> (if C (if A X Y) (if B X Y))    [if A and B are true or nil]
     IF-NOT:  (if (if C nil 1) X Y) --> (if C (if nil X Y) (if 1 X Y))  [+const prop]
     IF-YES:  (if (if C TRUE) X Y)  --> (if X (if TRUE X Y) (if nil Y)) [+const prop]

 * IF CSE:  (if COND (f A) (f B))  -->  (f (if COND A B))

     Special case:  (if PURE 1 1) -->  (begin PURE 1)  -->  1

     This can be applied recursively to break apart complex commonality.
     Not good when A or B are constants and `f` is evaluatable.

 * Misc...

     (word N (wordlist A B VEC))      -->  nil  ...or...  (word N+A-1 VEC)
     (wordlist A B (wordlist C D VEC) --> (wordlist A+C-1 (min B D-C+1) VEC)

     (demote WORD)          -->  (subst "!" "!1" WORD)  [when word is not nil]
     (demote PLAIN)         -->  PLAIN
     (promote PLAIN)        -->  PLAIN

     (subst PURE PURE nil)  -->  nil
     (word PURE nil)        -->  nil

     (eq? A B) ==
       (findstring A (findstring B A))  -->  (filter A B)
         When: A and B are words, and A does not contain "%" (e.g. $(words))

     (eq? CONST (nth N V)) -->  (eq? (demote CONST) (word N V))
                          -->  (filter (demote CONST) (word N V))

     (f (if COND X Y))   -->   (if COND (f X) (f Y))
       ... reduces when X or Y are constants e.g. demote
       (demote (if COND C1 C2)   -->  (if COND C3 C4)
       (if (not COND) A B) ==
          (if (if COND nil 1) EXPR)  -->  (if COND (if nil EXPR) (if 1 EXPR))


 * Extraction and naming of anonymous functions.  The main motivation is to
   make nested "let" blocks more efficient.  Currently size expands
   exponentially ... which directly impacts performance.  Deeper nesting is
   also a performance hit.

    A) Convert lambda literals to variable references:

          f = ...LAMBDA...  -->   tmpvar = $(unescape LAMBDA)
                                  f = ...$(value tmpvar)...

       Up-value references make this impossible, since the values are not
       known at tmpvar assignment time.

       This assumes compilation for file context.  In expression context
       we could do something like:

          ...LAMBDA...  -->  $(set tmpvar,LAMBDA)...$(value tmpvar)...

       ... but this will be unhelpful if the `set` is immediately prior to
       the value (the assignment has to be less nested).  Also, the assignment
       must be idempotent; any up-values will potentially corrupt the result.

    B) Lambda-call reduction:

          $(call ^Y,$(value x),...)  -->  $(call x,...)

    C) Up-value elimination:

        A: (let ((x y)) ...a...)     -->  (let ((x y) (a a)) ...a...)
        B: ((lambda (x) ...a...) y)  -->  ((lambda (x y) ...a...) y a)

            $(call ^Y,$1,...,$$1$(call escape,$2)...)
        --> $(call ^Y,$1,$2,...,$$1$$2...)

       This would have to be done at the gen0 phase (without knowledge of
       file vs. expression context), but it improves performance
       independently of A & B, so it would be good anyway.  (But this can be
       done manually by the programmer, so maybe isn't as urgent.)


    Looking at the `let` case in particular (where we know A and B are
    relevant):

    text:   (define (f) (let ((a VAL)) BODY))
    nodes:  [["F" "call" "Q ^fset" "Q f" ["X" ["Y" ["X" BODY] VAL]]]
    file:   f = $(call ^Y,VAL,,,,,,,,,ESC_BODY)


    One special case that might be easy to approach is when a function
    begins with `let` (so the generated code begins a lambda call).  This is
    fairly frequent, but doesn't cover a majority.  Another common case is
    `(if arg1 (let ...))` and there are lots of other cases.


* Misc
    * num: (> 5 0) not working?
    * num: treat nil as identity value for each operator: (+ 1) == (+ 1 nil...) == 1
    * num: multi-arg + and *
    * Interleave compile with parsing of top-level expressions.
    * Improve void-node?  (void? (if c a b)) --> (and (void? a) (void? b))
    * Identify arguments using special IL record (vs. R)
         A n level           ->   local (arg)       $n


----------------------------------------------------------------
Examples to be written:

 - cleanPath
 - numerical ordering
 - regular expressions
 - makefile lisp templating
 - syracuse / ackerman / HOTPO
 - web server

----------------------------------------------------------------
Root causes of some BUGS I've encountered:

 * Wrong number of arguments (misplaced parentheses)  X2

   e.g.: (if ( ... ) ( ... ))
   vs:   (if ( ... )) ( ... )

         (f (g a b c) d)
   vs:   (f (g a) b c d)

 * Used `func` instead of `"func"`

 * Undefined variable name (at least 6 times)

 * Shadowed "eval" with user-defined function!

----------------------------------------------------------------

The following provide all of the capabilities that SCAM needs:

     * (if a b c)
     * (subst a b c)
     * (word n s)
     * (f ...) : calling a lambda expression.
     * (set a b)     [needed only for Make interop]

The following functions make some common operations more efficient (but can
be fiendishly difficult to employ correctly):

    wordlist, filter, filter-out, patsubst, findstring, foreach, join

; (define (concat a b)  (u (subst "!*" (d b) (subst 1 (d a) "1!*")))

; (define (eq? a b)
;    (not (and (or a b)
;              (or (subst b "" a)
;                  (subst a "" b)))))

; (define (findstring a b)  (if (not (eq? (subst a "" b) b)) a))


--------------------------------

Assignment and control flow: matching, parsing

Monads <-> exceptions
do         try

  ;; (PSymbol n name) <- func else (warn func "FUNC" "(? FUNC ...)")
  ;; (case func ((PSymbol n name) ...) (else (warn func "FUNC" "(? FUNC ...")))
  ;; (match func (PSymbol n name) else (warn ...)) ...

  (match (PSymbol n name) func
         else (warn ...))
  ...

--------------------------------

Namespace/boot discusssion
----

Assume compiler c0, compiled from unknown sources.  Everything about *how*
it works is a mystery; the language definition is all that is known.  All it
does is compile sources to programs in the default (un-prefixed) namespace.
Our first step:

$ c0 -o c1 c.scm

Presumably, this program will include a runtime that was bundled with c0,
suitably namespaced to avoid collisions with our program's functions.
But we can't even assume that it has a runtime.  Certainly it does not
use the runtime in the c1 sources.

Ideally, c1 would be fully functional, so that we could proceed to:

$ c1 -o prog prog.scm

...but we aren't ready to, because *our* compiler -- the c1 source code
-- makes use of a runtime that must be bundled with any program we
generated.  That runtime is a separate source file, also written in SCAM.
It cannot be compiled with c0, because c0 generates only programs, not
discrete modules.  Even if it did, the discrete module would presumably
have external dependencies the way *our* generate code will have
dependencies on our runtime.  Just as our generated code will drag along
our runtime, c0's might drag along a copy of its runtime, and after a few
generations things can get quite large and conflicts get harder to avoid.

So we need c1 to compile its own runtime.  Maybe a special command-line
option will suffice for this "mode" of operation:

$ c1 --boot -o prog prog.scm

It will have to be careful to avoid having runtime code depending on
things not yet defined later in the runtime, but with knowledge of c1
codegen and runtime we could achieve this.  Once built, it will bundle
the runtime with the program it generates, leaving it with a standalone
program.

We still want to arrive at a standalone *compiler*, and in addition to
having its embedded runtime requirements met, it will also want to
extract a copy of that runtime from itself for bundling with programs it
generates.

That, in turn, generates namespacing concerns.  We want compiled code to
be able to run alongside compiler code in one instance of Make -- the
'-e' and interactive modes require this.  That means the generated code
uses a different namespace (the default namespace).  That means the
compiler must get OUT OF the default namespace.  And then how can it
share the runtime (on one namespace) with the generated code?

Currently in SCAM:

 - c1 (c1a) compiles c1b, and c1b uses a special namespace ("~" prefix).

 - c1b can then generate code in the deafult namespace.

 - However, once we promote c1b to be the new "c0", we will have a c0
   that internally uses the "~" namespace.  And therefore the next c1a
   will end up using a "~" runtime, the same as the next c1b that c1a
   generates.  This can cause problems when c1a executes code it
   generated for c1b.

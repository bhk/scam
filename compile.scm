
;;----------------------------------------------------------------
;; compile.scm
;;----------------------------------------------------------------

(require "core")
(require "parse")
(require "gen")
(require "gen0")
(require "gen1")
(require "io")

;; The following diagram summarizes the stages of compiling a SCAM
;; expression:
;;
;;               pos                 env
;;                |                   |
;;                v                   v
;;   text    +---------+   form   +------+    IL    +------+   exe
;;  -------->|  parse  |--------->|  c0  |--------->|  c1  |-------->
;;           +---------+          +------+          +------+
;;                |                   |                 |    errors
;;                v                   v                 +----------->
;;               pos                 env
;;
;; Each expression begins at a position "pos" (a numeric index into the
;; sequence of tokens in the subject text).  Parsing emits a "form" (an AST
;; node) and a position at which to look for subsequent expressions.
;;
;; The compiler front end (c0) operates on a form and an environment (a set
;; of symbol bindings), and emits an IL node and a new environment, since
;; expressions (e.g. `declare` and `define`) can alter the environment for
;; subsequent expressions.
;;
;; The compiler back end (c1) emits executable code (Make source) and a
;; (hopefully empty) vector of errors.  The form and IL data structures can
;; convey errors as well as successful results; c1 must output a separate
;; value for error information.


(begin
  ;; Load macros. We don't directly call from this module, but it registers
  ;; functions called from gen0.
  (require "macros"))

(and nil
     ;; Do not load these modules, but treat them as dependencies and bundle
     ;; them with the compiler.
     (require "utf8")
     (require "scam-ct"))


;; Compile SCAM source to executable code.
;;
;; Returns:
;;    { code: CODE, errors: ERRORS, env: ENV-OUT, requires: MODS, uses: MODS }
;;
;; TEXT = SCAM source
;; ENV = Initial environment. This is normally generated by compile-prelude.
;;       It includes exports from implicit modules, unless the file being
;;       compiled is itself an implicit module.  When called from the REPL,
;;       this will contain additional bindings from the user's session.
;; INFILE = Input file name (or '[command line]').
;; IS-FILE = When nil, code will be compiled for function syntax.  When
;;           non-nil, code will be compiled for file syntax.
;;
(define (compile-text text env infile is-file)
  &public
  (let-global ((*compile-subject*  (penc text))
               (*compile-file*     infile))

    (c0-block-cc env
                 (parse-subject *compile-subject*)
                 (lambda (env-out nodes)
                   (concat (gen1 nodes is-file) " " {env: env-out})))))


;; Return an initial environment (standard prelude).
;;
;; We construct this by calling `require` and `use` on "implicit" modules,
;; bute that is a compiler implementation detail.  User programs do not know
;; of these modules, and should always receive builtin versions.  When
;; compiling the compiler itself, however, we obtain these from source
;; files.
;;
;; EXCLUDES = string of characters that disable implicit dependencies:
;;            "" = default; "R" avoids runtime; "C" avoids scam-ct, "RC" both.
;;
;; On error, the result wil contain {=ErrorMarkerKey:...} pair.
;;
(define (compile-prelude excludes)
  &public
  (append (if (not (findstring "R" excludes))
              (get-module-env "'runtime" nil))
          (if (and (not (findstring "C" excludes))
                   (not *is-boot*))
              (use-module-env "'scam-ct"))))


(define `(construct-file infile env exe reqs uses)
  (define `(to-ids origins)
    (for m origins
         (module-id m)))
  (concat "# compiled from " infile "\n"
          (if reqs (concat "# Requires: " (to-ids reqs) "\n"))
          (if uses (concat "# Uses: " (to-ids uses) "\n"))
          (env-export-line env)
          exe))


;; Replace the first line with a blank line if it begins with "#".
;;
(define (trim-hashbang text)
  (if (filter "#%" (word 1 text))
      (concat "\n" (concat-vec (rest (split "\n" text)) "\n"))
      text))


(define (implicit-mod name flag flags)
  (if (not (findstring flag flags))
      (if *is-boot*
          (concat name ".scm")
          (concat "'" name))))


;; Compile a SCAM source file and write out a .min file.  On failure,
;; display errors.
;;
;; INFILE = source file name (to be read)
;; OUTFILE = object file name (to be written)
;; EXCLUDES = see compile-prelude
;;
;; Returns: nil on success, error description on failure.
;;
(define (compile-module infile outfile excludes)
  &public
  (define `text (trim-hashbang (read-file infile)))

  (define `imports
    (let-global ((*compile-file* infile))
      (compile-prelude excludes)))

  (let ((o (compile-text text imports infile outfile))
        (ireq (implicit-mod "runtime" excludes "R"))
        (iuse (implicit-mod "scam-ct" excludes "C"))
        (infile infile)
        (outfile outfile))
    (define `errors (dict-get "errors" o))
    (define `exe (dict-get "code" o))
    (define `env-out (dict-get "env" o))
    (define `reqs (append (dict-get "require" o) ireq))
    (define `uses (append (dict-get "use" o) iuse))

    (if errors
        ;; Error
        (begin
          (for e errors
               (info (describe-error e text infile)))
          (subst "S" (if (word 2 errors) "s" "")
                 "compilation errorS"))
        ;; Success
        (begin
          (mkdir-p (dir outfile))
          (write-file outfile
                      (construct-file infile env-out exe reqs uses))))))


(define (error-if desc)
  (if desc
      (error desc)))


;; Compile a SCAM source file and write out a .min file.  On failure,
;; display errors and terminate execution.
;;
;; INFILE = source file name (to be read)
;; OUTFILE = object file name (to be written)
;; FILE-MODS = module origins that have been compiled
;; EXCLUDES = see compile-prelude
;;
(define (compile-file infile outfile file-mods excludes)
  &public
  (let-global ((*file-mods* (for m file-mods
                                 (if (module-is-source? m)
                                     (module-id m)))))
    (error-if (compile-module infile outfile excludes))))

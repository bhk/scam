;;----------------------------------------------------------------
;; compile.scm
;;----------------------------------------------------------------

(require "core")
(require "parse")
(require "gen")
(require "gen0")
(require "gen1")
(require "io")

;; The following diagram summarizes the stages of compiling a SCAM
;; expression:
;;
;;               pos                 env
;;                |                   |
;;                v                   v
;;   text    +---------+   form   +------+    IL    +------+   exe
;;  -------->|  parse  |--------->|  c0  |--------->|  c1  |-------->
;;           +---------+          +------+          +------+
;;                |                   |                 |    errors
;;                v                   v                 +----------->
;;               pos                 env
;;
;; Each expression begins at a position "pos" (a numeric index into the
;; sequence of tokens in the subject text).  Parsing emits a "form" (an AST
;; node) and a position at which to look for subsequent expressions.
;;
;; The compiler front end (c0) operates on a form and an environment (a set
;; of symbol bindings), and emits an IL node and a new environment, since
;; expressions (e.g. `declare` and `define`) can alter the environment for
;; subsequent expressions.
;;
;; The compiler back end (c1) emits executable code (Make source) and a
;; (hopefully empty) vector of errors.  The form and IL data structures can
;; convey errors as well as successful results; c1 must output a separate
;; value for error information.


(begin
  ;; Load macros. We don't directly call from this module, but it registers
  ;; functions called from gen0.
  (require "macros"))

(and nil
     ;; Do not load these modules, but treat them as dependencies and bundle
     ;; them with the compiler.
     (require "utf8")
     (require "scam-ct"))


;; Compile SCAM source to executable code.
;;
;; Returns:
;;    { code: CODE, errors: ERRORS, env: ENV-OUT }
;;
;; TEXT = SCAM source
;; ENV = Initial environment. This is normally generated by compile-prelude.
;;       It includes exports from implicit modules, unless the file being
;;       compiled is itself an implicit module.  When called from the REPL,
;;       this will contain additional bindings from the user's session.
;; INFILE = Input file name (or '[command line]').
;; OUTFILE = When nil, code will be compiled for function syntax.  When
;;           non-nil, code will be compiled for file syntax.
;;
(define (compile-text text env infile outfile)
  &public
  (let-global ((*compile-subject*  (penc text))
               (*compile-file*     infile))

    (c0-block-cc env
                 (parse-subject *compile-subject*)
                 (lambda (env-out nodes)
                   (concat (gen1 nodes outfile) " " {env: env-out})))))


;; Return an initial environment (standard prelude).
;;
;; We construct this by calling `require` and `use` on "implicit" modules,
;; bute that is a compiler implementation detail.  User programs do not know
;; of these modules, and should always receive builtin versions.  When
;; compiling the compiler itself, however, we obtain these from source
;; files.
;;
;; EXCLUDES = string of characters that disable implicit dependencies:
;;            "" = default; "R" avoids runtime; "C" avoids scam-ct, "RC" both.
;;
;; On error, the result wil contain {=ErrorMarkerKey:...} pair.
;;
(define (compile-prelude excludes)
  &public
  (append (if (not (findstring "R" excludes))
              (get-module-env "'runtime" nil))
          (if (and (not (findstring "C" excludes))
                   (not *is-boot*))
              (use-module "'scam-ct"))))


(define `(construct-file infile env exe reqs uses)
  (define `(to-ids origins)
    (for m origins
         (module-id m)))
  (concat "# compiled from " infile "\n"
          (if reqs (concat "# Requires: " (to-ids reqs) "\n"))
          (if uses (concat "# Uses: " (to-ids uses) "\n"))
          (env-export-line env)
          exe))


;; Remove the first line if it begins with "#".
;;
(define (trim-hashbang text)
  (if (filter "#%" (word 1 text))
      (concat "\n" (concat-vec (rest (split "\n" text)) "\n"))
      text))


;; Compile a SCAM source file and write out a .min file.
;;
;; INFILE = source file name (to be read)
;; OUTFILE = object file name (to be written)
;; FILE-MODS = module origins that have been compiled
;; REQS = IDs `require`d by this module (output in "Requires: ...")
;; USES = IDs `use`d by this module (output in "Uses: ...")
;; EXCLUDES = see compile-prelude
;;
;;    Note: "Requires: ..." and "Uses: ..." comments are used only when
;;    pulled from builtin modules (otherwise we use sources to determine
;;    dependencies).  Bulting modules can only reference other builtins, and
;;    builtins are compiler-provided, so ID and ORIGIN values are identical.
;;
;; Returns: "OK" on success.
;;
(define (compile-file infile outfile file-mods reqs uses excludes)
  &public

  (let-global ((*file-mods* (for m file-mods
                                 (if (module-is-source? m)
                                     (module-id m))))
               (*compile-file* infile))
    (let ((text (trim-hashbang (read-file infile)))
          (outfile outfile)
          (imports (compile-prelude excludes)))
      (let ((o (compile-text text imports infile outfile))
            (text text)
            (infile infile)
            (outfile outfile))
        (begin
          (define `errors (dict-get "errors" o))
          (define `exe (dict-get "code" o))
          (define `env-out (dict-get "env" o))

          (if errors
              ;; Error
              (begin
                (for e errors
                     (info (describe-error e text infile)))
                (error (subst "%S" (if (eq? 1 (words errors)) "" "s")
                              "compilation error%S")))

              ;; Success
              (begin
                (mkdir-p (dir outfile))
                (write-file outfile
                            (construct-file infile env-out exe reqs uses)))))))))

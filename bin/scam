#!/bin/bash
:; for v in "${@//!/!1}" ; do v=${v// /!0} ; v=${v//	/!+}; a[++n]=${v:-!.} ; done ; LC_ALL=C SCAM_ARGS=${a[*]} exec make -Rr --no-print-directory -f"$0" 9>&1
SCAM_MOD := scam
^uid := 7551dd9fb105cfca

define [mod-scam]
# Requires: core repl getopts compile gen io
# Exports: 
$(call ^R,core)
$(call ^R,repl)
$(call ^R,getopts)
$(call ^R,compile)
$(call ^R,gen)
$(call ^R,io)
~usage-string := Usage:$'$'    scam [-i]                  Enter interactive mode$'    scam -o FILE [OPTS] FILE   Build an executable from SRC$'    scam -e EXPR               Eval and print value of expression$'    scam [-x] FILE ARGS...     Compile and execute FILE$'    scam -v / --version        Show version$'    scam -h                    Show this message$'$'Options:$'$'  --quiet         Do not display progress messages$'  --obj-dir DIR   Specify directory for intermediate files$'  --              Stop processing options$'
define ~perror
$(and $(call ~fprintf,2,scam: $1
,$(foreach N,2,$(^v)))1,1)
endef
~set-obj-dir = $(call ^set,~*obj-dir*,$(patsubst %//,%/,$(or $1,$(if $2,$(dir $2),.scam/))/))
~main = $(call ^Y,$(call ~getopts,$1,-o= -e= -v --version -h -x -i --quiet --obj-dir= --boot),,,,,,,,,$`(and $`(call ^set,~*is-quiet*,$`(call ~dict-get,quiet,$`1))1,$`(call ^set,~*is-boot*,$`(call ~dict-get,boot,$`1))1,$`(call ~set-obj-dir,$`(call ^u,$`(lastword $`(call ~dict-get,obj-dir,$`1))),$`(call ^u,$`(lastword $`(call ~dict-get,o,$`1))))1,$`(if $`(call ~dict-get,!,$`1),$`(and $`(foreach e,$`(call ~dict-get,!,$`1),$`(call ^d,$`(if $`(filter !:GetoptsError0,$`(word 1,$`(call ^u,$`e))),$`(call ~perror,'%s' is missing an argument,$`(call ^n,2,$`(call ^u,$`e))),$`(if $`(filter !:GetoptsError1,$`(word 1,$`(call ^u,$`e))),$`(call ~perror,'%s' is not a recognized option,$`(call ^n,2,$`(call ^u,$`e))),$`(call ~perror,[internal error])))))1,$`(call ~perror,try 'scam -h' for help)),$`(if $`(call ~dict-get,h,$`1),$`(info $`(~usage-string)),$`(if $`(call ~dict-get,o,$`1),$`(if $`(word 2,$`(call ~dict-get,*,$`1)),$`(call ~perror,to many input files were given with `-o`),$`(call ~build-program,$`(call ^n,1,$`(call ~dict-get,*,$`1)),$`(call ^u,$`(lastword $`(call ~dict-get,o,$`1))))),$`(if $`(call ~dict-get,e,$`1),$`(and $`(foreach expr,$`(call ~dict-get,e,$`1),$`(call ^d,$`(if $`(call ~repl-rep,$`(call ^u,$`(expr))),$`(error Error))))1,),$`(if $`(or $`(call ~dict-get,v,$`1),$`(call ~dict-get,version,$`1)),$`(info SCAM version 1.4x),$`(if $`(call ~dict-get,x,$`1),$`(if $`(if $`(call ~dict-get,*,$`1),,1),$`(call ~perror,no FILE was given with '-x'),$`(call ~run-program,$`(call ^n,1,$`(call ~dict-get,*,$`1)),$`(wordlist 2,99999999,$`(call ~dict-get,*,$`1)))),$`(if $`(if $`(call ~dict-get,*,$`1),,1),$`(and $`(info SCAM v1.4x interactive mode. Type '?' for help.)1,$`(call ~repl)),$`(if $`(call ~dict-get,i,$`1),$`(call ~perror,extraneous arguments were provided with -i),$`(call ~run-program,$`(call ^n,1,$`(call ~dict-get,*,$`1)),$`(wordlist 2,99999999,$`(call ~dict-get,*,$`1)))))))))))))

endef

define [mod-runtime]
# Requires: 
# Exports: at-exit#tracing(3;~untrace[:IL3'~trace',@\01\00[@'2'0 do-not-trace#untrace}1'or'2 trace#*obj-dir*{0;~%;i ^tags{0;%;i filtersub}3 bound?&1;!1.;!1:IL2;if[:IL2'filter-out',|\0u!p',:IL2\0flavor\0,1@,01,00[|'1 rrest&1;!1.;!1:IL2;wordlist[|'3[|'99999999[@'1'0 rest&1;!1.;!1:IL2;wordlist[|'2[|'99999999[@'1'0 first&1;!1.;!1:IL3;^n[|'1[@'1'0 nth-rest(2;wordlist[@'1'0[|'99999999[@'2'0 not&1;!1.;!1:IL2;if[@'1'0[|'\.[|'1 nil{2;!1.;i;!1|;!1. set-native-fn&2'or'3;!1.;!1:IL3;^fset[@'1'0[@'2'0[@'3'0 set-native&2'or'3;!1.;!1:IL3;^set[@'1'0[@'2'0[@'3'0 nth(3;^n[@'1'0[@'2'0 demote&1;!1.;!1:IL3;^d[@'1'0 promote&1;!1.;!1:IL3;^u[@'1'0 apply(3;^%[@'1'0[@'2'0 name-apply(3;^na[@'1'0[@'2'0
~*do-not-trace* := $(value .VARIABLES)
define '


endef
 [ := (
 ] := )
" := \#
' := $'
` := $$
& := ,
$(if ,, ) :=

^d = $(or $(subst $  ,!0,$(subst $ 	,!+,$(subst !,!1,$1))),!.)
^u = $(subst !1,!,$(subst !+,	,$(subst !0, ,$(subst !.,,$1))))
^n = $(subst !1,!,$(subst !+,	,$(subst !0, ,$(subst !.,,$(word $1,$2)))))
^k = $(subst %,!8,$(^d))
^Y = $(call if,,,$(10))
^v = $(subst !.,!. ,$(filter-out %!,$(subst !. ,!.,$(foreach n,$(wordlist $N,9,1 2 3 4 5 6 7 8),$(call ^d,$($n)))$(if $9, $9) !)))
^av = $(foreach N,1,$(^v))
^apply = $(call ^Y,$(call ^n,1,$2),$(call ^n,2,$2),$(call ^n,3,$2),$(call ^n,4,$2),$(call ^n,5,$2),$(call ^n,6,$2),$(call ^n,7,$2),$(call ^n,8,$2),$(wordlist 9,99999999,$2),$1)
^na = $(call if,,,$`(call $1$(subst $(if ,, ,),$(if ,,,),$(foreach n,$(wordlist 1,$(words $2),1 2 3 4 5 6 7 8),$(if ,,,$`(call ^n,$n,$`2))))$(if $(word 9,$2),$(if ,,,$`(wordlist 9,99999999,$`2)))))
define ^f
"$(subst 
,\n,$(subst ",\",$(subst \,\\,$1)))"
endef
^tp = $(info $1 $(call ^f,$2))$2
^tc = $(call $1,$2,$3,$4,$5,$6,$7,$8,$(call ^n,1,$9),$(wordlist 2,9999,$9))
^ta = $(if $(or $1,$2,$3,$4,$5,$6,$7,$8,$9), $(^f)$(call ^tc,^ta,$2,$3,$4,$5,$6,$7,$8,$9))
^t = $(info --> ($1$(call ^tc,^ta,$2,$3,$4,$5,$6,$7,$8,$9)))$(call ^tp,<-- $1:,$(call ^tc,$1,$2,$3,$4,$5,$6,$7,$8,$9))
define ~esc-LHS
$`(if ,,$(subst $],$`],$(subst $[,$`[,$(subst 
,$`',$(subst #,$`",$(subst $`,$`$`,$1))))))
endef
define ^set
$(eval $(call ~esc-LHS,$1) :=$` $(subst 
,$`',$(subst #,$`",$(subst $`,$`$`,$2))))$3
endef
define ^fset
$(and $(eval define $(call ~esc-LHS,$1)
$(subst \$ 
,\$` 
,$(subst define,$` define,$(subst endef,$` endef,$2
)))endef
)1,$3)
endef
define ^E
$(subst $`,$`$2,$`(if ,,$(subst 
,$`',$(subst $[,$`[,$(subst $],$`],$(subst $`,$``,$1))))))
endef
~filtersub = $(patsubst $1,$2,$(filter $1,$3))
^tags := 
^at = $(call ^set,^tags,$(^tags) $(filter-out $(^tags),$1))
~*required* := 
SCAM_DIR := 
~*obj-dir* := .scam/
^load = $(and $(if $(if $(filter-out u%,$(flavor [mod-$1])),1),$(eval $(value [mod-$1])),$(eval include $(or $(and $(SCAM_DIR),$(wildcard $(SCAM_DIR)$1.o)),$(~*obj-dir*)$1.o)))1,$1)
^R = $(and $(or $(filter $1,$(~*required*)),$(and $(call ^set,~*required*,$(~*required*) $1)1,$(call ^load,$1)))1,)
~trace-info = $(info TRACE: $1$2$3$4)
~trace-digits = $(if $(findstring /1111111111,$1),$(call ~trace-digits,$(subst /1111111111,1/,$1)),$(subst !:,,$(subst :!,0!,$(subst :0,::,$(subst :00,:::,$(subst :0000,:::::,$(subst $  ,,!:$(foreach d,/$(subst /, /,$1),$(words $(subst /,,$(subst 1, 1,$d))))!:)))))))
~trace-words = $(if $(word $1,$2),$2,$(call ~trace-words,$1,1 $2))
~trace-body = $(subst :D,$4,$(subst :N,$2,$(subst :C,$`(call [S-$3],$`1,$`2,$`3,$`4,$`5,$`6,$`7,$`8,$`9),$(subst :E,$`(eval ^TI:=$`$`(^TI) ):C$`(eval ^TI:=$`$`(subst x ,,x$`$`(^TI))),$(subst :I,info $`(^TI),$(if $(filter c,$1),$(and $(call ^set,[K-$3],$(or $(value [K-$3]),///////),)1,$`(eval [K-$3]:=$`(subst /1111111111,1/,$`([K-$3])1)):D),$(if $(filter p%,$1),$(subst :,:$` ,$(call ^u,$(patsubst p%,%,$1))):D,$(if $(filter t f,$1),$(if $(or $(filter f,$1),$(filter ^ta ^f ^tc ^tp ^n,$2)),$`(:I--> :N):E$`(:I<-- :N),$`(:I--> (:N$`(^ta)))$`(call ^tp,$`(^TI)<-- :N:,:E)),$(if $(filter x%,$1),$`(foreach ^X,1,:C)$`(if $`(^X),,$`(if $`(foreach ^X,$(wordlist 2,99999999,$(call ~trace-words,$(or $(patsubst x%,%,$1),11),1)),$`(if :C,)),)),$(error TRACE: Unknown mode: '$1'))))))))))
~trace-match = $(filter-out $(foreach p,^% ~% ~trace% ~esc-% ~set-native-fn ~filtersub,$(if $(filter-out $p,$1),$p)),$(filter $1,$2))
~*trace-ids* := 
~trace-id = $(or $(call ~filtersub,$1:%,%,$(~*trace-ids*)),$(if $2,$(call ^set,~*trace-ids*,$(~*trace-ids*) $1:$(words $(~*trace-ids*)),$(words $(~*trace-ids*)))))
define ~trace
$(filter %,$(foreach _-spec,$(filter-out %:v %:-,$1),$(foreach _-name,$(foreach v,$(call ~trace-match,$(filter-out :%,$(subst :, :,$(_-spec))),$(filter-out $(~*do-not-trace*) [% ~trace ~untrace ~trace-ext ~untrace-ext ^Y  $(call ~filtersub,%:-,%,$1),$(.VARIABLES))),$(if $(filter filerec%,$(origin $v)$(flavor $v)),$v)),$(foreach id,$(call ~trace-id,$(_-name),1),$(and $(and $(if $(filter u%,$(origin [S-$(id)])),$(call ^fset,[S-$(id)],$(value $(_-name)),))1,$(if $(filter %:v,$1),$(call ~trace-info,[,$(subst $  ,,$(wordlist 2,999,$(subst :,: ,$(_-spec)))),] ,$(_-name)))1,$(call ^fset,$(_-name),$(call ~trace-body,$(or $(subst $  ,,$(wordlist 2,999,$(subst :,: ,$(_-spec)))),t),$(subst #,$`",$(_-name)),$(id),$(value [S-$(id)])),))1,$(_-name))))))
endef
~trace-rev = $(if $1,$(call ~trace-rev,$(wordlist 2,99999,$1)) $(word 1,$1))
~trace-dump = $(foreach line,$(sort $(foreach name,$1,$(foreach k,$(value [K-$(call ~trace-id,$(name))]),$(if $(findstring 1,$k),$(and $(call ^set,[K-$(call ~trace-id,$(name))],///////,)1,$(call ^d,$(subst :, ,$(call ~trace-digits,$k)) $(name))))))),$(call ^d,$(call ~trace-info,$(call ^u,$(line)))))
~untrace = $(and $(call ~trace-dump,$(foreach name,$(filter $1,$(filter-out :%,$(subst :, :,$(~*trace-ids*)))),$(foreach id,$(call ~trace-id,$(name)),$(and $(call ^fset,$(name),$(value [S-$(id)]),)1,$(name)))))1,$2)
~do-not-trace = $(call ^set,~*do-not-trace*,$(~*do-not-trace*) $1)
~start-trace = $(call ~trace,$(value $(if $(filter scam,$1),_)SCAM_TRACE))
SHELL := /bin/bash
~*atexits* := 
~at-exit = $(call ^set,~*atexits*,$(call ^d,$1) $(~*atexits*))
~run-at-exits = $(and $(foreach fn,$(~*atexits*),$(call ^d,$(call ^Y,,,,,,,,,,$(call ^u,$(fn)))))1,)
~check-exit = $(if $(subst 0,,$(subst 9,,$(subst 8,,$(subst 7,,$(subst 6,,$(subst 5,,$(subst 4,,$(subst 3,,$(subst 2,,$(subst 1,,$(patsubst -%,%,$(subst $ 	,x,$(subst $  ,x,$1))))))))))))),$(error scam: main returned '$1'),$(or $1,0))
define ^start
$(and $(call ~start-trace,$1)1,$(call ~do-not-trace,^R ^load)1,$(call ^R,$1)1,$(call ~start-trace,$1)1,$(eval $(call ^Y,$(call ~check-exit,$(call ^Y,$2,,,,,,,,,$(value $(if $(filter .scm,$(suffix $1)),,~)main))),,,,,,,,,.DEFAULT_GOAL :=
.PHONY: [exit]
[exit]: $`(.DEFAULT_GOAL);@exit $`1$``(call ~run-at-exits))))
endef
$(if $(call ~do-not-trace,^start ~start-trace),)
$(if $(call ~at-exit,$`(call ~trace-dump,$`(filter-out :%,$`(subst :, :,$`(~*trace-ids*))))),)
$(if $(call ^start,$(SCAM_MOD),$(value SCAM_ARGS)),)

endef

define [mod-core]
# Requires: 
# Exports: intersperse"foldr}3 foldl}3 index-of"assoc(3;~%-initial[:IL2'subst',|\0,1',|\0,11',:IL3\0^d\0,1@,01,00[@'2'0 assoc-vec(3;~assoc-initial[:IL3'^d',@\01\00[@'2'0 assoc-initial"sort-by"memoize#1+#split"uniq#see"fexpect(3;~expect-x[:IL3'~format',@\01\00[:IL3'~format',@\02\00[:IL9'4586 assert&1;!1.;!1:IL3;~%-x[@'1'0[:IL9'4537 trace-expect(5[:IL8',:IL3\0~expect-x\0,1:IL3,0^n,0,11|,101,0,11@,101,100\0,1:IL3,0^n,0,11|,102,0,11@,101,100\0,1:IL9,04454[:IL3'~untrace',:IL3\0~trace\0,1|,0!p',:IL6\0,1:IL3,0^d,0,11@,101,100\0,1|,0,10\0,1:IL3,0^d,0,11@,102,100 expect(3;~%-x[@'1'0[@'2'0[:IL9'4405 expect-x}3 printf}1'or'more sprintf}1'or'more vsprintf"format#format-add#dict-collate#dict-values#dict-keys#dict-compact}1'or'2 dict-set}3 dict-remove"dict-get}2'or'3 dict-find"dict-value&1;!1.;!1:IL3;^n[|'2[:IL2'subst',|\0,1=',|\0,0',@\01\00 dict-key#append}0'or'more word-index?#numeric?#while}3 reverse#indices&1;!1.;!1:IL3;~%-a[:IL2'words',@\01\00 vec-subtract(3;~vec-filter[|'filter-out[@'2'0[@'1'0 vec-intersect(3;~vec-filter[|'filter[@'2'0[@'1'0 vec-or&1;!1.;!1:IL3;^n[|'1[:IL2'filter-out',|\0,1.',@\01\00 select-words"select-vec"butlast#strip-vec&1;!1.;!1:IL2;filter[|'!p[@'1'0 last&1;!1.;!1:IL3;^u[:IL2'%word',@\01\00 conj"cons"concat-vec}1'or'2 xor"identity&1;!1.;!1@;1;0 eq?}2
~eq? = $(if $(findstring 1$1,$(findstring 1$2,1$1)),1)
~xor = $(if $1,$(if $2,,$1),$2)
~concat-vec = $(call ^u,$(subst $  ,$(call ^d,$2),$1))
~cons = $(call ^d,$1)$(if $2, )$2
~conj = $1$(if $1, )$(call ^d,$2)
~butlast = $(wordlist 2,$(words $1),X $1)
~select-vec = $(filter-out !,$(foreach dx,$2,$(if $(call ^Y,$(call ^u,$(dx)),,,,,,,,,$1),$(dx),!)))
~select-words = $(foreach a,$(foreach x,$2,$(if $(call ^Y,$x,,,,,,,,,$1),$x)),$a)
~vec-filter = $(if $(findstring %,$2),$(subst !P,%,$(call $1,$(subst %,!P,$2),$(subst %,!P,$3))),$(call $1,$2,$3))
~indices-b = $(if $(filter $1,$2),$2,$2 $(call ~indices-b,$1,$(words $3),. $3))
~indices-a = $(if $(filter-out 0,$1),$(call ~indices-b,$1,1,. .))
~rev-by-10s = $(if $1,$(if $2,$(foreach p,10 9 8 7 6 5 4 3 2 1,$(call ~rev-by-10s,$(wordlist $(word $p,0 1 2 3 4 5 6 7 8 9)$(patsubst %0,%1,$2),$p$2,$1),$(patsubst 0%,%,$2))),$(foreach p,10 9 8 7 6 5 4 3 2 1,$(word $p,$1))))
~rev-zeroes = $(if $(word 1$21,$1),$(call ~rev-zeroes,$1,0$2),$2)
~reverse = $(wordlist 1,99999999,$(call ~rev-by-10s,$1,$(call ~rev-zeroes,$1,)))
~while-0 = $(if $(filter iiiiiiiiiiiiiiiiiiii,$4),1 $(call ^d,$3),$(if $(call ^Y,$3,,,,,,,,,$1),$(call ~while-0,$1,$2,$(call ^Y,$3,,,,,,,,,$2),i$4),0 $(call ^d,$3)))
~while-N = $(if $(filter 0,$(word 1,$3)),$3,$(if $(filter iii,$5),$(if $(filter 1,$4),$(call ~while-N,$1,$2,$3,$4 0,ii),$3),$(call ~while-N,$1,$2,$(if $4,$(call ~while-N,$1,$2,$3,$(wordlist 2,99999999,$4),),$(call ~while-0,$1,$2,$(call ^n,2,$3),)),$4,i$5)))
~while = $(if $(call ^Y,$3,,,,,,,,,$1),$(call ^Y,$(call ^Y,$3,,,,,,,,,$2),$1,$2,,,,,,,$`(call ^n,2,$`(call ~while-N,$`2,$`3,$`(call ~while-0,$`2,$`3,$`1,),1,ii))),$3)
~numeric? = $(if $(filter 0% 1% 2% 3% 4% 5% 6% 7% 8% 9%,$(subst -,,$1)),$(if $(patsubst .%,%,$(patsubst %e,%,$(subst 0,,$(patsubst -%,%,$(subst $  ,_,$(subst E0,e,$(subst E-,E,$(subst e,E,$(subst +,-,$(subst 9,0,$(subst 8,0,$(subst 7,0,$(subst 6,0,$(subst 5,0,$(subst 4,0,$(subst 3,0,$(subst 2,0,$(subst 1,0,$1)))))))))))))))))),,$1))
~word-index? = $(if $(subst 9,,$(subst 8,,$(subst 7,,$(subst 6,,$(subst 5,,$(subst 4,,$(subst 3,,$(subst 2,,$(subst 1,,$(subst 0,,$1)))))))))),,$(subst 0,,$1))
~append = $(filter %,$1 $2 $3 $4 $5 $6 $7 $8 $(if $9,$(call ^u,$9)))
~dict-key = $(call ^u,$(subst !8,%,$(word 1,$(subst !=, ,$1))))
~dict-find = $(word 1,$(filter $(subst %,!8,$(call ^d,$1))!=%,$2))
~dict-get = $(call ^u,$(or $(word 2,$(subst !=, ,$(filter $(subst %,!8,$(call ^d,$1))!=%,$2))),$(subst !,!1,$3)))
~dict-remove = $(filter-out $(subst %,!8,$(call ^d,$1))!=%,$2)
~dict-set = $(foreach p,$(subst %,!8,$(call ^d,$1))!=,$p$(call ^d,$2) $(filter-out $p%,$3))
~dict-compact = $(if $(if $1,,1),$2,$(call ~append,$(word 1,$1),$(call ~dict-compact,$(filter-out $(word 1,$(subst !=,!=% ,$(word 1,$1))),$(wordlist 2,99999999,$1)))))
~dict-keys = $(subst !8,%,$(filter-out !=%,$(subst !=, !=,$1)))
~dict-values = $(filter-out %!=,$(subst !=,!= ,$1))
~dict-collate = $(foreach p,$(word 1,$(subst !=,!= ,$(word 1,$1))),$(call ~append,$p$(call ^d,$(call ~filtersub,$p%,%,$1)),$(call ~dict-collate,$(filter-out $p%,$1))))
define ~symbol?
$(and $(findstring $1,$(call ^u,$(word 1,$1))),$(if $(or $(findstring 
,$1),$(findstring $[,$1),$(findstring $],$1),$(findstring [,$1),$(findstring ],$1),$(findstring $(if ,,,),$1),$(findstring ;,$1),$(findstring !=,$1)),,1),$1)
endef
~format-dict = $(if $(findstring !=,$1),$(if $(call ~eq?,$1,$(foreach w,$1,$(call ^k,$(call ^n,1,$(subst !=, ,$w)))!=$(call ^d,$(call ^n,2,$(subst !=, ,$w))))),{$(call ~concat-vec,$(foreach e,$1,$(call ^d,$(or $(call ~symbol?,$(call ~dict-key,$e)),$(call ~format,$(call ~dict-key,$e))): $(call ~format,$(call ^n,2,$(subst !=, ,$e))))),$(if ,,, ))}))
~data-foreach = $(if $2,$(call ~data-foreach,$1,$(wordlist 2,99999999,$2),$(wordlist 2,99999999,$3),$4$(if $4, )$(call ^Y,$(if $(filter L,$(word 1,$2)),$3,$(if $(filter S,$(word 1,$2)),$(call ^n,1,$3),$(if $(filter W,$(word 1,$2)),$(word 1,$3),$(error bad encoding in ctor pattern)))),$(word 1,$2),,,,,,,,$1)),$4)
~format-record = $(if $(filter !:%,$(word 1,$1)),$(call ^Y,$(call ~dict-get,$(word 1,$1),$(^tags)),$(wordlist 2,99999999,$1),$(word 1,$1),$1,,,,,,$`(and $`1,$`(call ~eq?,$`(filter %,$`4),$`(filter %,$`(call ~data-foreach,$``(if $``(call ~eq?,S,$``2),$``(call ^d,$``1),$``1),$`(wordlist 2,99999999,$`1),$`2,$`3))),($`(call ^n,1,$`1)$`(if $`(wordlist 2,99999999,$`1), )$`(call ~data-foreach,$``(if $``(and $``(call ~eq?,L,$``2),$``(if $``1,,1)),[],$``(call ~format,$``1)),$`(wordlist 2,99999999,$`1),$`2,)))))
~*format-funcs* := 
~format-add = $(call ^set,~*format-funcs*,$(call ~cons,$1,$(~*format-funcs*)))
~format-custom = $(if $2,$(or $(call ^Y,$1,,,,,,,,,$(call ^n,1,$2)),$(call ~format-custom,$1,$(wordlist 2,99999999,$2))))
define ~format
$(or $(call ~format-custom,$1,$(~*format-funcs*)),$(if $(findstring !,$1),$(or $(call ~format-dict,$1),$(call ~format-record,$1))),$(if $(or $(findstring !,$1),$(and $(findstring $  ,$1),$(call ~numeric?,$(subst $  ,,$1)))),$(if $(call ~eq?,$1,$(foreach w,$1,$(call ^d,$(call ^u,$w)))),[$(foreach w,$1,$(call ~format,$(call ^u,$w)))])),$(call ~numeric?,$1),"$(subst ,\x0d,$(subst $ 	,\t,$(subst 
,\n,$(subst ",\",$(subst \,\\,$1)))))")
endef
~vsprintf = $(call ~concat-vec,$(foreach w,$(join !. $2,$(subst $  !% !%,%,$(subst %, !%,%s$(call ^d,$1)))),$(if $(findstring !%s,$w),$(subst !%s,,$w),$(if $(findstring !%q,$w),$(call ~cons,$(call ~format,$(call ^n,1,$(subst !%q,!. ,$w))),$(word 2,$(subst !%q,!. ,$w))),$(if $(findstring !%,$w),$(subst !%,[unknown % escape]%,$w))))))
~sprintf = $(call ~vsprintf,$1,$(foreach N,2,$(^v)))
~printf = $(info $(call ~vsprintf,$1,$(foreach N,2,$(^v))))
define ~expect-x
$(if $(call ~eq?,$1,$2),$(if $(findstring O,$(SCAM_DEBUG)),$(info $3: OK: $1)),$(and $(info $3: error: assertion failed
A: $(call ~format,$1)
B: $(call ~format,$2)

Raw:
A: $1
B: $2
)1,$(if $(if $(findstring K,$(SCAM_DEBUG)),,1),$(error ))))
endef
~assert-x = $(or $1,$(error $(info $2: error: assertion failed)))
define ~see
$(if $(findstring $1,$2),1,$(and $(info Expected: $(subst 
,
          ,$1))1,$(info $   Within: $(subst 
,
          ,$2))))
endef
~uniq-x = $(if $1,$(word 1,$1) $(call ~uniq-x,$(filter-out $(word 1,$1),$(wordlist 2,99999999,$1))))
~uniq = $(subst ~1,~,$(subst ~p,%,$(filter %,$(call ~uniq-x,$(subst %,~p,$(subst ~,~1,$1))))))
~split = $(foreach w,$(subst $(or $(subst $ 	,{t},$(subst $  ,{s},$(subst {L,{L},$(subst },{R},$(subst {,{L,$1))))),{}),{} {},$(or $(subst $ 	,{t},$(subst $  ,{s},$(subst {L,{L},$(subst },{R},$(subst {,{L,$2))))),{})),$(call ^d,$(subst {L,{,$(subst {R},},$(subst {L},{L,$(subst {s}, ,$(subst {t},	,$(subst {},,$w))))))))
~1+ = $(if $(filter %1 %2 %3 %4,$1),$(subst 1~,2,$(subst 2~,3,$(subst 3~,4,$(subst 4~,5,$1~)))),$(if $(filter %5 %6 %7,$1),$(subst 5~,6,$(subst 6~,7,$(subst 7~,8,$1~))),$(if $(findstring 9~,$1~),$(call ~1+,$(or $(subst 9~,,$1~),0))0,$(patsubst %0,%1,$(patsubst %8,%9,$1)))))
~mcache = $(and $(if $6,$(info Warning: memoized function passed more than three arguments))1,$(if $(if $(if $(filter-out u%,$(flavor $1)),1),,1),$(call ^set,$1,$(call ^Y,$3,$4,$5,,,,,,,$2),))1,$(value $1))
~memoenc = $(if $(or $1,$2,$3),~~$(subst ~,~0,$1)$(call ~memoenc,$2,$3))
~memoize = $(if $(if $(if $(filter-out u%,$(flavor $1)),1),,1),$(info Warning: [memoize-1] function '$1' not defined.),$(call ^Y,$(value $1),*memo$(call ~memoenc,$1),$1,,,,,,,$`(call ^fset,$`3,$``(call ~mcache,$`(call ^E,$`2)$``(call ~memoenc,$``1,$``2,$``3),$`(call ^E,$`1),$``1,$``2,$``3,$``(or $``4,$``5,$``6,$``7,$``8)),)))
~sort-by = $(filter-out %!!,$(subst !!,!! ,$(sort $(foreach w,$2,$(call ^d,$(call ^Y,$(call ^u,$w),,,,,,,,,$1))!!$w))))
~assoc-initial = $(call ^u,$(firstword $(if $(findstring %,$1),$(subst !8,$1,$(filter !8 !8!0%,$(subst $1,!8,$2))),$(filter $1 $1!0%,$2))))
~index-of = $(words $(subst !_, ,$(filter %!|,$(subst !_$(call ^d,$2)!_,!_!| ,!_$(subst $  ,!_,$1)!_))))
~foldl = $(if $(word 1,$3),$(call ~foldl,$1,$(call ^Y,$2,$(call ^n,1,$3),,,,,,,,$1),$(wordlist 2,99999999,$3)),$2)
~foldr = $(if $(word 1,$3),$(call ^Y,$(call ^n,1,$3),$(call ~foldr,$1,$2,$(wordlist 2,99999999,$3)),,,,,,,,$1),$2)
~intersperse = $(subst $  , $(call ^d,$1) ,$2)

endef

define [mod-repl]
# Requires: core io parse compile gen math
# Exports: repl-rep#repl}0
$(call ^R,core)
$(call ^R,io)
$(call ^R,parse)
$(call ^R,compile)
$(call ^R,gen)
$(call ^R,math)
~LIBS := compile core getopts io math string utf8
*1 := 
*2 := 
define ~help
$(and $(info Commands:
  :q or ^D : exit REPL loop
  :        : reset input state
  :e       : show environment
  :E       : show environment (including imported entries)
  ?        : this message

Global variables in REPL:
  *1 = most recent value printed
  *2 = second most recent value
)1,$(call ~printf,LIBS = %s
,$(~LIBS)))
endef
~describe-binding = $(if $(or $3,$(if $(filter i%,$(word 3,$2)),,1)),$(if $(filter !:EDefn5,$(word 1,$2)),built-in function,$(if $(filter !:EDefn1,$(word 1,$2)),$(if $(call ~eq?,$(call ^n,2,$2),:),compound macro,function)$(if $(wordlist 5,99999999,$2),$(call ~sprintf, (%s arguments),$(call ^n,4,$2))),$(if $(filter !:EDefn0,$(word 1,$2)),variable,$(if $(filter !:EDefn2,$(word 1,$2)),symbol macro: $(call ~format,$(wordlist 4,99999999,$2)),$(if $(filter !:EDefn3,$(word 1,$2)),executable macro,$(if $(filter !:EDefn4,$(word 1,$2)),constructor,)))))))
~describe-env = $(foreach w,$(call ~reverse,$(call ~dict-compact,$1)),$(call ^Y,$(call ~dict-key,$w),$(call ~describe-binding,$(call ~dict-key,$w),$(call ^n,2,$(subst !=, ,$w)),$2),,,,,,,,$`(if $`2,$`(call ~printf,  %s : %s,$`1,$`2))))
~eval-and-print = $(call ^Y,$(call ~compile-text,$1,[stdin],$2),$2,$1,,,,,,,$`(if $`(and $(call ^E,$3),$`(filter $`[ [ {,$`(if $`(filter !:P8,$`(word 1,$`(call ^n,1,$`(call ~dict-get,errors,$`1)))),$`(word 1,$`(call ^n,3,$`(call ^n,1,$`(call ~dict-get,errors,$`1))))))),$`(call ^d,$`3) $`(call ^d,$`2),$`(if $`(call ~dict-get,errors,$`1),$`(and $`(foreach err,$`(call ~dict-get,errors,$`1),$`(call ^d,$`(info $`(call ~describe-error,$`(call ^u,$`(err)),$`3,[stdin]))))1,!. $`(call ^d,$`2) 1),$`(and $`(call ^Y,$`(call ^Y,,,,,,,,,,$`(call ~dict-get,code,$`1)),,,,,,,,,$``(if $``1,$``(and $``(call ^set,*2,$``(*1))1,$``(call ^set,*1,$``1)1,$``(info $``(call ~format,$``1)))))1,!. $`(call ^d,$`(call ~dict-get,env,$`1))))))
~read-eval-print = $(call ^Y,$(call ~getline,$(if $(call ^n,1,$1),+ ,> )),$(call ^n,1,$1),$(call ^n,2,$1),$1,,,,,,$`(if $`(call ~eq?,$`(strip $`1),?),$`(and $`(call ~help)1,$`4),$`(if $`(call ~eq?,$`(strip $`1),:),!. $`(call ^d,$`3),$`(if $`(call ~eq?,$`(strip $`1),:q),,$`(if $`(call ~eq?,$`1,),,$`(if $`(call ~eq?,$`(strip $`1),:e),$`(and $`(call ~describe-env,$`3,)1,$`4),$`(if $`(call ~eq?,$`(strip $`1),:E),$`(and $`(call ~describe-env,$`3,1)1,$`4),$`(call ~eval-and-print,$`2$`1,$`3,1))))))))
~repl = $(and $(call ~do-not-trace,~repl ~eval-and-print ~while ~while-0 ~while-N)1,$(call ~while,$`1,$(value ~read-eval-print),$(call ~eval-and-print,$(foreach lib,$(~LIBS),(require "$(lib)"))(declare *1)(declare *2),))1,$(info ))
~repl-rep = $(word 3,$(call ~eval-and-print,$1,$(call ^n,2,$(call ~eval-and-print,$(foreach lib,$(~LIBS),(require "$(lib)"))(declare *1)(declare *2),))))

endef

define [mod-getopts]
# Requires: core
# Exports: getopts"MissingArg{4;S]GetoptsError0 BadOption{4;S]GetoptsError1
$(call ^R,core)
$(call ^at,!1:GetoptsError0!=MissingArg!0S !1:GetoptsError1!=BadOption!0S)
~opt-pair = $(call ^k,$(patsubst -%,%,$(patsubst -%,%,$1)))!=$(call ^d,$2)
~getopts-loop = $(if $(if $(word 1,$3),,1),$4,$(if $(filter --,$(word 1,$3)),$(call ~append,$4,$(foreach w,$(wordlist 2,99999999,$3),*!=$w)),$(if $(filter $1,$(word 1,$3)),$(call ~getopts-loop,$1,$2,$(wordlist $(or 2,2),99999999,$3),$(call ~append,$4,$(call ~opt-pair,$(word 1,$3),1))),$(if $(filter $2,$(word 1,$3)),$(if $(word 2,$3),$(call ~getopts-loop,$1,$2,$(wordlist $(or 3,2),99999999,$3),$(call ~append,$4,$(call ~opt-pair,$(word 1,$3),$(call ^n,2,$3)))),$(call ~append,$4,!1!=$(call ^d,!:GetoptsError0 $(call ^d,$(word 1,$3))))),$(if $(filter -%,$(word 1,$3)),$(call ~getopts-loop,$1,$2,$(wordlist $(or 2,2),99999999,$3),$(call ~append,$4,!1!=$(call ^d,!:GetoptsError1 $(call ^d,$(word 1,$3))))),$(call ~getopts-loop,$1,$2,$(wordlist $(or 2,2),99999999,$3),$(call ~append,$4,*!=$(word 1,$3))))))))
~getopts = $(call ~dict-collate,$(call ~getopts-loop,$(filter-out %=,$2),$(call ~filtersub,%=,%,$2),$1))

endef

define [mod-compile]
# Requires: core parse gen gen0 gen1 io memo macros utf8
# Exports: compile-text}2'or'3 run-program"build-program"*is-quiet*{0;~%;i
$(call ^R,core)
$(call ^R,parse)
$(call ^R,gen)
$(call ^R,gen0)
$(call ^R,gen1)
$(call ^R,io)
$(call ^R,memo)
$(call ^R,macros)
$(if $(and ,$(call ^R,utf8)),)
~*is-quiet* := 
~*compiling* := 
define ~build-message
$(or $(~*is-quiet*),$(call ~write,2,... $1 $2
))
endef
define ~bail-if
$(if $1,$(and $(call ~fprintf,2,scam: %s
,$1)1,$(call ~memo-drop)1,1),$(and 1,))
endef
~descendants = $(if $2,$(call ~descendants,$1,$(call ~append,$(wordlist 2,99999999,$2),$(call ~vec-filter,filter-out,$2 $3,$(call ^Y,$(call ^n,1,$2),,,,,,,,,$1))),$(call ~append,$3,$(word 1,$2))),$3)
define ~env-cmp
$(subst &2;!1.;!1:IL,$[,$(subst {1;:;i;,&,$(subst }2 ,",$(subst }1 ,#,$(subst {1;~%;i;,},$(subst !=!1:EDefn,{,$(subst :IL4,@,$(subst :IL0,|,$(subst ;i[:,],$(subst ;\,[,$(subst !10,',$(subst \1,$(if ,,,),$(subst !11,\,$(subst !0,;,$(subst $[,!N,$(subst &,!M,$(subst ",!L,$(subst #,!K,$(subst },!J,$(subst {,!I,$(subst @,!H,$(subst |,!G,$(subst ],!F,$(subst [,!E,$(subst ',!D,$(subst $(if ,,,),!C,$(subst \,!B,$(subst ;,!A,$1))))))))))))))))))))))))))))
endef
define ~env-exp
$(subst !A,;,$(subst !B,\,$(subst !C,$(if ,,,),$(subst !D,',$(subst !E,[,$(subst !F,],$(subst !G,|,$(subst !H,@,$(subst !I,{,$(subst !J,},$(subst !K,#,$(subst !L,",$(subst !M,&,$(subst !N,$[,$(subst ;,!0,$(subst \,!11,$(subst $(if ,,,),\1,$(subst ',!10,$(subst [,;\,$(subst ],;i[:,$(subst |,:IL0,$(subst @,:IL4,$(subst {,!=!1:EDefn,$(subst },{1;~%;i;,$(subst #,}1 ,$(subst ",}2 ,$(subst &,{1;:;i;,$(subst $[,&2;!1.;!1:IL,$1))))))))))))))))))))))))))))
endef
define ~env-compress
$(call ~env-cmp,$(foreach w,$(patsubst %!0,%,$(subst 
,!n,$1)),$(word 1,$(subst !=,!= ,$w))$(subst $(word 1,$(subst !=, ,$w)),%,$(subst %,!p,$(word 2,$(subst !=,!= ,$w))))))
endef
define ~env-parse
$(subst !n,
,$(subst !n,
,$(foreach w,$(call ~env-exp,$(foreach prefix,$(call ~append,Exports,$(if $2,Private)),$(call ^u,$(call ~filtersub,#!0$(prefix):!0%,%,$1)))),$(word 1,$(subst !=,!= ,$w))$(subst !p,%,$(subst %,$(word 1,$(subst !=, ,$w)),$(word 2,$(subst !=,!= ,$w)))))))
endef
~export-defn = $(word 3,$2):$(call ^k,$1)!=$(call ^d,$(call ~append,$(wordlist 1,2,$2),i,$(wordlist 4,99999999,$2)))
define ~modid-read-lines
$(if $(or $(filter %.scm,$1),$(~*is-boot*)),$(and $(call ~memo-hash-file,$(~*obj-dir*)$1.o)1,$(call ~read-lines,$(~*obj-dir*)$1.o,$(and $2,1),$2)),$(wordlist 1,$(or $2,99999999),$(call ~split,
,$(value [mod-$1]))))
endef
define ~modid-deps
$(call ^Y,$(call ~modid-read-lines,$1,4),,,,,,,,,$`(and $`(call ~assert-x,$`1,compile.scm:289)1,$`(call ^u,$`(call ~filtersub,#!0Requires:!0%,%,$`1))))
endef
~modid-import = $(call ~env-parse,$(call ~modid-read-lines,$1,4),$2)
~module-id = $(call ^Y,$(call ~escape-path,$1),,,,,,,,,$`(if $`(~*is-boot*),$`(basename $`1),$`1))
~locate-module = $(or $(and $(filter %.scm,$(call ^d,$2)),$(call ^n,1,$(filter-out !.,$(foreach dir,$(call ~cons,$1,$(addsuffix /,$(call ~split,:,$(value SCAM_LIBPATH)))),$(call ^d,$(wildcard $(call ~resolve-path,$(call ^u,$(dir)),$2))))))),$(and $(if $(~*is-boot*),,1),$(if $(if $(filter-out u%,$(flavor [mod-$2])),1),$2)))
$(if $(call ~memoize,~locate-module),)
~m-locate-module = $(call ~memo-io,~locate-module,$1,$2)
define ~skip-comments
$(if $(filter #% !.,$(word 1,$1)),$(call ~append,$(filter $2,$(word 1,$1)),$(call ~skip-comments,$(wordlist 2,99999999,$1),$2)),$1)
endef
define ~construct-bundle

$ define [mod-$1]
$(call ~concat-vec,$(call ~skip-comments,$(call ~modid-read-lines,$1),$(if $2,#!0Req% #!0Exp%)),
)
$ endef

endef
~get-module = $(call ^Y,$(call ~m-locate-module,$(dir $2),$1),$3,,,,,,,,$`(or $`(if $`(if $`1,,1),!:Mod1 $`(call ^d,$`(call ~sprintf,cannot find %q,$(call ^E,$1)))),$`(if $`(filter %.scm,$`(call ^d,$`1)),$`(if $`(call ~memo-call,$`(if $`2,~compile-module,~compile-and-test-module),$`1),!:Mod1 $`(call ^d,$`(call ~sprintf,compilation of %q failed,$`1)),)),$`(call ^Y,$`(call ~memo-blob-call,~modid-import,$`(call ~module-id,$`1),$`2),$`(call ~module-id,$`1),$`1,,,,,,,$``(or $``(if $``(word 1,$``(foreach pair,$``1,$``(if $``(filter !:EDefn3,$``(word 1,$``(call ^n,2,$``(subst !=, ,$``(pair))))),1))),$``(if $``(~*is-boot*),!:Mod1 module!0has!0executable!0macros!0(boot=true),$``(call ^R,$``2))),!:Mod0 $``(call ^d,$``2) $``(call ^d,$``1)))))
~runtime-module-name = $(if $(~*is-boot*),$(filter-out $(subst -q.scm,.scm,$(call ^d,$1)),runtime.scm),runtime)
~compile-prelude = $(foreach m,$(call ~runtime-module-name,$1),$(call ^Y,$(call ~get-module,$m,.,),,,,,,,,,$`(if $`(filter !:Mod0,$`(word 1,$`1)),$`(call ^n,3,$`1),$`(if $`(filter !:Mod1,$`(word 1,$`1)),$`(error $`(call ^n,2,$`1))))))
~parse-and-gen = $(call ^set,~*compile-subject*,$(call ^set,~*compile-subject*,$(call ~penc,$1),$(~*compile-subject*)),$(call ^set,~*compile-file*,$(call ^set,~*compile-file*,$3,$(~*compile-file*)),$(call ^Y,$(call ~gen0,$(or $5,$(call ~parse-subject,$(~*compile-subject*))),$2),$4,,,,,,,,$`(call ~gen1,$`(wordlist 2,99999999,$`1),$`2) env!=$`(call ^d,$`(call ^n,1,$`1)))))
define ~trim-hashbang
$(if $(filter #%,$(word 1,$1)),
$(call ~concat-vec,$(wordlist 2,99999999,$(call ~split,
,$1)),
),$1)
endef
~parse-file = $(call ~parse-text,$(call ~trim-hashbang,$(call ~memo-read-file,$1)))
define ~compile-module
$(or $(if $(call ~vec-filter,filter,$(call ^d,$1),$(~*compiling*)),$(call ~bail-if,dependency loop: $(call ~concat-vec,$(call ~conj,$(~*compiling*),$1), -> ))),$(call ^set,~*compiling*,$(call ^set,~*compiling*,$(call ~conj,$(~*compiling*),$1),$(~*compiling*)),$(and $(call ~build-message,compile,$1)1,$(call ^Y,$(call ~parse-and-gen,$(call ~trim-hashbang,$(call ~memo-read-file,$1)),$(call ~compile-prelude,$1),$1,$(~*obj-dir*)$(call ~module-id,$1).o,$(call ~memo-blob-call,~parse-file,$1)),$1,$(~*obj-dir*)$(call ~module-id,$1).o,,,,,,,$`(if $`(call ~dict-get,errors,$`1),$`(and $`(foreach e,$`(call ~dict-get,errors,$`1),$`(call ^d,$`(info $`(call ~describe-error,$`(call ^u,$`e),$`(call ~trim-hashbang,$`(call ~memo-read-file,$(call ^E,$1))),$`2))))1,$`(call ~memo-drop)1,1),$`(and $`(call ~bail-if,$`(call ~memo-write-file,$`3,# Requires: $`(call ~dict-get,require,$`1)
$`(call ^Y,$`(filter p:% x:%,$`(foreach b,$`(call ~dict-compact,$`(call ~dict-get,env,$`1)),$`(call ~export-defn,$`(call ~dict-key,$`b),$`(call ^n,2,$`(subst !=, ,$`b))))),,,,,,,,,# Exports: $``(call ~env-compress,$``(call ~filtersub,x:%,%,$``1))
# Private: $``(call ~env-compress,$``(call ~filtersub,p:%,%,$``1))
)$`(call ~dict-get,code,$`1)))1,))))))
endef
~modid-deps-all = $(call ~descendants,$(value ~modid-deps),$(call ~uniq,$(call ~append,$1,$(foreach m,$(call ~runtime-module-name,),$(call ~module-id,$m)))))
define ~link
$(and $(call ~build-message,link,$1)1,$(call ~bail-if,$(or $(call ~memo-write-file,$1,$(call ^Y,$(call ~modid-deps-all,$2),,,,,,,,,#!/bin/bash
:; for v in "$``{@//!/!1}" ; do v=$``{v// /!0} ; v=$``{v//	/!+}; a[++n]=$``{v:-!.} ; done ; LC_ALL=C SCAM_ARGS=$``{a[*]} exec make -Rr --no-print-directory -f"$``0" 9>&1
SCAM_MOD := $(call ^E,$2)
^uid := $`(call ~hash-output,cat $`(foreach id,$`1,$`(if $`(or $`(filter %.scm,$`(id)),$`(~*is-boot*)),$`(call ~quote-sh-arg,$`(~*obj-dir*)$`(id).o))))
$`(subst |1,|,$`(subst |0, ,$`(subst $`  ,,$`(foreach id,$`1,$`(subst $`  ,|0,$`(subst |,|1,$`(call ~construct-bundle,$`(call ^u,$`(id)),$`(filter compile,$`1))))))))$``(eval $``(value [mod-runtime]))
)),$(call ~memo-chmod-file,$1,+x))))
endef
~run = $(and $(if $3,$(call ~build-message,run,$1))1,$(call ~modid-deps-all,$(call ~module-id,$1))1,$(if $(filter-out 0,$(lastword $(call ~ioshell,SCAM_ARGS=$(call ~quote-sh-arg,$2) $(MAKE) -f $(call ~quote-sh-arg,$(if $(~*is-boot*),$(~*obj-dir*)runtime.o,$(firstword $(MAKEFILE_LIST)))) SCAM_MOD=$(call ~quote-sh-arg,$(call ~module-id,$1)) SCAM_DIR=$(call ~quote-sh-arg,$(~*obj-dir*)) 1>&9 ; echo " $`?"))),$(and 1,$(call ~memo-drop)1,1),$(and 1,)))
~compile-and-test-module = $(or $(call ~memo-call,~compile-module,$1),$(and $(call ~file-exists?,$(subst .scm,-q.scm,$1)),$(or $(call ~memo-call,~compile-module,$(subst .scm,-q.scm,$1)),$(if $(call ~memo-call,~run,$(subst .scm,-q.scm,$1),,1),$(call ~bail-if,$(subst .scm,-q.scm,$1) failed)))))
define ~build-program
$(call ~memo-minus,$(if $(~*memo-on*),,$(and $(call ~memo-start-session,$(~*obj-dir*)$(^uid).db)1,1)),$(if $(if $(call ~memo-hash-file,$1),,1),$(and $(call ~fprintf,2,scam: file '%s' does not exist
,$1)1,1),$(or $(call ~memo-call,$(if ,~compile-module,~compile-and-test-module),$1),$(call ~memo-call,~link,$2,$(call ~module-id,$1)))))
endef
~run-program = $(call ~memo-minus,$(if $(~*memo-on*),,$(and $(call ~memo-start-session,$(~*obj-dir*)$(^uid).db)1,1)),$(or $(call ~memo-call,$(if ,~compile-module,~compile-and-test-module),$1),$(call ~run,$1,$2,)))
~compile-text = $(call ~memo-minus,$(if $(~*memo-on*),,$(and $(call ~memo-start-session,$(~*obj-dir*)$(^uid).db)1,1)),$(call ~parse-and-gen,$1,$(or $3,$(call ~compile-prelude,)),$2,))

endef

define [mod-gen]
# Requires: core parse
# Exports: resolve"builtin-names{0;~%;i check-argc}3 err-expected}5'or'6'or'7 gen-error}2'or'more gensym"current-depth#gensym-name}3 gen-native-name"il-subst}3 il-promote#il-demote#il-concat#NoOp{2;!1.;i;!1:IL6[|',|[|'\0[|',. LambdaMarkerKey{2;!1.;i;!1|;: NoGlobalName{2;!1.;i;!1|;: EDefn.scope&1;!1.;!1:IL2;word[|'3[@'1'0 EVar{4;S'W]EDefn0 EFunc{4;S'W'S'L]EDefn1 EIL{4;S'W'L]EDefn2 EXMacro{4;S'W]EDefn3 ERecord{4;S'W'S]EDefn4 EBuiltin{4;S'W'S]EDefn5 EArg{4;W]EDefn6 EMarker{4;W]EDefn7 IString{4;S]IL0 IVar{4;W]IL1 IBuiltin{4;W'L]IL2 ICall{4;W'L]IL3 ILocal{4;W'W]IL4 IFuncall{4;L]IL5 IConcat{4;L]IL6 IBlock{4;L]IL7 ILambda{4;S]IL8 IWhere{4;W]IL9 ICrumb{4;W'S]IL10 IEnv{4;S'L]IL11 *is-boot*{0;~%;i *compile-file*{0;~%;i *compile-subject*{0;~%;i
$(call ^R,core)
$(call ^R,parse)
~*is-boot* := 
$(call ^at,!1:IL0!=IString!0S !1:IL1!=IVar!0W !1:IL2!=IBuiltin!0W!0L !1:IL3!=ICall!0W!0L !1:IL4!=ILocal!0W!0W !1:IL5!=IFuncall!0L !1:IL6!=IConcat!0L !1:IL7!=IBlock!0L !1:IL8!=ILambda!0S !1:IL9!=IWhere!0W !1:IL10!=ICrumb!0W!0S !1:IL11!=IEnv!0S!0L)
$(call ^at,!1:EDefn0!=EVar!0S!0W !1:EDefn1!=EFunc!0S!0W!0S!0L !1:EDefn2!=EIL!0S!0W!0L !1:EDefn3!=EXMacro!0S!0W !1:EDefn4!=ERecord!0S!0W!0S !1:EDefn5!=EBuiltin!0S!0W!0S !1:EDefn6!=EArg!0W !1:EDefn7!=EMarker!0W)
~il-merge-strings = $(if $(filter !:IL0,$(word 1,$(call ^n,1,$1))),$(call ~il-merge-strings,$(wordlist 2,99999999,$1),$2$(call ^n,2,$(call ^n,1,$1))),$(call ~append,$(if $2,$(call ^d,!:IL0 $(call ^d,$2))),$(word 1,$1),$(if $(word 2,$1),$(call ~il-merge-strings,$(wordlist 2,99999999,$1),))))
~il-flatten = $(filter %,$(foreach node,$1,$(if $(filter !:IL6,$(word 1,$(call ^u,$(node)))),$(call ~il-flatten,$(wordlist 2,99999999,$(call ^u,$(node)))),$(node))))
~il-concat = $(call ^Y,$(call ~il-merge-strings,$(call ~il-flatten,$1),),,,,,,,,,$`(if $`(word 2,$`1),!:IL6 $`1,$`(or $`(call ^n,1,$`1),!:IL0 !.)))
~il-demote = $(or $(if $(filter !:IL0,$(word 1,$1)),!:IL0 $(call ^d,$(word 2,$1)),$(if $(filter !:IL3,$(word 1,$1)),$(if $(call ~eq?,$(word 2,$1),^u),$(call ^n,1,$(wordlist 3,99999999,$1))))),!:IL3 ^d $(call ^d,$1))
~il-promote = !:IL3 ^u $(call ^d,$1)
~il-subst = $(if $(filter !:IL0,$(word 1,$3)),!:IL0 $(call ^d,$(subst $1,$2,$(call ^n,2,$3))),!:IL2 subst $(call ^d,!:IL0 $(call ^d,$1)) $(call ^d,!:IL0 $(call ^d,$2)) $(call ^d,$3))
~gen-native-name = $(and $(~*is-boot*),$(if $(filter %&native,$2),,1),~)$1
~gensym-name = $(if $(filter $1&$3!=%,$2),$(call ~gensym-name,$1,$2 .,$(words $2)),$1&$3)
~current-depth = $(call ^Y,$(call ~dict-get,:,$1),,,,,,,,,$`(if $`(filter !:EDefn7,$`(word 1,$`1)),$`(word 2,$`1)))
~gensym = !:P2 0 $(call ^d,$(call ~gensym-name,$(call ~symbol-name,$1),$2,))
~gen-error = !:P8 $(or $(call ~form-index,$1),$(if $(call ~numeric?,$1),$1,0)) $(call ^d,$(call ~vsprintf,$2,$(foreach N,3,$(^v))))
~form-description = $(if $(call ~eq?,$1,%),form,$(if $(call ~eq?,$1,L),list,$(if $(call ~eq?,$1,S),symbol,$(if $(call ~eq?,$1,Q),literal string,$(call ~form-typename,$1)))))
~err-expected = $(call ~gen-error,$(or $2,$3),$(if $2,invalid,missing) $4 in $5$(if $1,; expected a $(subst |1,|,$(subst |0, ,$(subst $  , or ,$(foreach ty,$1,$(subst $  ,|0,$(subst |,|1,$(call ~form-description,$(call ^u,$(ty)))))))))),$6,$7)
~check-argc = $(if $(if $(or $(filter $1,$(words $2)),$(and $(filter more,$1),$(or $(call ~eq?,0,$(word 1,$1)),$(word $(word 1,$1),$2)))),,1),$(call ~gen-error,$3,$(subst %S,$(if $(call ~eq?,$1,1),,s),$(if ,,%q accepts %s argument%S, not %s)),$(call ~symbol-name,$3),$1,$(words $2)))
~builtins-1 := abspath basename dir error eval firstword flavor info lastword notdir origin realpath shell sort strip suffix value warning wildcard words
~builtins-2 := addprefix addsuffix filter filter-out findstring join word
~builtins-3 := .foreach patsubst .subst wordlist
~builtin-names := $(patsubst .%,%,$(~builtins-1) $(~builtins-2) $(~builtins-3) and or call if)
~base-env := $(call ~append,$(foreach b,$(~builtins-1),$(call ^k,$b)!=$(call ^d,!:EDefn5 $(call ^d,$b) i 1)),$(foreach b,$(~builtins-2),$(call ^k,$b)!=$(call ^d,!:EDefn5 $(call ^d,$b) i 2)),$(foreach b,$(~builtins-3),$(call ^k,$b)!=$(call ^d,!:EDefn5 $(call ^d,$(patsubst .%,%,$b)) i 3)),$(foreach b,and or call,$(call ^k,$b)!=$(call ^d,!:EDefn5 $(call ^d,$b) i %)),if!=$(call ^d,!:EDefn5 if i 2!0or!03),$(foreach v,MAKEFILE_LIST .DEFAULT_GOAL,$(call ^k,$v)!=$(call ^d,!:EDefn0 $(call ^d,$v) i)))
~resolve = $(if $(filter !:P2,$(word 1,$1)),$(call ^n,2,$(subst !=, ,$(or $(filter $(subst !,!1,$(call ^n,3,$1))!=%,$2),$(filter $(subst !,!1,$(call ^n,3,$1))!=%,$(~base-env))))),-)

endef

define [mod-io]
# Requires: core
# Exports: unescape-path#escape-path#resolve-path"clean-path#save-blob"hash-output#hash-file#hash-files#mkdir-p#file-exists?#cp-file}2'or'3 read-file#read-lines}1'or'2'or'3 chmod-file"write-file"getline#fprintf}2'or'more write"echo-command#shell!1{1;~%1;i;1 quote-sh-file#quote-sh-arg#ioshell}1
$(call ^R,core)
~ioshell = $(and $(if $(filter S,$(SCAM_DEBUG)),$(info shell: $1))1,$(shell $1))
~quote-sh-arg = '$(subst ','\'',$1)'
~quote-sh-file = $(call ~quote-sh-arg,$(if $(filter -%,$(call ^d,$1)),./)$1)
define ~shell!
$(call ~concat-vec,$(subst !r,,$(addsuffix 
,$(call ~ioshell,( $1 ) | sed -e '$(if ,$(if ,,,!d;))s/!/!1/g;s/ /!0/g;s/	/!+/g;s//!r/g;s/^$`/!./'))))
endef
define ~echo-command
printf '%b' $(call ~quote-sh-arg,$(subst 
,\n,$(subst \,\\,$1)))
endef
~write = $(wordlist 2,99999999,$(call ~ioshell,$(call ~echo-command,$2)$(if $(filter 2,$1), 3>&2 2>&1 1>&3 3>&-, 2>&1 >&$(patsubst 1,9,$1))))
~fprintf = $(call ~write,$1,$(call ~vsprintf,$2,$(foreach N,3,$(^v))))
~getline = $(and $(if $1,$(call ~write,1,$1))1,$(call ~shell!,head -1))
~concat-groups = $(call ^Y,$(patsubst %,!.,$(wordlist 1,$2,$1)),$(patsubst %,!.,$1),$1,,,,,,,$`(subst !., ,$`(subst !. ,,$`(join $`3,$`(subst $`1,$`1!.,$`2)))))
define ~write-file
$(or $(wordlist 2,99999999,$(call ~ioshell,rm -f $(call ~quote-sh-file,$1) 2>&1 && 2>&1 > $(call ~quote-sh-file,$1_[tmp]))),$(and $(foreach line,$(call ~concat-groups,$(subst 
,
 ,$(call ^d,$2)),50),$(call ^d,$(call ~ioshell,$(call ~echo-command,$(call ^u,$(line))) >> $(call ~quote-sh-file,$1_[tmp]))))1,$(wordlist 2,99999999,$(call ~ioshell,mv $(call ~quote-sh-file,$1_[tmp]) $(call ~quote-sh-file,$1) 2>&1 || rm $(call ~quote-sh-file,$1_[tmp]) 2>&1))))
endef
~chmod-file = $(call ~ioshell,chmod $(call ~quote-sh-arg,$2) $(call ~quote-sh-file,$1) 2>&1)
~read-lines = $(subst !r,,$(call ~ioshell,(( cat $(call ~quote-sh-file,$1) && echo ) | sed -e '$(if $2,$(if ,,$2,$3!d;))s/!/!1/g;s/ /!0/g;s/	/!+/g;s//!r/g;s/^$`/!./' ) 2>/dev/null))
define ~read-file
$(if $1,$(call ~concat-vec,$(call ~read-lines,$1),
),$(info error: read-file: nil filename))
endef
~cp-file = $(call ~ioshell,$(if $3,mkdir -p $(call ~quote-sh-file,$(dir $2)) 2>&1 && )cp $(call ~quote-sh-file,$1) $(call ~quote-sh-file,$2) 2>&1)
~file-exists? = $(if $(call ~ioshell,[[ -f $(call ~quote-sh-file,$1) ]] && echo t),$1)
~mkdir-p = $(call ~ioshell,mkdir -p $(call ~quote-sh-file,$1) 2>&1)
~*hash-cmd* := 
~hash-cmd = $(or $(~*hash-cmd*),$(and $(call ^set,~*hash-cmd*,$(subst md5,md5 -r,$(or $(notdir $(word 1,$(shell which md5 sha1sum shasum))),$(error $(if ,,no md5, shasum, or sha1sum in path)))))1,$(~*hash-cmd*)))
~hash-files = $(foreach dline,$(call ~ioshell,$(call ~hash-cmd) $(foreach f,$1,$(call ~quote-sh-file,$(call ^u,$f))) 2>/dev/null | sed 's/\(^................\)[^ ]*/\1/;s/!/!1/g;s/ /!0/g;s/	/!+/g'),$(foreach hash,$(word 1,$(subst !0, ,$(dline))),$(subst %,!8,$(patsubst $(hash)!0$(if $(filter s%,$(call ~hash-cmd)),!0)%,%,$(dline)))!=$(call ^d,$(hash))))
~hash-file = $(call ^n,2,$(subst !=, ,$(call ~hash-files,$(call ^d,$1))))
~hash-output = $(call ~ioshell,( $1 ) | $(if $(filter md5,$(basename $(call ~hash-cmd))),md5 -q,$(call ~hash-cmd) -) | sed 's/\(^................\).*/\1/')
~save-blob = $(addprefix $1,$(call ~ioshell,( t=$`(mktemp $(call ~quote-sh-file,$1objtmp.XXXXXXXX)) && $(call ~echo-command,$2) > "$`t" && h=$`($(call ~hash-cmd) "$`t") && n="$`{h:0:16}" && mv -f "$`t" $(call ~quote-sh-file,$1)"$`n" && echo "$`n") 2>/dev/null))
~clean-path-x = $(if $1,$(filter ..,$(word 1,$1)$(word 1,$2)) $(call ~clean-path-x,$(wordlist 2,99999999,$1),$(subst /, ,$(filter-out %/..,$2/$(word 1,$1)))),$2)
~clean-path = $(call ^u,$(patsubst /./,/,$(if $(filter /%,$1),/)$(or $(subst $  ,/,$(filter %,$(call ~clean-path-x,$(filter-out .,$(subst /, ,$(call ^d,$1)))))),.)$(if $(filter %/,$1),/)))
~resolve-path = $(call ~clean-path,$(if $(filter /%,$2),$2,$1/$2))
define ~escape-path
$(patsubst /%,+/%,$(subst ..,+.,$(subst 
,+_,$(subst $ 	,+-,$(subst |,+V,$(subst ?,+Q,$(subst *,+A,$(subst ~,+T,$(subst %,+P,$(subst =,+E,$(subst ;,+S,$(subst :,+C,$(subst $`,+D,$(subst \,+B,$(subst #,+H,$(subst !,+1,$(subst $  ,+0,$(subst +,+2,$1))))))))))))))))))
endef
define ~unescape-path
$(subst +2,+,$(subst +0, ,$(subst +1,!,$(subst +H,#,$(subst +B,\,$(subst +D,$`,$(subst +C,:,$(subst +S,;,$(subst +E,=,$(subst +P,%,$(subst +T,~,$(subst +A,*,$(subst +Q,?,$(subst +V,|,$(subst +-,	,$(subst +_,
,$(subst +.,..,$(subst +/,/,$1))))))))))))))))))
endef

endef

define [mod-parse]
# Requires: core string
# Exports: describe-error}3 get-subject-line"parse-text#parse-subject#pdec#penc#format-form#form-typename#form-index#PList-is-empty?#string-value#symbol-to-string#symbol-name#PList{4;W'L]P0 PString{4;W'S]P1 PSymbol{4;W'S]P2 PDict{4;W'L]P3 PQuote{4;W'L]P4 PQQuote{4;W'L]P5 PUnquote{4;W'L]P6 PSplice{4;W'L]P7 PError{4;W'S]P8
$(call ^R,core)
$(call ^R,string)
$(call ^at,!1:P0!=PList!0W!0L !1:P1!=PString!0W!0S !1:P2!=PSymbol!0W!0S !1:P3!=PDict!0W!0L !1:P4!=PQuote!0W!0L !1:P5!=PQQuote!0W!0L !1:P6!=PUnquote!0W!0L !1:P7!=PSplice!0W!0L !1:P8!=PError!0W!0S)
~symbol-name = $(if $(filter !:P2,$(word 1,$1)),$(call ^n,3,$1),ERROR:symbol-name($1))
~symbol-to-string = $(if $(filter !:P2,$(word 1,$1)),!:P1 $(word 2,$1) $(call ^d,$(call ^n,3,$1)),ERROR:symbol-to-string($1))
~string-value = $(if $(filter !:P1,$(word 1,$1)),$(call ^n,3,$1),ERROR:string-value($1))
~PList-is-empty? = $(if $(filter !:P0,$(word 1,$1)),$(if $(wordlist 3,99999999,$1),,1),ERROR:PList.is-empty?($1))
~form-index = $(if $(filter !:P0 !:P1 !:P2 !:P3 !:P4 !:P5 !:P6 !:P7 !:P8,$(word 1,$1)),$(word 2,$1))
~form-typename = $(if $(filter !:P0,$(word 1,$1)),list,$(if $(filter !:P2,$(word 1,$1)),symbol,$(if $(filter !:P1,$(word 1,$1)),literal string,invalid form)))
~format-form = $(if $(filter !:P0,$(word 1,$1)),($(foreach f,$(wordlist 3,99999999,$1),$(call ~format-form,$(call ^u,$f)))),$(if $(filter !:P1,$(word 1,$1)),$(call ~format,$(call ^n,3,$1)),$(if $(filter !:P2,$(word 1,$1)),$(call ^n,3,$1),$(if $(filter !:P4,$(word 1,$1)),'$(call ~format-form,$(wordlist 3,99999999,$1)),$(if $(filter !:P5,$(word 1,$1)),`$(call ~format-form,$(wordlist 3,99999999,$1)),$(if ,,,$(call ~format,$1)))))))
~expand-spaces = $(subst !2,!0!0,$(subst !6,!2!2!2,$(subst !c,!6!6,$1)))
define ~penc
$(subst !6!6,!c,$(subst !2!0!2!0,!6,$(subst !0!0!0,!0!2,$(subst 
!0!0,
!2,$(subst 
 !0,
!0,$(subst ; ;,;;,$(subst !s, ,$(subst $  ,,$(foreach c,$(subst ;, ;,$(subst 
, 
,$(subst \, \,$(subst ", ",$(subst $  ,!s,$(subst !0 !0,!0!0,$(subst !0 !0,!0!0,$(subst $   , ,$(subst !+, !+ ,$(subst %, !p ,$(subst \, \,$(subst :, : ,$(subst $`, $` ,$(subst $[, $[ ,$(subst $], $] ,$(subst }, } ,$(subst {, { ,$(subst [, [ ,$(subst ], ] ,$(subst ", " ,$(subst 
, 
 ,$(subst !0, !0 ,$(subst ;, ; ,$(subst \",!Q,$(subst \\,!b,$(subst ', ' ,$(subst `, ` ,$(subst $(if ,,, @),$(if ,,,@ ),$(subst $(if ,,,),$(if ,, , ),$(if $1,$(call ^d,$1))))))))))))))))))))))))))))))),$(if $(filter ;%,$c),$(subst !s,,$c)!s,$c))))))))))
endef
~pdec = $(call ^u,$(call ~expand-spaces,$(subst !p,%,$(subst !b,\\,$(subst !Q,\",$(subst $  ,,$1))))))
~find-word = $(foreach p,$(call ~1+,$(call ~1+,$2)),$(if $(filter $3,$(or $(wordlist $2,$p,$1),$3)),$(if $(filter $3,$(or $(word $2,$1),$3)),$2,$(foreach q,$(call ~1+,$2),$(if $(filter $3,$(or $(word $q,$1),$3)),$q,$p))),$(call ~find-word,$1,$(call ~1+,$p),$3)))
~hex-ticks = $(filter :,$(subst :, : ,$(word 2,$(subst $1, ,xFf:Ee:Dd:Cc:Bb:Aa:9:8:7:6:5:4:3:2:1:))))
~hh-to-dec = $(words $(subst :,: : : : : : : : : : : : : : : :,$(call ~hex-ticks,$(word 1,$1))) $(call ~hex-ticks,$(word 2,$1)))
~hex-digits := 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F
define ~parse-string-bs
$(or $(if $(filter \n% \t%,$5),$(call ~parse-string,$1,$2,$(call ~1+,$3),$4$(subst \t,!+,$(subst \n,
,$5)))),$(foreach hh,$(foreach d1,$(~hex-digits),$(if $(filter \x$(d1)%,$5),$(foreach d2,$(~hex-digits),$(if $(filter \x$(d1)$(d2)%,$5),$(d1)
$(d2))))),$(call ~parse-string,$1,$2,$(call ~1+,$3),$4$(subst \x$(subst 
,,$(hh)),$(call ~strings-from-bytes,$(call ~hh-to-dec,$(strip $(hh)))),$5))),$(call ~find-word,$1,$3,") !:P8 $3 $(call ^d,!B))
endef
~parse-string = $(or $(foreach w,$(word $3,$1),$(if $(filter ",$w),$3 !:P1 $2 $(or $(call ~expand-spaces,$(subst !p,%,$(subst !b,\,$(subst !Q,",$(subst !.,,$4))))),!.),$(if $(filter \\%,$w),$(call ~parse-string-bs,$1,$2,$3,$4,$w),$(call ~parse-string,$1,$2,$(call ~1+,$3),$4$w)))),$3 !:P8 $2 ")
~parse-seq-err = $3 $(if $(filter .,$4),!:P8 $2 $(call ^d,$(subst ],[,$(subst $],$[,$1))),!:P8 $3 $(call ^d,$4 $1))
~parse-seq = $(if $(filter !:P8,$(word 1,$(wordlist 2,99999999,$4))),$(if $(call ~eq?,$2,$(call ^n,3,$(wordlist 2,99999999,$4))),$(word 1,$4) !:P0 $3 $5,$(call ~parse-seq-err,$2,$3,$(word 2,$(wordlist 2,99999999,$4)),$(call ^n,3,$(wordlist 2,99999999,$4)))),$(call ~parse-seq,$1,$2,$3,$(call ~parse-exp,$1,$(call ~1+,$(word 1,$4))),$(call ~conj,$5,$(wordlist 2,99999999,$4))))
~parse-array = $(call ~parse-seq,$1,],$2,$(call ~parse-exp,$1,$(call ~1+,$2)),$(call ^d,!:P2 0 vector))
define ~parse-skip
$(if $(filter !0% !+% 
% ;%,$(word $2,$1)),$(call ~parse-skip,$1,$(call ~1+,$2)),$2)
endef
~parse-dict = $(call ~parse-dict-1,$1,$2,,$(call ~parse-exp,$1,$(call ~1+,$2)))
~parse-dict-error = $(if $(filter !:P8,$(word 1,$(wordlist 2,99999999,$1))),$(if $(call ~eq?,.,$(call ^n,3,$(wordlist 2,99999999,$1))),$(word 2,$(wordlist 2,99999999,$1)) !:P8 $3 {,$(if $(if $(filter $2,$(call ^d,$(call ^n,3,$(wordlist 2,99999999,$1)))),,1),$(word 2,$(wordlist 2,99999999,$1)) !:P8 $(word 2,$(wordlist 2,99999999,$1)) $(call ^d,$(call ^n,3,$(wordlist 2,99999999,$1)) }))))
~parse-dict-1 = $(or $(call ~parse-dict-error,$4,},$2),$(if $(filter !:P8,$(word 1,$(wordlist 2,99999999,$4))),$(word 1,$4) !:P3 $2 $3,$(call ~parse-dict-2,$1,$2,$3,$(wordlist 2,99999999,$4),$(call ~parse-skip,$1,$(call ~1+,$(word 1,$4))))))
~parse-dict-2 = $(if $(filter :,$(word $5,$1)),$(call ~parse-dict-3,$1,$2,$3,$4,$(call ~parse-exp,$1,$(call ~1+,$5))),$5 !:P8 $5 :?)
~parse-dict-3 = $(or $(call ~parse-dict-error,$5,},$2),$(if $(filter !:P8,$(word 1,$(wordlist 2,99999999,$5))),$(if $(call ~eq?,$(call ^n,3,$(wordlist 2,99999999,$5)),}),$(word 2,$(wordlist 2,99999999,$5)) !:P8 $(word 2,$(wordlist 2,99999999,$5)) v?)),$(call ~parse-dict-4,$1,$2,$(call ~append,$3,$(call ^k,$4)!=$(call ^d,$(wordlist 2,99999999,$5))),$(call ~parse-skip,$1,$(call ~1+,$(word 1,$5)))))
~parse-dict-4 = $(call ~parse-dict-1,$1,$2,$3,$(call ~parse-exp,$1,$(if $(filter $(if ,,,),$(word $4,$1)),$(call ~1+,$4),$4)))
~parse-x2 = $(if $(filter !:P8,$(word 1,$(wordlist 2,99999999,$3))),$3,$(word 1,$3) $(call ^Y,$2,$(wordlist 2,99999999,$3),,,,,,,,$(if $(filter ',$1),!:P4 $`1 $`2,$(if $(filter `,$1),!:P5 $`1 $`2,$(if $(filter $(if ,,,),$1),!:P6 $`1 $`2,$(if $(filter $(if ,,,@),$1),!:P7 $`1 $`2,!:P8 $(call ^E,$2) $`(call ^d,internal:parse-x2:$(call ^E,$1))))))))
define ~parse-x
$(if $(filter !0% !+% 
% ;% (),$(or $(word $(call ~1+,$3),$2),())),$3 !:P8 $3 $(call ^d,$1),$(call ~parse-x2,$1,$3,$(call ~parse-exp,$2,$(call ~1+,$3))))
endef
define ~parse-exp
$(or $(foreach w,$(word $2,$1),$(if $(filter !0% !+% 
%,$w),$(call ~parse-exp,$1,$(call ~1+,$2)),$(if $(filter $] ] },$w),$2 !:P8 $2 $(call ^d,$w),$(if $(filter $[,$w),$(call ~parse-seq,$1,$],$2,$(call ~parse-exp,$1,$(call ~1+,$2)),),$(if $(filter ",$w),$(call ~parse-string,$1,$2,$(call ~1+,$2)),$(if $(filter ;%,$w),$(call ~parse-exp,$1,$(call ~1+,$(call ~find-word,$1,$2,
%))),$(if $(filter [,$w),$(call ~parse-array,$1,$2),$(if $(filter {,$w),$(call ~parse-dict,$1,$2),$(if $(filter $(if ,,' ` , ,@),$w),$(call ~parse-x,$w,$1,$2),$(if $(call ~numeric?,$w),$2 !:P1 $2 $(call ^d,$w),$(if $(filter $` : !p,$w),$2 !:P8 $2 $(call ^d,$(call ~pdec,$w)),$2 !:P2 $2 $w))))))))))),$2 !:P8 $2 .)
endef
~parse-subject = $(call ^Y,$(wordlist 2,99999999,$(call ~parse-seq,$1,.,0,$(call ~parse-exp,$1,1),)),,,,,,,,,$`(if $`(filter !:P0,$`(word 1,$`1)),$`(wordlist 3,99999999,$`1),$`(call ^d,$`1)))
~parse-text = $(call ~parse-subject,$(call ~penc,$1))
define ~get-subject-line
$(words $(filter 
%,$(wordlist 1,$(or $1,1),
 $2)))
endef
~get-error-msg = $(if $(filter ` ',$(word 1,$1)),prefix "$(word 1,$1)" must immediately precede expression,$(if $(filter ( ) [ ] { },$(word 1,$1)),unmatched "$(word 1,$1)",$(if $(filter ",$(word 1,$1)),unterminated string,$(if $(filter $(if ,,: ,),$(word 1,$1)),saw ":" where not expected,$(if $(filter :?,$(word 1,$1)),expected ": VALUE" following dictionary key,$(if $(filter v?,$(word 1,$1)),expected value following dictionary "KEY:",$(if $(filter !B,$(word 1,$1)),invalid backslash sequence in string,$(if $(filter $(word 1,$1),$`),invalid symbol character "$(word 1,$1)",$1))))))))
define ~describe-error
$(if $(filter !:P8,$(word 1,$1)),$(call ^Y,$(call ^Y,$(subst 
, 
,$(subst $  ,,$(wordlist 1,$(or $(word 2,$1),1),
 $(call ~penc,$2)))),,,,,,,,,$`(words $`1):$`(call ~string-len,$`(call ~pdec,$`(lastword $`1)))),$2,$3,$(call ~get-error-msg,$(call ^n,3,$1)),,,,,,$`(if $`(call ~word-index?,$`(word 2,$(call ^E,$1))),$`(call ~sprintf,%s:%s: %s
%s
%s
,$`3,$`1,$`4,$`(call ^n,$`(word 1,$`(subst :, ,$`1)),$`(call ~split,
,$`2)),$`(subst $`  ^,^,$`(call ~string-repeat, ,$`(word 2,$`(subst :, ,$`1)))^)),$`(call ~sprintf,%s: %s
,$`3,$`(call ^n,3,$(call ^E,$1))))))
endef

endef

define [mod-math]
# Requires: core math0 math1 math2
# Exports: atan}1'or'2 atan2}2'or'3 get-pi}0'or'1 cos&1'or'2;!1.;!1:IL3;~xsin[|'\.[@'1'0[@'2'0 sin&1'or'2;!1.;!1:IL3;~x%[|'1[@'1'0[@'2'0 pow}2'or'3 exp}1'or'2 log}1'or'2'or'3 num-sort#num-lex#format-fixed}1'or'2'or'3 range"sum}0'or'more min"max"abs&1;!1.;!1:IL2;patsubst[|'-!p[|'!p[@'1'0 0-&1;!1.;!1:IL2;subst[|!1%-[|'\.[:IL6',|\%',@\01\00 <=(2;if[:IL2'findstring',|\01',:IL3\0~math-cmp\0,1@,01,00\0,1@,02,00[|'\.[|'1 >=(2;if[:IL2'findstring',|\01',:IL3\0~math-cmp\0,1@,02,00\0,1@,01,00[|'\.[|'1 =(2;if[:IL3'~math-cmp',@\01\00',@\02\00[|'\.[|'1 !1=(2;if[:IL3'~math-cmp',@\01\00',@\02\00[|'1 <(2;findstring[|'1[:IL3'~math-cmp',@\02\00',@\01\00 >(2;findstring[|'1[:IL3'~math-cmp',@\01\00',@\02\00 round}1'or'2'or'3 trunc&1;!1.;!1:IL3;~raw-round[@'1'0[|'0[|'1 ceil&1;!1.;!1:IL3;~raw-round[@'1'0[|'0[|'3 floor&1;!1.;!1:IL3;~raw-round[@'1'0[|'0[|'9 mod(3;~binop[|'%[@'1'0[@'2'0 ^(3;~binop[|'pwr[@'1'0[@'2'0 *~&2'or'3;!1.;!1:IL3;~prec-op[|'mulp[@'1'0[@'2'0[@'3'0 /&2'or'3;!1.;!1:IL3;~prec-op[|'div[@'1'0[@'2'0[@'3'0[|'1 //(3;~binop[|'fdiv[@'1'0[@'2'0 *(3;~binop[|'mul[@'1'0[@'2'0 -(3;~binop[|'sub[@'1'0[@'2'0 +(3;~binop[|'add[@'1'0[@'2'0
$(call ^R,core)
$(call ^R,math0)
$(call ^R,math1)
$(call ^R,math2)
~raw-add = $(if $(subst 0,,$(subst 1,,$(subst 9,,$(subst 9-0,,9$19$2)))),$(call ~fp2u,$(call ~fp-add,$(call ~u2fp,$1),$(call ~u2fp,$2))),$(call ~u-add,$1,$2))
~raw-sub = $(if $(subst 1,,$(subst 0,,$1$2)),$(if $(subst 0,,$(subst 1,,$(subst 9,,$(subst 9-0,,9$19$2)))),$(call ~fp2u,$(call ~fp-add,$(call ~u2fp,$1),$(subst !,-,$(subst $  -, +,$(subst $  +, !,$(call ~u2fp,$2)))))),$(call ~u-add,$1,$(subst --,,-$2))),$(call ~u-sub-unsigned,$1,$2))
~raw-mul-s = $(if $(subst 0,,$(subst 1,,$(subst 9,,$(subst 9-0,,9$19$2)))),$(call ~fp2u,$(call ~fp-mul,$(call ~u2fp,$1),$(call ~u2fp,$2))),$(patsubst -0,0,$(filter -,$(findstring -,$1)$(findstring -,$2))0$(subst $  ,,$(wordlist 2,99999999,$(subst 01,0 1,$(subst $  ,,$(call ~uf-mul,$(strip $(subst 0, 0,$(subst -,,$1))),$(strip $(subst 0, 0,$(subst -,,$2))))))))))
~raw-mul = $(if $(subst 1,,$(subst 0,,$1$2)),$(call ~raw-mul-s,$1,$2),0$(subst $  ,,$(wordlist 2,99999999,$(subst 01,0 1,$(subst $  ,,$(call ~uf-mul,$(strip $(subst 0, 0,$1)),$(strip $(subst 0, 0,$2))))))))
~raw-fdiv = $(if $(subst 1,,$(subst 0,,$1$2)),$(call ~fp2u,$(call ~fp-div,$(call ~u2fp,$1),$(call ~u2fp,$2),0,)),$(or $(call ~u-fdiv,$1,$2,1),NaN))
~raw-mod = $(if $(subst 1,,$(subst 0,,$1$2)),$(call ~fp2u,$(call ~fp-mod,$(call ~u2fp,$1),$(call ~u2fp,$2))),$(or $(call ~u-fdiv,$1,$2,4),NaN))
~raw-round = $(call ~u2d,$(call ~fp2u,$(call ~fp-round,$(call ~u2fp,$(call ~d2u,$1)),$2,$3)))
~raw-cmp = $(if $(subst 1,,$(subst 0,,$1$2)),$(call ~fp-cmp,$(call ~u2fp,$1),$(call ~u2fp,$2)),$(word 1,$(subst 0,,$(subst 1~,,$(subst 11~~,,$(subst 10~,,$(subst 111110~~~~~,0,$(join $(subst 0, 0,$(subst 1,,$2)$1),$(subst 0, 0,$(subst 1,,$1)$(subst 1,~,$2))))))))))
~math-cmp = $(call ~raw-cmp,$(subst 3,0111,$(subst 6,3111,$(subst 8,611,$(subst 9,81,$(subst 7,61,$(subst 5,311,$(subst 4,31,$(subst 2,011,$(subst 1,01,$(or $1,?)))))))))),$(subst 3,0111,$(subst 6,3111,$(subst 8,611,$(subst 9,81,$(subst 7,61,$(subst 5,311,$(subst 4,31,$(subst 2,011,$(subst 1,01,$(or $2,?)))))))))))
~raw-pwr = $(if $(subst 1,,$(subst 0,,$2)),NaN,$(call ~fp2u,$(call ~fp-pwr,$(call ~u2fp,$1),$2)))
~binop = $(subst 01,1,$(subst 011,2,$(subst 31,4,$(subst 311,5,$(subst 61,7,$(subst 81,9,$(subst 611,8,$(subst 3111,6,$(subst 0111,3,$(call ~raw-$1,$(subst 3,0111,$(subst 6,3111,$(subst 8,611,$(subst 9,81,$(subst 7,61,$(subst 5,311,$(subst 4,31,$(subst 2,011,$(subst 1,01,$(or $2,?)))))))))),$(subst 3,0111,$(subst 6,3111,$(subst 8,611,$(subst 9,81,$(subst 7,61,$(subst 5,311,$(subst 4,31,$(subst 2,011,$(subst 1,01,$(or $3,?))))))))))))))))))))
~prec-op = $(subst 01,1,$(subst 011,2,$(subst 31,4,$(subst 311,5,$(subst 61,7,$(subst 81,9,$(subst 611,8,$(subst 3111,6,$(subst 0111,3,$(call ~fp2u,$(call ~fp-$1,$(call ~u2fp,$(subst 3,0111,$(subst 6,3111,$(subst 8,611,$(subst 9,81,$(subst 7,61,$(subst 5,311,$(subst 4,31,$(subst 2,011,$(subst 1,01,$(or $2,?))))))))))),$(call ~u2fp,$(subst 3,0111,$(subst 6,3111,$(subst 8,611,$(subst 9,81,$(subst 7,61,$(subst 5,311,$(subst 4,31,$(subst 2,011,$(subst 1,01,$(or $3,?))))))))))),$(call ~prec-to-pod,$4),$5)))))))))))
~round = $(call ~raw-round,$1,$(if $2,$(call ~prec-to-pod,$2),0),$(or $(if $3,$(filter 9 3 1,$(subst |,1,$(subst +,3,$(subst -,9,$3))))),2))
~max = $(if $(findstring 1,$(call ~math-cmp,$2,$1)),$2,$1)
~min = $(if $(findstring 1,$(call ~math-cmp,$1,$2)),$2,$1)
~fp-sum = $(if $(word 2,$1),$(call ~fp-add,$(call ^n,1,$1),$(call ~fp-sum,$(wordlist 2,99999999,$1))),$(call ^n,1,$1))
~sum-vec = $(if $(findstring !,$1),$(if $(findstring !0,$(subst !1,!0,$1)),$(call ~sum-vec,$(call ^u,$1))),$(call ~u2d,$(call ~fp2u,$(call ~fp-sum,$(foreach u,$(call ~d2u,$1),$(call ^d,$(call ~u2fp,$(call ^u,$u))))))))
~sum = $(call ~sum-vec,$(call ^u,$(foreach N,1,$(^v))))
~uv-trim = $(wordlist $(words $(subst 1,1 ,$(subst 0,,$1$21))),$(words $3),$(subst 1,1 ,$(subst 0,,$2)) $3)
~uv-range = $(if $(findstring 1,$(call ~u-cmp,$1,$2)),,$(call ~uv-trim,$(lastword $1),$(subst $(lastword $2),0,0111111111),$(if $(if $(word 2,$1),,1),0 1 2 3 4 5 6 7 8 9 )$(foreach n,$(call ~uv-range,$(or $(filter-out %x,$1x),01),$(filter-out %x,$2x)),$n0 $n1 $n2 $n3 $n4 $n5 $n6 $n7 $n8 $n9 )))
~uv-sign-range = $(if $3,$(addprefix -,$(call ~reverse,$(call ~uv-range,$(if $4,$2,1),$1))) )$(if $4,,$(call ~uv-range,$(if $3,0,$1),$2))
~u-to-uv = $(or $(strip $(subst 0, 0,$(filter 01%,$(subst 01, 01,$(subst -,,$1))))),0)
~raw-range = $(strip $(if $(subst 0,,$(subst 1,,$(subst 9,,$(subst 9-0,,9$19$2)))),,$(call ~uv-sign-range,$(call ~u-to-uv,$1),$(call ~u-to-uv,$2),$(findstring 1,$(filter -%,$1)),$(findstring 1,$(filter -%,$2)))))
~range = $(call ~raw-range,$(call ~d2u,$1),$(call ~d2u,$2))
~format-fixed = $(foreach p,$(if $3,$(call ~d2u,$3),?),$(if $(subst 1,,$(subst 0,,$(if $3,$p)$(if $2,$(call ~d2u,$2)))),$(if $(and $3,$(subst 1,,$(subst 0,,$p))),[invalid_PRECISION],[invalid_MIN-WIDTH]),$(call ~fp-fix,$(call ~fp-round,$(call ~u2fp,$(call ~d2u,$1)),$(if $3,$p,0),2),$2,$3,$p)))
~lex-exp = $(if $(subst 0,,$(filter-out -%,$1)),$(patsubst 0111111111%,%,$(subst 9,0111111111,$(subst 90111111111,9909,$(subst 0,9,$(subst 1,,$1))$1))),$(subst 1~,,$(subst 11~~,,$(subst 111~~~,,$(subst 111111~~~~~~,,$(subst 0,0111111111,$(subst 1,~,$(subst 9,0111111111,$(subst 90111111111,9909,$(subst 0,9,$(subst 1,,$(subst -,,$1)))$(subst -,,$1))))))))))
~fp-lex = $(if $(findstring - 01,$(filter-out 0,.$1)),-$(subst 1~,,$(subst 11~~,,$(subst 111~~~,,$(subst 111111~~~~~~,,$(subst 0,0111111111,$(subst 1,~,$(call ~fp-lex,$(subst !,-,$(subst $  -, +,$(subst $  +, !,$1)))))))))):,$(if $(findstring 1,$(wordlist 3,99999999,$1)),$(call ~lex-exp,$(word 1,$1))$(wordlist 3,99999999,$1),0))
~num-lex = $(call ~u2d,$(subst $  ,,$(call ~fp-lex,$(call ~u2fp,$(call ~d2u,$1)))))
define ~num-sort
$(filter-out %!#,$(subst !#,!# ,$(sort $(foreach elem,$1,$(call ~num-lex,$(word 1,$(subst !, ,$(elem))))!#$(elem)))))
endef
~log = $(call ~u2d,$(call ~fp2u,$(if $2,$(call ~fp-log-x-b,$(call ~u2fp,$(call ~d2u,$1)),$(call ~u2fp,$(call ~d2u,$2)),$(call ~prec-to-pod,$3)),$(call ~fp-log,$(call ~u2fp,$(call ~d2u,$1)),$(call ~prec-to-pod,$3)))))
~exp = $(call ~u2d,$(call ~fp2u,$(call ~fp-exp,$(call ~u2fp,$(call ~d2u,$1)),$(call ~prec-to-pod,$2))))
~pow = $(call ~u2d,$(call ~fp2u,$(call ~fp-pow,$(call ~u2fp,$(call ~d2u,$1)),$(call ~u2fp,$(call ~d2u,$2)),$(call ~prec-to-pod,$3))))
~get-pi = $(or $(foreach pod,$(call ~prec-to-pod,$1),$(or $(patsubst 31%,3.1%,$(call ~u2d,$(subst $  ,,$(subst ., ,$(filter-out %0,$(subst 0 ,0.,$(call ~get-uf-const,~uf-pi,$(if $(filter 0% -0%,$(pod)),$(call ~u-zeros,$(call ~u-add-ones,$(pod),1)),$(call ~extend-fn,0,$(pod), 0 0 0 0))))))))),0)),NaN:PREC)
~atan2 = $(or $(foreach pod,$(call ~prec-to-pod,$3),$(call ~u2d,$(call ~fp2u,$(call ~fp-round,$(call ~fp-atan2,$(call ~u2fp,$(call ~d2u,$1)),$(call ~u2fp,$(call ~d2u,$2)),$(pod)),$(or $(~result-pod),$(pod)),2)))),NaN:PREC)
~atan = $(call ~atan2,$1,1,$2)

endef

define [mod-gen0]
# Requires: core parse escape gen math
# Exports: gen0"c0"c0-block"ModSuccess{4;S'S]Mod0 ModError{4;S]Mod1 get-module}3 c0-vec"skip-flags"get-flags}2
$(call ^R,core)
$(call ^R,parse)
$(call ^R,escape)
$(call ^R,gen)
$(call ^R,math)
~*warn-upvals* := $(findstring U,$(value SCAM_DEBUG))
~scan-flags-x = $(or $(if $(filter !:P2,$(word 1,$(call ^n,$2,$1))),$(if $(filter &private &public &native,$(call ^n,3,$(call ^n,$2,$1))),$(call ~scan-flags-x,$1,$(call ~1+,$2),$2))),$3)
~get-flags = $(filter %,$(foreach form,$(wordlist $(call ~1+,$2),$(call ~scan-flags-x,$1,$(call ~1+,$2),$2),$1),$(if $(filter !:P2,$(word 1,$(call ^u,$(form)))),$(call ^n,3,$(call ^u,$(form))))))
~skip-flags = $(wordlist $(call ~1+,$(call ~scan-flags-x,$1,$(call ~1+,$2),$2)),99999999,$1)
~xlat-node = $(if $(filter !:IL0,$(word 1,$1)),$1,$(if $(filter !:IL2,$(word 1,$1)),!:IL2 $(word 2,$1) $(foreach n,$(wordlist 3,99999999,$1),$(call ^d,$(call ~xlat-node,$(call ^u,$n),$2,$3))),$(if $(filter !:IL3,$(word 1,$1)),!:IL3 $(word 2,$1) $(foreach n,$(wordlist 3,99999999,$1),$(call ^d,$(call ~xlat-node,$(call ^u,$n),$2,$3))),$(if $(filter !:IL4,$(word 1,$1)),$(if $(if $(findstring 1,$(call ~math-cmp,$2,$(word 3,$1))),,1),!:IL4 $(word 2,$1) $(call ~binop,add,$(word 3,$1),$3),$1),$(if $(filter !:IL6,$(word 1,$1)),!:IL6 $(foreach n,$(wordlist 2,99999999,$1),$(call ^d,$(call ~xlat-node,$(call ^u,$n),$2,$3))),$(if $(filter !:IL8,$(word 1,$1)),!:IL8 $(call ^d,$(call ~xlat-node,$(call ^n,2,$1),$(call ~1+,$2),$3)),$(if $(filter !:IL5,$(word 1,$1)),!:IL5 $(foreach n,$(wordlist 2,99999999,$1),$(call ^d,$(call ~xlat-node,$(call ^u,$n),$2,$3))),$(if $(filter !:IL7,$(word 1,$1)),!:IL7 $(foreach n,$(wordlist 2,99999999,$1),$(call ^d,$(call ~xlat-node,$(call ^u,$n),$2,$3))),$1))))))))
~xlat-where = $(if $(filter !:IL4 !:IL0 !:IL1,$(word 1,$1)),$1,$(if $(filter !:IL3,$(word 1,$1)),!:IL3 $(word 2,$1) $(foreach n,$(wordlist 3,99999999,$1),$(call ^d,$(call ~xlat-where,$(call ^u,$n),$2))),$(if $(filter !:IL2,$(word 1,$1)),!:IL2 $(word 2,$1) $(foreach n,$(wordlist 3,99999999,$1),$(call ^d,$(call ~xlat-where,$(call ^u,$n),$2))),$(if $(filter !:IL9,$(word 1,$1)),!:IL9 $(if $(word 2,$1),$2),$(if $(filter !:IL6,$(word 1,$1)),!:IL6 $(foreach n,$(wordlist 2,99999999,$1),$(call ^d,$(call ~xlat-where,$(call ^u,$n),$2))),$(if $(filter !:IL5,$(word 1,$1)),!:IL5 $(foreach n,$(wordlist 2,99999999,$1),$(call ^d,$(call ~xlat-where,$(call ^u,$n),$2))),$(if $(filter !:IL7,$(word 1,$1)),!:IL7 $(foreach n,$(wordlist 2,99999999,$1),$(call ^d,$(call ~xlat-where,$(call ^u,$n),$2))),$(if $(filter !:IL8,$(word 1,$1)),!:IL8 $(call ^d,$(call ~xlat-where,$(call ^n,2,$1),$2)),$1))))))))
~xlat-arg = $(if $(filter-out $3,$2),$(call ~xlat-node,$1,0,$(words $(subst .,. ,$(subst :$2,,:$3)))),$1)
~xlat-macro = $(if $(filter !:IL0,$(word 1,$1)),$1,$(if $(filter !:IL2,$(word 1,$1)),!:IL2 $(word 2,$1) $(foreach n,$(wordlist 3,99999999,$1),$(call ^d,$(call ~xlat-macro,$(call ^u,$n),$2,$3,$4))),$(if $(filter !:IL3,$(word 1,$1)),!:IL3 $(word 2,$1) $(foreach n,$(wordlist 3,99999999,$1),$(call ^d,$(call ~xlat-macro,$(call ^u,$n),$2,$3,$4))),$(if $(filter !:IL4,$(word 1,$1)),$(if $(call ~eq?,$(word 3,$1),$2),$(call ~xlat-arg,$(or $(call ^n,$(word 2,$1),$4),!:IL0 !.),.,.$(wordlist 1,$2,$(subst .,. . . . . . . . ,................))),$(if $(findstring 1,$(call ~math-cmp,$(word 3,$1),$2)),!:IL4 $(word 2,$1) $(call ~binop,add,$(word 3,$1),$3),$1)),$(if $(filter !:IL6,$(word 1,$1)),!:IL6 $(foreach n,$(wordlist 2,99999999,$1),$(call ^d,$(call ~xlat-macro,$(call ^u,$n),$2,$3,$4))),$(if $(filter !:IL8,$(word 1,$1)),!:IL8 $(call ^d,$(call ~xlat-macro,$(call ^n,2,$1),$(call ~1+,$2),$3,$4)),$(if $(filter !:IL5,$(word 1,$1)),!:IL5 $(foreach n,$(wordlist 2,99999999,$1),$(call ^d,$(call ~xlat-macro,$(call ^u,$n),$2,$3,$4))),$(if $(filter !:IL7,$(word 1,$1)),!:IL7 $(foreach n,$(wordlist 2,99999999,$1),$(call ^d,$(call ~xlat-macro,$(call ^u,$n),$2,$3,$4))),$1))))))))
~expand-macro = $(call ~xlat-macro,$(call ~xlat-where,$1,$5),0,$(call ~binop,sub,$(words $(subst .,. ,$(subst :$2,,:$3))),1),$4)
~check-optional-args = $(if $1,$(if $(filter ...% ?%,$(call ~symbol-name,$(call ^n,1,$1))),$(call ~check-optional-args,$(wordlist 2,99999999,$1),1),$(if $2,$(call ~gen-error,$(call ^n,1,$1),non-optional parameter after optional one),$(call ~check-optional-args,$(wordlist 2,99999999,$1),))))
~c0-local = $(and $(if $(and $(~*warn-upvals*),$(if $(findstring $2,$1),,1)),$(info $(call ~describe-error,$(call ~gen-error,$3,reference to upvalue %q,$(call ~symbol-name,$3)),$(call ~pdec,$(~*compile-subject*)),$(~*compile-file*))))1,!:IL4 $(subst .,,$1) $(words $(subst .,. ,$(subst $1,,$2$(subst .,,$1)))))
~c0-ctor = $(call ~c0-lambda,$1,$(foreach i,$(call ~indices-a,$(words $3)),$(call ^d,!:P2 0 $(call ^d,a$(call ^u,$i)))),$(call ^d,!:P0 0 $(call ~cons,$2,$(foreach i,$(call ~indices-a,$(words $3)),$(call ^d,!:P2 0 $(call ^d,a$(call ^u,$i)))))))
~c0-macro = $(call ~xlat-arg,!:IL8 $(call ^d,$(wordlist 2,99999999,$2)),$(call ^n,1,$2),$(call ~current-depth,$1))
~c0-builtin = !:IL8 $(call ^d,$(if $(word 1,$(filter 3 2 1,$3)),!:IL2 $2 $(foreach n,$(wordlist 1,$(word 1,$(filter 3 2 1,$3)),1 2 3),$(call ^d,!:IL4 $(call ^u,$n) 0)),!:IL3 ^na $(call ^d,!:IL0 $(call ^d,$2)) $(call ^d,!:IL1 ^av)))
~c0-S-error = $(if $2,$(call ~gen-error,$1,internal: %q binds to %q,$1,$2),$(call ~gen-error,$1,undefined variable %q,$(call ~symbol-name,$1)))
~c0-S = $(if $(filter !:EDefn6,$(word 1,$4)),$(call ~c0-local,$(word 2,$4),$(call ~current-depth,$1),$2),$(if $(filter !:EDefn0,$(word 1,$4)),!:IL1 $(call ^n,2,$4),$(if $(filter !:EDefn1,$(word 1,$4)),$(if $(filter :,$(call ^n,2,$4)),$(call ~c0-macro,$1,$(wordlist 5,99999999,$4)),!:IL2 value $(call ^d,!:IL0 $(call ^d,$(call ^n,2,$4)))),$(if $(filter !:EDefn2,$(word 1,$4)),$(call ~xlat-arg,$(call ~xlat-where,$(wordlist 4,99999999,$4),$(call ~form-index,$2)),$(call ^n,2,$4),$(call ~current-depth,$1)),$(if $(filter !:EDefn4,$(word 1,$4)),$(call ~c0-ctor,$1,$2,$(call ^n,2,$4)),$(if $(filter !:EDefn5,$(word 1,$4)),$(call ~c0-builtin,$1,$(call ^n,2,$4),$(call ^n,4,$4)),$(call ~c0-S-error,$2,$4)))))))
~c0-vec = $(foreach f,$1,$(call ^d,$(call ~c0,$(call ^u,$f),$2)))
~c0-call = $(or $(call ~check-argc,$5,$3,$2),$(if $6,$(call ~expand-macro,$(wordlist 2,99999999,$6),$(call ^n,1,$6),$(call ~current-depth,$1),$(foreach a,$3,$(call ^d,$(call ~c0,$(call ^u,$a),$1))),$(call ~form-index,$2)),!:IL3 $4 $(call ~c0-vec,$3,$1)))
~c0-record = $(or $(call ~check-argc,$(words $4),$3,$2),!:IL6 $(call ~cons,!:IL0 $(call ^d,$5),$(foreach n,$(call ~indices-a,$(words $4)),$(call ~append,$(call ^d,!:IL0 !0),$(call ^d,$(if $(filter S,$(word $n,$4)),$(call ~il-demote,$(call ~c0,$(call ^n,$n,$3),$1)),$(call ~c0,$(call ^n,$n,$3),$1)))))))
~c0-L = $(if $(filter !:EDefn1,$(word 1,$5)),$(call ~c0-call,$1,$3,$4,$(call ^n,2,$5),$(call ^n,4,$5),$(wordlist 5,99999999,$5)),$(if $(filter !:EDefn5,$(word 1,$5)),$(or $(call ~check-argc,$(call ^n,4,$5),$4,$3),!:IL2 $(call ^n,2,$5) $(call ~c0-vec,$4,$1)),$(if $(filter !:EDefn3,$(word 1,$5)),$(if $(call ~eq?,$(word 3,$5),x),$(call ~gen-error,$3,cannot use xmacro in its own file),$(call ~c0,$(call $(call ^n,2,$5),$4),$1)),$(if $(filter !:EDefn4,$(word 1,$5)),$(call ~c0-record,$1,$3,$4,$(call ^n,2,$5),$(call ^n,4,$5)),$(if $(if $3,,1),$(call ~gen-error,$2,missing function/macro name),$(if $5,!:IL5 $(call ~c0-vec,$(call ~cons,$3,$4),$1),$(if $(if $(filter-out u%,$(flavor ~ml.special-$(call ~symbol-name,$3))),1),$(call ~ml.special-$(call ~symbol-name,$3),$1,$3,$4),$(call ~gen-error,$3,undefined symbol: %q,$(call ~symbol-name,$3)))))))))
~lambda-env-arg9 = $(foreach n,$(call ~indices-a,$(words $1)),$(foreach name,$(call ~symbol-name,$(call ^n,$n,$1)),$(if $(filter ...%,$(name)),$(call ^k,$(or $(patsubst ...%,%,$(name)),$(name)))!=$(call ^d,$(if $(call ~eq?,$n,1),!:EDefn6 $29,!:EDefn2 $(call ^d,$2) - !:IL2 wordlist $(call ^d,!:IL0 $(call ^d,$n)) $(call ^d,!:IL0 999999) $(call ^d,!:IL4 9 0))),$(call ^k,$(patsubst ?%,%,$(name)))!=$(call ^d,!:EDefn2 $(call ^d,$2) - !:IL2 call $(call ^d,!:IL0 ^n) $(call ^d,!:IL0 $(call ^d,$n)) $(call ^d,!:IL4 9 0)))))
~lambda-env-args = $(call ~append,:!=$(call ^d,!:EDefn7 $2),$(foreach n,$(call ~indices-a,$(words $(wordlist 1,8,$1))),$(foreach name,$(call ~symbol-name,$(call ^n,$n,$1)),$(if $(filter ...%,$(name)),$(call ^k,$(or $(patsubst ...%,%,$(name)),$(name)))!=$(call ^d,!:EDefn2 !. - !:IL2 foreach $(call ^d,!:IL0 N) $(call ^d,!:IL0 $(call ^d,$n)) $(call ^d,!:IL1 ^v)),$(call ^k,$(patsubst ?%,%,$(name)))!=$(call ^d,!:EDefn6 $2$n)))),$(if $(word 9,$1),$(call ~lambda-env-arg9,$(wordlist 9,99999999,$1),$2)))
~c0-lambda = $(or $(call ~check-optional-args,$2),!:IL8 $(call ^d,$(call ~c0-block,$3,$(call ~append,$(call ~lambda-env-args,$2,.$(call ~current-depth,$1)),$1))))
~lambda-error = $(call ~err-expected,$1,$2,$3,$4,(lambda (ARGNAME...) BODY))
~ml.special-lambda = $(if $(filter !:P0,$(word 1,$(call ^n,1,$3))),$(or $(call ^n,1,$(filter-out !.,$(foreach a,$(wordlist 3,99999999,$(call ^n,1,$3)),$(call ^d,$(if $(filter !:P2,$(word 1,$(call ^u,$a))),,$(call ~lambda-error,S,$(call ^u,$a),$2,ARGNAME)))))),$(call ~c0-lambda,$1,$(wordlist 3,99999999,$(call ^n,1,$3)),$(wordlist 2,99999999,$3))),$(call ~lambda-error,L,$(call ^n,1,$3),$2,(ARGNAME...)))
~c0-check-body = $(if $3,$(if $(if $2,,1),$(call ~gen-error,$1,no BODY supplied to (define FORM BODY))),$(if $2,$(call ~gen-error,$2,too many arguments to (declare ...))))
~il-errors = $(if $(filter !:P8,$(word 1,$1)),$(call ^d,$1),$(if $(filter !:IL2 !:IL3,$(word 1,$1)),$(filter %,$(foreach node,$(wordlist 3,99999999,$1),$(call ~il-errors,$(call ^u,$(node))))),$(if $(filter !:IL5 !:IL6 !:IL7,$(word 1,$1)),$(filter %,$(foreach node,$(wordlist 2,99999999,$1),$(call ~il-errors,$(call ^u,$(node))))),$(if $(filter !:IL8,$(word 1,$1)),$(call ~il-errors,$(call ^n,2,$1))))))
~il-error-node = $(call ^Y,$(call ~il-errors,$1),,,,,,,,,$`(if $`1,$`(if $`(word 2,$`1),!:IL7 $`1,$`(call ^n,1,$`1))))
~check-name = $(if $(filter $1,$(~builtin-names)),$(call ~gen-error,$2,cannot redefine built-in function %q,$1),$(if $(filter @ : < ? ^ + | *,$(subst %,:,$1)),$(call ~gen-error,$2,cannot redefine automatic variable '$`%s',$1)))
~c0-def-symbol = $(or $(call ~c0-check-body,$2,$(call ^n,1,$5),$6),$(if $(if $7,,1),$(call ~check-name,$3,$2)),$(call ^Y,$(call ~c0-block,$5,$1),$(if $(filter &public,$4),x,p),$(call ~gen-native-name,$3,$4),$(call ~current-depth,$1),$6,$7,,,,$`(or $`(call ~il-error-node,$`1),!:IL11 $`(call ^d,$`(call ^k,$(call ^E,$3))!=$`(call ^d,$`(if $`6,!:EDefn2 $`(call ^d,$`4) $`2 $`1,!:EDefn0 $`(call ^d,$`3) $`2))) $`(and $`5,$`(if $`6,,1),!:IL3 ^set $`(call ^d,!:IL0 $`(call ^d,$`3)) $`(call ^d,$`1)))))
~get-argc = $(if $(filter ...% ?%,$(lastword $1)),$(if $(filter ...%,$(lastword $1)),$(words $(filter-out ...% ?%,$1)) or more,$(call ~get-argc,$(call ~butlast,$1)) or $(words $1)),$(words $1))
~c0-def-compound = $(or $(call ~c0-check-body,$2,$(call ^n,1,$6),$7),$(if $8,$(call ^n,1,$(filter-out !.,$(foreach a,$4,$(call ^d,$(if $(filter ...%,$(call ~symbol-name,$(call ^u,$a))),$(call ~gen-error,$(call ^u,$a),macros cannot have rest (...) parameters)))))),$(call ~check-name,$3,$2)),$(call ^Y,$(call ~c0-lambda,$(if $8,$1,$(call ~append,$(call ^k,$3)!=$(call ^d,!:EDefn1 $(call ^d,$(call ~gen-native-name,$3,$5)) $(if $(filter &public,$5),x,p) $(call ^d,$(call ~get-argc,$(foreach a,$4,$(call ^d,$(call ~symbol-name,$(call ^u,$a)))))) ),$1)),$4,$6),$(call ~current-depth,$1),$7,$8,$(call ~get-argc,$(foreach a,$4,$(call ^d,$(call ~symbol-name,$(call ^u,$a))))),$(if $(filter &public,$5),x,p),$3,$(if $8,:,$(call ~gen-native-name,$3,$5)),,$`(or $`(call ~il-error-node,$`1),!:IL11 $`(call ^d,$`(call ^k,$`7)!=$`(call ^d,!:EDefn1 $`(call ^d,$`8) $`6 $`(call ^d,$`5) $`(if $`4,$`(call ~cons,$`2,$`(if $`(filter !:IL8,$`(word 1,$`1)),$`(call ^n,2,$`1)))))) $`(and $`3,$`(if $`4,,1),!:IL3 ^fset $`(call ^d,!:IL0 $`(call ^d,$`8)) $`(call ^d,$`1)))))
~c0-def2 = $(or $(if $(if $7,,1),$(if $(filter !:P5,$(word 1,$3)),$(call ~c0-def2,$1,$(word 2,$3),$(wordlist 3,99999999,$3),$4,$5,$6,1))),$(if $(filter !:P2,$(word 1,$3)),$(call ~c0-def-symbol,$1,$(word 2,$3),$(call ^n,3,$3),$4,$5,$6,$7),$(if $(filter !:P0,$(word 1,$3)),$(if $(filter !:P2,$(word 1,$(call ^n,1,$(wordlist 3,99999999,$3)))),$(call ~c0-def-compound,$1,$(word 2,$3),$(call ^n,3,$(call ^n,1,$(wordlist 3,99999999,$3))),$(wordlist 2,99999999,$(wordlist 3,99999999,$3)),$4,$5,$6,$7),$(call ~err-expected,S,$(call ^n,1,$(wordlist 3,99999999,$3)),$3,NAME,(%s %s(NAME...)),$(if $6,define,declare),$(if $7,`))),$(call ~err-expected,L S,$3,$2,FORM,(%s %sFORM ...),$(if $6,define,declare),$(if $7,`)))))
~ml.special-define = $(call ~c0-def2,$1,$(call ~form-index,$2),$(call ^n,1,$3),$(call ~get-flags,$3,1),$(call ~skip-flags,$3,1),1,)
~ml.special-declare = $(call ~c0-def2,$1,$(call ~form-index,$2),$(call ^n,1,$3),$(call ~get-flags,$3,1),$(call ~skip-flags,$3,1),,)
$(call ^at,!1:Mod0!=ModSuccess!0S!0S !1:Mod1!=ModError!0S)
~ml.special-require = $(or $(if $(call ~skip-flags,$3,1),$(call ~gen-error,$(call ^n,1,$(call ~skip-flags,$3,1)),too many arguments to require)),$(if $(filter !:P1,$(word 1,$(call ^n,1,$3))),$(call ^Y,$(call ~get-module,$(call ^n,3,$(call ^n,1,$3)),$(~*compile-file*),$(filter &private,$(call ~get-flags,$3,1))),$(call ^n,1,$3),,,,,,,,$`(if $`(filter !:Mod1,$`(word 1,$`1)),$`(call ~gen-error,$`2,require: %s,$`(call ^n,2,$`1)),$`(if $`(filter !:Mod0,$`(word 1,$`1)),!:IL11 $`(call ^d,$`(call ^n,3,$`1)) !:IL3 ^R $`(call ^d,!:IL6 $`(call ^d,!:IL0 $`(call ^d,$`(call ^n,2,$`1))) $`(call ^d,!:IL10 require $`(call ^d,$`(call ^n,2,$`1))))))),$(call ~err-expected,Q,$(call ^n,1,$3),$2,STRING,(require STRING))))
~c0-block-cc = $(if $(filter !:IL11,$(word 1,$5)),$(call ~c0-block-cc,$(call ~append,$(call ^n,2,$5),$1),$2,$3,$4,$(wordlist 3,99999999,$5)),$(if $2,$(call ~c0-block-cc,$1,$(wordlist 2,99999999,$2),$3,$4$(if $5, $(call ^d,$5)),$(call ~c0,$(call ^n,1,$2),$1)),$(call ^Y,$1,$(filter-out !:IL0 !.,$4$(if $5, $(call ^d,$5))),,,,,,,,$3)))
~c0-block = $(call ~c0-block-cc,$2,$1,$`(if $`(word 2,$`2),!:IL7 $`2,$`(or $`(call ^n,1,$`2),!:IL0 !.)))
~ml.special-begin = $(call ~c0-block,$3,$1)
~c0-dict-key = $(call ^Y,$(call ~il-demote,$(call ~c0,$1,$2)),,,,,,,,,$`(or $`(if $`(filter !:IL3,$`(word 1,$`1)),$`(if $`(call ~eq?,$`(word 2,$`1),^d),!:IL3 ^k $`(wordlist 3,99999999,$`1))),$`(call ~il-subst,%,!8,$`1)))
~c0-D = $(call ~il-concat,$(call ~intersperse,!:IL0 !0,$(foreach pair,$3,$(call ^d,$(call ~il-concat,$(call ^d,$(if $(filter !:P2,$(word 1,$(call ~dict-key,$(pair)))),$(if $(filter =%,$(call ^n,3,$(call ~dict-key,$(pair)))),$(call ~c0-dict-key,!:P2 $(word 2,$(call ~dict-key,$(pair))) $(call ^d,$(patsubst =%,%,$(call ^n,3,$(call ~dict-key,$(pair))))),$1),!:IL0 $(call ^d,$(call ^d,$(call ^n,3,$(call ~dict-key,$(pair)))))),$(call ~c0-dict-key,$(call ~dict-key,$(pair)),$1))) $(call ^d,!:IL0 !1=) $(call ^d,$(call ~il-demote,$(call ~c0,$(call ^n,2,$(subst !=, ,$(pair))),$1))))))))
~c0-qq-form = $(if $(findstring *!*,$1),$(call ~il-concat,$(call ~intersperse,$2,$(foreach a,$(call ~split,*!*,$1),$(call ^d,!:IL0 $a)))),$(if $(findstring *!1*,$1),$(call ~il-concat,$(call ~intersperse,$(call ~il-demote,$2),$(foreach a,$(call ~split,*!1*,$1),$(call ^d,!:IL0 $a)))),!:P8 0 $(call ^d,c0-qq-form: template='$1')))
~c0-qq = $(if $(filter !:P6,$(word 1,$2)),$(if $3,$(call ~c0-qq-form,!:P6 $(word 2,$2) *!*,$(call ~c0-qq,$1,$(wordlist 3,99999999,$2),$(wordlist 2,99999999,$3))),$(call ~c0,$(wordlist 3,99999999,$2),$1)),$(if $(filter !:P5,$(word 1,$2)),$(call ~c0-qq-form,!:P5 $(word 2,$2) *!*,$(call ~c0-qq,$1,$(wordlist 3,99999999,$2),$(call ~cons,1,$3))),$(if $(filter !:P0,$(word 1,$2)),$(call ~c0-qq-form,!:P0 $(word 2,$2) *!*,$(call ~il-concat,$(call ~intersperse,!:IL0 !0,$(foreach c,$(wordlist 3,99999999,$2),$(call ^d,$(if $(filter !:P7,$(word 1,$(call ^u,$c))),$(call ~c0,$(wordlist 3,99999999,$(call ^u,$c)),$1),$(call ~il-demote,$(call ~c0-qq,$1,$(call ^u,$c),$3)))))))),$(if $(filter !:P8,$(word 1,$2)),$2,!:IL0 $(call ^d,$2)))))
~c0-error = $(call ~gen-error,$1,$(if $(filter !:P6,$(word 1,$1)),unquote (,) outside of a quasiquoted (`) form,$(if $(filter !:P7,$(word 1,$1)),splice (,@) outside of a quasiquoted (`) form,bad AST node: %q)),$1)
~c0 = $(if $(filter !:P2,$(word 1,$1)),$(call ~c0-S,$2,$1,$(call ^n,3,$1),$(call ~resolve,$1,$2)),$(if $(filter !:P1,$(word 1,$1)),!:IL0 $(call ^d,$(call ^n,3,$1)),$(if $(filter !:P0,$(word 1,$1)),$(call ~c0-L,$2,$(word 2,$1),$(call ^n,1,$(wordlist 3,99999999,$1)),$(wordlist 2,99999999,$(wordlist 3,99999999,$1)),$(call ~resolve,$(call ^n,1,$(wordlist 3,99999999,$1)),$2)),$(if $(filter !:P3,$(word 1,$1)),$(call ~c0-D,$2,$(word 2,$1),$(wordlist 3,99999999,$1)),$(if $(filter !:P4,$(word 1,$1)),!:IL0 $(call ^d,$(wordlist 3,99999999,$1)),$(if $(filter !:P5,$(word 1,$1)),$(call ~c0-qq,$2,$(wordlist 3,99999999,$1)),$(if $(filter !:P8,$(word 1,$1)),$1,$(call ~c0-error,$1))))))))
~gen0 = $(call ~c0-block-cc,$2,$1,$`(call ~cons,$`1,$`2))

endef

define [mod-gen1]
# Requires: core escape parse gen
# Exports: gen1}2
$(call ^R,core)
$(call ^R,escape)
$(call ^R,parse)
$(call ^R,gen)
~c1-Where = $(subst $`,$``,$(~*compile-file*)$(if $1,:$(call ~get-subject-line,$1,$(~*compile-subject*))))
~c1-Lambda = $(subst $``.,$`.,$(subst $``-,$`,$(subst $`,$``,$1)))
define ~crumb
$`.{$(subst 
,~N,$(subst $`,~S,$(subst $],~R,$(subst $(if ,,,),~C,$(subst $[,~L,$(subst ~,~1,$(call ^k,$1)!=$(call ^d,$2)))))))$`.}
endef
~c1-arg = $(if $(if $(filter !:IL3 !:IL1 !:IL2 !:IL5 !:IL4,$(word 1,$1)),1),$(call ~c1,$1),$(call ~protect-arg,$(call ~c1,$1)))
~c1-arg-trim = $(if $(if $(filter !:IL3 !:IL1 !:IL2 !:IL5 !:IL4,$(word 1,$1)),1),$(call ~c1,$1),$(call ~protect-trim,$(call ~protect-arg,$(call ~c1,$1))))
~c1-vec = $(subst |1,|,$(subst |0, ,$(subst $  ,$(subst |,|1,$2),$(foreach a,$1,$(subst $  ,|0,$(subst |,|1,$(call $3,$(call ^u,$a))))))))
~c1-Error = $(call ~crumb,errors,$(if $(filter !:P8,$(word 1,$1)),$1,!:P8 0 $(call ^d,internal:bad IL: $1)))
~il-vector = $(call ~il-concat,$(subst $  , $(call ^d,!:IL0 !0) ,$(foreach n,$1,$(call ^d,$(call ~il-demote,$(call ^u,$n))))))
~c1-Builtin = $`($1 $(call ~protect-ltrim,$(call ~c1-vec,$2,$(if ,,,),$(if $(filter and or,$1),~c1-arg-trim,~c1-arg))))
~c1-args9 = $(if $(word 9,$1),$(if ,,$(call ~c1-vec,$(wordlist 1,8,$1),$(if ,,,),~c1-arg),$(call ~protect-arg,$(call ~c1,$(call ~il-vector,$(wordlist 9,99999999,$1))))),$(call ~c1-vec,$1,$(if ,,,),~c1-arg))
~c1-Call = $`(call $(call ~protect-ltrim,$(subst $`,$``,$1))$(if $2,$(if ,,,))$(call ~c1-args9,$2))
~make-list = $(if $(word $2,$3),$(subst $  ,,$(wordlist $1,$2,$3)),$(call ~make-list,$1,$2,$3 $3 $3))
~c1-Local = $(if $(filter-out 0,$2),$(subst $(if ,,,$]),$],$(subst -,$(call ~make-list,1,$2,-),$`-(call ^E,$`-$1,$(call ~make-list,2,$2,`)))),$`$1)
~c1-Funcall = $`(call ^Y,$(call ~c1-args9,$(wordlist 2,99999999,$1))$(subst $  ,,$(or $(wordlist $(words x$(wordlist 2,99999999,$1)),9,$(if ,,, , , , , , , , ,)),$(if ,,,)))$(call ~protect-arg,$(call ~c1,$(call ^n,1,$1))))
~c1-Block = $(if $(word 2,$1),$`(and $(call ~c1-vec,$1,$(if ,,1,),~c1-arg)),$(if $1,$(call ~c1,$(call ^n,1,$1))))
~c1-Var = $`$(or $(filter a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z _,$1),($(subst $`,$``,$1)))
~c1 = $(if $(filter !:IL0,$(word 1,$1)),$(subst $`,$``,$(call ^n,2,$1)),$(if $(filter !:IL4,$(word 1,$1)),$(call ~c1-Local,$(word 2,$1),$(word 3,$1)),$(if $(filter !:IL3,$(word 1,$1)),$(call ~c1-Call,$(word 2,$1),$(wordlist 3,99999999,$1)),$(if $(filter !:IL1,$(word 1,$1)),$(call ~c1-Var,$(word 2,$1)),$(if $(filter !:IL6,$(word 1,$1)),$(call ~c1-vec,$(wordlist 2,99999999,$1),,~c1),$(if $(filter !:IL8,$(word 1,$1)),$(call ~c1-Lambda,$(call ~c1,$(call ^n,2,$1))),$(if $(filter !:IL7,$(word 1,$1)),$(call ~c1-Block,$(wordlist 2,99999999,$1)),$(if $(filter !:IL5,$(word 1,$1)),$(call ~c1-Funcall,$(wordlist 2,99999999,$1)),$(if $(filter !:IL2,$(word 1,$1)),$(call ~c1-Builtin,$(word 2,$1),$(wordlist 3,99999999,$1)),$(if $(filter !:IL9,$(word 1,$1)),$(call ~c1-Where,$(word 2,$1)),$(if $(filter !:IL10,$(word 1,$1)),$(call ~crumb,$(word 2,$1),$(call ^n,3,$1)),$(if $(filter !:IL11,$(word 1,$1)),$(call ~c1,$(wordlist 3,99999999,$1)),$(call ~c1-Error,$1)))))))))))))
define ~c1-file-set
$(call ~protect-lhs,$1) := $(call ~protect-rhs,$2)

endef
define ~c1-file-fset
$(if $(or $(findstring $`,$(subst $``,,$2)),$(findstring $``.,$2)),$`(call ^fset,$(call ~protect-arg,$1),$(call ~protect-arg,$2))
,$(if $(or $(findstring #,$2),$(findstring 
,$2),$(filter ~%,$(subst $  ,~,$(subst $ 	,~,$2)))),define $(call ~protect-lhs,$1)
$(call ~protect-define,$(subst $``,$`,$2))
$ endef
,$(call ~protect-lhs,$1) = $(subst $``,$`,$(call ~protect-rhs,$2))
))
endef
~c1-file* = $(subst |1,|,$(subst |0, ,$(subst $  ,,$(foreach node,$1,$(subst $  ,|0,$(subst |,|1,$(call ~c1-file,$(call ^u,$(node)))))))))
define ~c1-file
$(or $(if $(filter !:IL2,$(word 1,$1)),$(if $(filter !:IL0,$(word 1,$(call ^n,1,$(wordlist 3,99999999,$1)))),$(if $(filter eval,$(word 2,$1)),$(call ^n,2,$(call ^n,1,$(wordlist 3,99999999,$1)))
,$(if $(filter call,$(word 2,$1)),$(call ~c1-file,!:IL3 $(call ^n,2,$(call ^n,1,$(wordlist 3,99999999,$1))) $(wordlist 2,99999999,$(wordlist 3,99999999,$1)))))),$(if $(filter !:IL3,$(word 1,$1)),$(if $(if $(filter-out $(call ^d,!:IL0 !.),$(word 3,$(wordlist 3,99999999,$1))),,1),$(if $(filter ^set,$(word 2,$1)),$(call ~c1-file-set,$(call ~c1,$(call ^n,1,$(wordlist 3,99999999,$1))),$(call ~c1,$(call ^n,2,$(wordlist 3,99999999,$1)))),$(if $(filter ^fset,$(word 2,$1)),$(call ~c1-file-fset,$(call ~c1,$(call ^n,1,$(wordlist 3,99999999,$1))),$(call ~c1,$(call ^n,2,$(wordlist 3,99999999,$1))))))),$(if $(filter !:IL7,$(word 1,$1)),$(call ~c1-file*,$(wordlist 2,99999999,$1))))),$(if ,,$(call ~protect-expr,$(call ~c1,$(if $(if $(filter !:IL2 !:IL3,$(word 1,$1)),$(filter error eval info ^R ^at,$(word 2,$1)),$(if $(filter !:IL10,$(word 1,$1)),1)),$1,!:IL2 if $(call ^d,$1) $(call ^d,!:IL0 !.))))
))
endef
define ~gen1
$(call ^Y,$(subst $`.}, ,$(subst $`.{, $`.{,$(call ^d,$(if $2,$(call ~c1-file*,$1),$(call ~c1,!:IL7 $1))))),,,,,,,,,$`(call ~append,code!=$`(call ^d,$`(call ~concat-vec,$`(filter-out $``.{%,$`1))),$`(call ~dict-collate,$`(foreach w,$`(call ~filtersub,$``.{%,%,$`1),$`(subst ~1,~,$`(subst ~L,$`[,$`(subst ~C,$`(if ,,,),$`(subst ~R,$`],$`(subst ~S,$``,$`(subst ~N,
,$`(call ^u,$`w)))))))))))
endef

endef

define [mod-memo]
# Requires: core io string
# Exports: memo-chmod-file"memo-write-file"memo-read-file#memo-hash-file#memo-on(3;~memo-minus[:IL2'if',:IL1\0~*%*',|\0,.',:IL7\0,1:IL3,0~memo-start-session,0,11@,101,100\0,1|,01[@'2'0 memo-blob-call}1'or'more memo-call}1'or'more memo-apply"memo-io}1'or'more memo-drop}0
$(call ^R,core)
$(call ^R,io)
$(call ^R,string)
~*memo-on* := 
~*memo-cache* := 
~*memo-db* := 
~*memo-db-file* := 
~*memo-db-disk* := 
~*memo-key* := 
~*memo-tag* := 
~*memo-log* := 
~*memo-hashes* := 
$(call ^at,!1:PMDB0!=Result!0S !1:PMDB1!=IO!0S!0S!0L)
~memo-playback = $(call ^Y,$(call ~dict-get,$1,$(~*memo-cache*) $(~*memo-db*)),,,,,,,,,$`(if $`(filter !:PMDB0,$`(word 1,$`1)),$`1,$`(if $`(filter !:PMDB1,$`(word 1,$`1)),$`(call ~memo-playback,$`(call ^d,$`(call ^n,2,$`1)) $`(call ^d,$`(if $`(filter :%,$`(call ^n,3,$`1)),$`(call ~memo-do-apply,$`(patsubst :%,%,$`(call ^n,3,$`1)),$`(wordlist 4,99999999,$`1)),$`(call ^na,$`(call ^n,3,$`1),$`(wordlist 4,99999999,$`1))))),)))
~memo-add-entry = $(call ^set,~*memo-log*,$(call ~append,$(~*memo-log*),$(call ^k,$(~*memo-key*))!=$(call ^d,$1)))
~memo-record = $(call ^set,~*memo-key*,$(call ^set,~*memo-key*,$1,$(~*memo-key*)),$(call ^set,~*memo-log*,$(call ^set,~*memo-log*,,$(~*memo-log*)),$(call ^Y,$(call ^na,$2,$3),$1,,,,,,,,$`(and $`(if $`(~*memo-key*),$`(and $`(call ~memo-add-entry,!:PMDB0 $`(call ^d,$`1))1,$`(call ^set,~*memo-db*,$`(call ~append,$`(~*memo-db*),$`(~*memo-log*)))))1,$`1))))
~memo-drop = $(and $(call ^set,~*memo-key*,)1,$(call ~memo-save-session))
~get-io-tag = $(if $1,$(and $(call ~expect-x,$1,!:PMDB1 $(call ^d,$(if $(filter !:PMDB1,$(word 1,$1)),$(call ^n,2,$1))) $(call ^d,$2) $3,memo.scm:109)1,$(if $(filter !:PMDB1,$(word 1,$1)),$(call ^n,2,$1))))
~memo-log-io = $(and $(if $(~*memo-key*),$(call ^set,~*memo-key*,$(call ^d,$(or $(call ~get-io-tag,$(call ~dict-get,$(~*memo-key*),$(~*memo-db*)),$1,$2),$(and $(call ~memo-add-entry,!:PMDB1 $(call ^d,$(~*memo-tag*)) $(call ^d,$1) $2)1,$(call ^set,~*memo-tag*,$(call ~1+,$(~*memo-tag*)),$(~*memo-tag*))))) $(call ^d,$3)))1,$3)
~memo-io = $(call ~memo-log-io,$1,$(foreach N,2,$(^v)),$(call ^na,$1,$(foreach N,2,$(^v))))
~memo-do-apply = $(call ^Y,$(call ~dict-find,$1 $2,$(~*memo-cache*)),$1,$2,,,,,,,$`(if $`1,$`(call ^n,2,$`(subst !=, ,$`1)),$`(call ^Y,$`(call ^Y,$`(call ~memo-playback,$`2 $`3),$`2,$`3,,,,,,,$``(if $``(filter !:PMDB0,$``(word 1,$``1)),$``(call ^n,2,$``1),$``(call ~memo-record,$``2 $``3,$``2,$``3))),$`2 $`3,,,,,,,,$``(and $``(call ^set,~*memo-cache*,$``(call ~append,$``(call ^k,$``2)!=$``(call ^d,$``1),$``(~*memo-cache*)))1,$``1))))
~memo-apply = $(and $(call ~assert-x,$(~*memo-on*),memo.scm:163)1,$(call ~memo-log-io,:$1,$2,$(call ~memo-do-apply,$1,$2)))
~memo-call = $(call ~memo-apply,$1,$(foreach N,2,$(^v)))
~blobify = $(call ~save-blob,$(dir $(~*memo-db-file*)),$(call ^na,$1,$(foreach N,2,$(^v))))
~read-blob = $(call ~read-file,$1)
$(if $(call ~memoize,~read-blob),)
~memo-blob-call = $(if $(~*memo-on*),$(call ~read-blob,$(call ~memo-apply,~blobify,$(call ~cons,$1,$(foreach N,2,$(^v))))),$(call ^na,$1,$(foreach N,2,$(^v))))
define ~memo-save-session
$(if $(if $(call ~eq?,$(~*memo-db*),$(~*memo-db-disk*)),,1),$(and $(call ~expect-x,,$(call ~write-file,$(~*memo-db-file*),$(~*memo-tag*)
$(subst !0, ,$(subst $  ,
,$(subst 
,!n,$(~*memo-db*))))
),memo.scm:229)1,$(call ^set,~*memo-db-disk*,$(~*memo-db*))))
endef
define ~memo-start-session
$(and $(call ^set,~*memo-on*,1)1,$(if $(if $(call ~eq?,$(~*memo-db-file*),$1),,1),$(and $(call ~mkdir-p,$(dir $1))1,$(and $(call ^set,~*memo-db-file*,$1)1,$(call ^set,~*memo-db*,$(filter %,$(subst !n,
,$(subst 
, ,$(subst $  ,!0,$(call ~read-file,$1))))))1,$(call ^set,~*memo-tag*,$(or $(word 1,$(~*memo-db*)),0))1,$(call ^set,~*memo-db*,$(wordlist 2,99999999,$(~*memo-db*)))1,$(call ^set,~*memo-db-disk*,$(~*memo-db*))))))
endef
~memo-minus = $(and $(if $1,$(and $(call ^set,~*memo-on*,)1,$(call ^set,~*memo-cache*,)1,$(call ^set,~*memo-hashes*,)1,$(call ~memo-save-session)))1,$2)
~hash-add = $(call ^set,~*memo-hashes*,$(call ~append,$(~*memo-hashes*),$1))
~do-hash-file = $(if $(~*memo-on*),$(call ^n,2,$(subst !=, ,$(or $(call ~dict-find,$1,$(~*memo-hashes*)),$(and $(call ~hash-add,$(call ~hash-files,$(sort $(call ~cons,$1,$(if $(~*memo-hashes*),,$(foreach pair,$(~*memo-db*),$(if $(filter !:PMDB1,$(word 1,$(call ^n,2,$(subst !=, ,$(pair))))),$(if $(filter $(call ^n,3,$(call ^n,2,$(subst !=, ,$(pair)))),~do-hash-file ~do-write-blob),$(word 1,$(wordlist 4,99999999,$(call ^n,2,$(subst !=, ,$(pair)))))))))))))1,$(call ~dict-find,$1,$(~*memo-hashes*)))))),$(call ~hash-file,$1))
~memo-hash-file = $(call ~memo-io,~do-hash-file,$1)
~memo-read-file = $(and $(call ~memo-hash-file,$1)1,$(call ~read-file,$1))
~do-write-blob = $(if $(if $(call ~eq?,$(notdir $2),$(call ~dict-get,$1,$(~*memo-hashes*))),,1),$(and $(call ^set,~*memo-hashes*,$(call ~dict-remove,$1,$(~*memo-hashes*)))1,$(call ~cp-file,$2,$1,1)))
~memo-write-file = $(if $(~*memo-on*),$(call ^Y,$(call ~save-blob,$(dir $(~*memo-db-file*)),$2),,,,,,,,,$`(call ~memo-io,~do-write-blob,$(call ^E,$1),$`1)),$(call ~write-file,$1,$2))
~memo-chmod-file = $(call ~memo-io,~chmod-file,$1,$2)

endef

define [mod-macros]
# Requires: core parse gen gen0
# Exports: 
$(call ^R,core)
$(call ^R,parse)
$(call ^R,gen)
$(call ^R,gen0)
~ml.special-when = $(or $(call ~check-argc,2 or more,$3,$2),!:IL2 if $(call ^d,$(call ~c0,$(call ^n,1,$3),$1)) $(call ^d,$(call ~c0-block,$(wordlist 2,99999999,$3),$1)))
~ml.special-print = !:IL2 info $(call ^d,!:IL6 $(call ~c0-vec,$3,$1))
~ml.special-current-env = !:IL0 $(call ^d,$1)
~ml.special-current-file = $(or $(call ~check-argc,0,$3,$2),$(if ,,!:IL9 ))
~ml.special-current-file-line = $(or $(call ~check-argc,0,$3,$2),!:IL9 $(call ~form-index,$2))
~ml.special-concat = $(call ~il-concat,$(call ~c0-vec,$3,$1))
~ml.special-vector = $(call ~il-concat,$(call ~intersperse,!:IL0 !0,$(foreach f,$3,$(call ^d,$(call ~il-demote,$(call ~c0,$(call ^u,$f),$1))))))
~subst-x = $(if $1,$(call ~subst-x,$(wordlist 3,99999999,$1),!:IL2 subst $(call ~conj,$(wordlist 1,2,$1),$2)),$2)
~ml.special-subst = $(if $(filter %2 %4 %6 %8 %0 1,$(words $3)),$(call ~gen-error,$2,$(if ,,(subst {FROM TO}+ STR) accepts 2n+1 arguments, not %s),$(words $3)),$(call ~subst-x,$(call ~c0-vec,$(call ~butlast,$3),$1),$(call ~c0,$(call ^u,$(lastword $3)),$1)))
~c0-set = $(call ^Y,$(call ~resolve,$2,$1),$2,$3,$4,$5,$6,$1,,,$`(if $`(filter !:P2,$`(word 1,$`2)),$`(if $`(filter !:EDefn0,$`(word 1,$`1)),!:IL3 ^set $`(call ~append,$`(call ^d,!:IL0 $`(call ^d,$`(call ^n,2,$`1))) $`(call ^d,$`3),$`(if $`4,$`(call ^d,$`4))),$`(if $`(filter !:EDefn1,$`(word 1,$`1)),!:IL3 ^fset $`(call ~append,$`(call ^d,!:IL0 $`(call ^d,$`(call ^n,2,$`1))) $`(call ^d,$`3),$`(if $`4,$`(call ^d,$`4))),$`(call ~gen-error,$`2,%q is not a global variable,$`(call ~symbol-name,$`2)))),$`(call ~err-expected,S,$`2,,$`5,$`6)))
~ml.special-set = $(or $(call ~check-argc,2 or 3,$3,$2),$(call ~c0-set,$1,$(call ^n,1,$3),$(call ~c0,$(call ^n,2,$3),$1),$(if $(call ^n,3,$3),$(call ~c0,$(call ^n,3,$3),$1)),NAME,(set NAME VALUE [RETVAL])))
~ml.special-? = $(call ^Y,$(call ~resolve,$(call ^n,1,$3),$1),$1,$2,$3,,,,,,$`(or $`(if $`(call ~eq?,-,$`1),$`(call ~err-expected,S,$`(call ^n,1,$(call ^E,$3)),$`3,FUNC,(? FUNC ARGS...)),$`(if $`(filter !:EDefn1,$`(word 1,$`1)),$`(if $`(if $`(call ~eq?,$`(call ^n,2,$`1),:),,1),$`(call ^Y,^t,$`(call ~cons,!:IL0 $`(call ^d,$`(call ^n,2,$`1)),$`(call ~c0-vec,$`(wordlist 2,99999999,$(call ^E,$3)),$`2)),,,,,,,,!:IL3 $``1 $``2)),$`(if $`(filter !:EDefn5,$`(word 1,$`1)),$`(call ^Y,^t,$`(call ~cons,!:IL0 $`(call ^d,$`(call ^n,2,$`1)),$`(call ~c0-vec,$`(wordlist 2,99999999,$(call ^E,$3)),$`2)),,,,,,,,!:IL2 $``1 $``2)))),$`(if $`1,$`(call ~gen-error,$`(call ^n,1,$(call ^E,$3)),FUNC in (? FUNC ...) is not traceable),$`(call ~gen-error,$`(call ^n,1,$(call ^E,$3)),undefined variable: %q,$`(call ~symbol-name,$`3)))))
~read-pairs-r = $(if $(if $1,,1),$3,$(if $(filter !:P0,$(word 1,$(call ^n,1,$1))),$(if $(filter !:P2,$(word 1,$(call ^n,1,$(wordlist 3,99999999,$(call ^n,1,$1))))),$(if $(call ^n,2,$(wordlist 3,99999999,$(call ^n,1,$1))),$(if $(if $(call ^n,3,$(wordlist 3,99999999,$(call ^n,1,$1))),,1),$(call ~read-pairs-r,$(wordlist 2,99999999,$1),$2,$(call ~conj,$3,$(wordlist 3,99999999,$(call ^n,1,$1)))),$(call ~gen-error,$(call ^n,3,$(wordlist 3,99999999,$(call ^n,1,$1))),extra form after value in %q,$2)),$(call ~err-expected,,$(call ^n,2,$(wordlist 3,99999999,$(call ^n,1,$1))),$(call ^n,1,$1),VALUE,$2)),$(call ~err-expected,S,$(call ^n,1,$(wordlist 3,99999999,$(call ^n,1,$1))),$(call ^n,1,$1),VAR,$2)),$(call ~err-expected,L,$(call ^n,1,$1),,(VAR VALUE),$2)))
~read-pairs = $(if $(filter !:P0,$(word 1,$1)),$(call ~read-pairs-r,$(wordlist 3,99999999,$1),$3,),$(call ~err-expected,L,$1,$2,((VAR VALUE)...),$3))
~let-where := (let ((VAR VALUE)...) BODY)
~ml.special-let = $(call ~c0,$(call ^Y,$(wordlist 2,99999999,$3),$(call ~read-pairs,$(call ^n,1,$3),$2,$(~let-where)),,,,,,,,$`(or $`(if $`(filter !:P8,$`(word 1,$`2)),$`2),!:P0 0 $`(call ~cons,!:P0 0 $`(call ~append,$`(call ^d,!:P2 0 lambda),$`(call ^d,!:P0 0 $`(foreach p,$`2,$`(call ^d,$`(call ^n,1,$`(call ^u,$`p))))),$`1),$`(foreach p,$`2,$`(call ^d,$`(call ^n,2,$`(call ^u,$`p))))))),$1)
~letg-where := (let-global ((VAR VALUE)...) BODY)
~letg-expand = $(or $(if $(filter !:P8,$(word 1,$4)),$4),$(if $(if $4,,1),$(call ~c0-block,$3,$1)),$(call ~c0-set,$1,$(call ^n,1,$(call ^n,1,$4)),$(call ~c0-set,$1,$(call ^n,1,$(call ^n,1,$4)),$(call ~c0,$(call ^n,2,$(call ^n,1,$4)),$1),$(call ~c0,$(call ^n,1,$(call ^n,1,$4)),$1),,),$(call ~letg-expand,$1,$(call ^n,1,$(call ^n,1,$4)),$3,$(wordlist 2,99999999,$4)),,))
~ml.special-let-global = $(call ~letg-expand,$1,$2,$(wordlist 2,99999999,$3),$(call ~read-pairs,$(call ^n,1,$3),$2,$(~letg-where)))
~let&-where := (let& ((VAR VALUE)...) BODY)
~let&-env = $(if $1,$(call ~let&-env,$(wordlist 2,99999999,$1),$(call ~append,$(if $(filter !:P2,$(word 1,$(call ^n,1,$(call ^n,1,$1)))),$(call ^k,$(call ^n,3,$(call ^n,1,$(call ^n,1,$1))))!=$(call ^d,!:EDefn2 $(call ^d,$3) - $(call ~c0,$(call ^n,2,$(call ^n,1,$1)),$2))),$2),$3),$2)
~ml.special-let& = $(call ^Y,$(wordlist 2,99999999,$3),$(call ~read-pairs,$(call ^n,1,$3),$2,$(~let&-where)),$1,,,,,,,$`(if $`(filter !:P8,$`(word 1,$`2)),$`2,$`(call ~c0-block,$`1,$`(call ~let&-env,$`2,$`3,$`(call ~current-depth,$`3)))))
~c0-for = $(if $(filter !:P2,$(word 1,$(call ^n,1,$3))),$(if $(wordlist $(words $(wordlist 2,99999999,$4)),99999999,$3),!:IL2 foreach $(call ^d,!:IL0 $(call ^d,$(call ^n,3,$(call ^n,1,$3)))) $(call ^d,$(call ~c0,$(call ^n,2,$3),$1)) $(call ^d,$(call ^Y,$(call ~c0-block,$(wordlist $(words $(wordlist 2,99999999,$4)),99999999,$3),$(call ~append,$(call ^k,$(call ^n,3,$(call ^n,1,$3)))!=$(call ^d,!:EDefn2 !. - $(call ^Y,!:IL1 $(call ^n,3,$(call ^n,1,$3)),,,,,,,,,$5)),$1)),,,,,,,,,$6)),$(call ~err-expected,,,$2,$(word $(words . . $3),$(subst $],,$4)),$4)),$(call ~err-expected,S,$(call ^n,1,$3),$2,VAR,$4))
~ml.special-foreach = $(call ~c0-for,$1,$2,$3,(foreach VAR LIST BODY),$`1,$`1)
~ml.special-for = $(call ~c0-for,$1,$2,$3,(for VAR VEC BODY),$(value ~il-promote),$(value ~il-demote))
~ml.special-append-for = !:IL2 filter $(call ^d,!:IL0 %) $(call ^d,$(call ~c0-for,$1,$2,$3,(append-for VAR VEC BODY),$(value ~il-promote),$`1))
~concat-for-where := (concat-for VAR VEC DELIM BODY)
~il-spc-encode = $(call ~il-subst, ,|0,$(call ~il-subst,|,|1,$1))
~il-spc-decode = $(call ~il-subst,|1,|,$(call ~il-subst,|0, ,$1))
~ml.special-concat-for = $(or $(if $(filter !:P1,$(word 1,$(call ^n,3,$3))),$(if $(call ~eq?,$(call ^n,3,$(call ^n,3,$3)), ),$(call ~c0-for,$1,$2,$3,$(~concat-for-where),$(value ~il-promote),$`1))),$(call ~il-spc-decode,!:IL2 subst $(call ^d,!:IL0 !0) $(call ^d,$(call ~il-subst,|,|1,$(call ~c0,$(call ^n,3,$3),$1))) $(call ^d,$(call ~c0-for,$1,$2,$3,$(~concat-for-where),$(value ~il-promote),$(value ~il-spc-encode)))))
~cond-where := (cond (TEST BODY)...)
~begin-block = $(if $(filter 1,$(words $1)),$(call ^n,1,$1),!:P0 0 $(call ~cons,!:P2 0 begin,$1))
~cond-wrap = $(if $(filter !:P0,$(word 1,$1)),$(if $(wordlist 2,99999999,$(wordlist 3,99999999,$1)),$(if $(if $(filter !:P2,$(word 1,$(call ^n,1,$(wordlist 3,99999999,$1)))),$(call ~eq?,$(call ^n,3,$(call ^n,1,$(wordlist 3,99999999,$1))),else)),$(if $(if $2,,1),$(call ~begin-block,$(wordlist 2,99999999,$(wordlist 3,99999999,$1))),$(call ~gen-error,$(call ^n,1,$(wordlist 3,99999999,$1)),(else ...) is followed by additional clauses)),!:P0 0 $(call ~append,$(call ^d,!:P2 0 if) $(call ^d,$(call ^n,1,$(wordlist 3,99999999,$1))) $(call ^d,$(call ~begin-block,$(wordlist 2,99999999,$(wordlist 3,99999999,$1)))),$(if $2,$(call ^d,$2)))),$(if $(call ^n,1,$(wordlist 3,99999999,$1)),$(call ~err-expected,,,$1,BODY,$(~cond-where)),$(call ~err-expected,,,$1,TEST,$(~cond-where)))),$(call ~err-expected,L,$1,,(TEST BODY),$(~cond-where)))
~ml.special-cond = $(call ~c0,$(call ~foldr,$(value ~cond-wrap),,$3),$1)
~defn-native-name = $(if $(filter !:EDefn1 !:EDefn0,$(word 1,$1)),$(call ^n,2,$1))
~ml.special-native-name = $(or $(call ~check-argc,1,$3,$2),$(if $(filter !:P2,$(word 1,$(call ^n,1,$3))),$(call ^Y,$(call ~defn-native-name,$(call ~resolve,$(call ^n,1,$3),$1)),$(call ^n,3,$(call ^n,1,$3)),,,,,,,,$`(if $`1,!:IL0 $`(call ^d,$`1),$`(call ~gen-error,$`(call ^n,1,$(call ^E,$3)),%q is not a global variable,$`2))),$(call ~err-expected,S,$(call ^n,1,$3),$2,NAME,(native-name NAME))))
~defmacro-where := (defmacro (NAME ARG...) BODY)
~ml.special-defmacro = $(if $(filter !:P0,$(word 1,$(call ^n,1,$3))),$(if $(filter !:P2,$(word 1,$(call ^n,1,$(wordlist 3,99999999,$(call ^n,1,$3))))),$(call ^Y,$(call ~c0,!:P0 0 $(call ~cons,!:P2 0 define,$3),$1),$(call ^k,$(call ^n,3,$(call ^n,1,$(wordlist 3,99999999,$(call ^n,1,$3)))))!=$(call ^d,!:EDefn3 $(call ^d,$(call ~gen-native-name,$(call ^n,3,$(call ^n,1,$(wordlist 3,99999999,$(call ^n,1,$3)))),$1)) x),,,,,,,,!:IL11 $`(call ^d,$`2) $`(if $`(filter !:IL11,$`(word 1,$`1)),$`(wordlist 3,99999999,$`1),$`1)),$(call ~err-expected,S,$(call ^n,1,$(wordlist 3,99999999,$(call ^n,1,$3))),$2,NAME,$(~defmacro-where))),$(call ~err-expected,L,$(call ^n,1,$3),$2,(NAME ARG...),$(~defmacro-where)))
$(call ^at,!1:Data0!=DataType!0W!0W!0S!0L)
~data-where := (data NAME (CTOR ARG...)...)
~read-type-r = $(or $(if $(if $1,,1),$(if $6,$(call ~gen-error,$2,no argument following last flag: %s,$6),!:Data0 $3 $(call ^n,1,$4) $(call ^d,$(wordlist 2,99999999,$4)) $5)),$(if $(filter !:P2,$(word 1,$(call ^n,1,$1))),$(or $(if $(if $(filter &%,$(call ^n,3,$(call ^n,1,$1))),,1),$(call ~read-type-r,$(wordlist 2,99999999,$1),$2,$3,$4 $(if $(call ~eq?,&word,$6),W,$(if $(and $(call ~eq?,&list,$6),$(if $(word 2,$1),,1)),L,S)),$(call ~conj,$5,$(call ^n,3,$(call ^n,1,$1))),)),$(if $6,$(call ~gen-error,$(call ^n,1,$1),two type flags supplied for one argument)),$(if $(filter &list &word,$(call ^n,3,$(call ^n,1,$1))),$(call ~read-type-r,$(wordlist 2,99999999,$1),$2,$3,$4,$5,$(call ^n,3,$(call ^n,1,$1)))),$(call ~gen-error,$(call ^n,1,$1),$(if ,,unknown flag [supported: &list, &word]))),$(call ~err-expected,S,$(call ^n,1,$1),$2,ARG,$(~data-where))))
~read-type = $(if $(filter !:P0,$(word 1,$1)),$(if $(filter !:P2,$(word 1,$(call ^n,1,$(wordlist 3,99999999,$1)))),$(if $(filter !:P1,$(word 1,$(call ^n,2,$(wordlist 3,99999999,$1)))),$(call ~read-type-r,$(wordlist 3,99999999,$(wordlist 3,99999999,$1)),$1,$(call ^n,3,$(call ^n,2,$(wordlist 3,99999999,$1))),$(call ^n,3,$(call ^n,1,$(wordlist 3,99999999,$1))),,),$(call ~read-type-r,$(wordlist 2,99999999,$(wordlist 3,99999999,$1)),$1,$2,$(call ^n,3,$(call ^n,1,$(wordlist 3,99999999,$1))),,)),$(call ~err-expected,S,$(call ^n,1,$(wordlist 3,99999999,$1)),$3,CTOR,$(~data-where))),$(call ~err-expected,L,$1,$3,(CTOR ...),$(~data-where)))
~read-types = $(if $(filter !:P8,$(word 1,$5)),$5,$(if $(if $3,,1),$(call ~append,$6,$(if $5,$(call ^d,$5))),$(call ~read-types,$1,$2,$(wordlist 2,99999999,$3),$(call ~append,$4,1),$(call ~read-type,$(call ^n,1,$3),$2$(words $4),$1),$(call ~append,$6,$(if $5,$(call ^d,$5))))))
~ml.special-data = $(call ^Y,$(if $(filter !:P2,$(word 1,$(call ^n,1,$3))),$(call ~read-types,$2,!:$(call ^n,3,$(call ^n,1,$3)),$(call ~skip-flags,$3,1)),$(call ~err-expected,S,$(call ^n,1,$3),$2,NAME,$(~data-where))),$(if $(filter &public,$(call ~get-flags,$3,1)),x,p),,,,,,,,$`(or $`(if $`(filter !:P8,$`(word 1,$`1)),$`1),!:IL11 $`(call ^d,$`(filter %,$`(foreach ty,$`1,$`(if $`(filter !:Data0,$`(word 1,$`(call ^u,$`(ty)))),$`(call ^k,$`(word 3,$`(call ^u,$`(ty))))!=$`(call ^d,!:EDefn4 $`(call ^d,$`(call ^n,4,$`(call ^u,$`(ty)))) $`2 $`(call ^d,$`(word 2,$`(call ^u,$`(ty))))))))) !:IL3 ^at $`(call ^d,!:IL0 $`(call ^d,$`(filter %,$`(foreach ty,$`1,$`(if $`(filter !:Data0,$`(word 1,$`(call ^u,$`(ty)))),$`(call ^k,$`(word 2,$`(call ^u,$`(ty))))!=$`(call ^d,$`(call ~append,$`(word 3,$`(call ^u,$`(ty))),$`(call ^n,4,$`(call ^u,$`(ty))))))))))))
~case-where := (case VALUE (PATTERN BODY)...)
~arg-bindings = $(foreach n,$(call ~indices-a,$(words $2)),$(call ^k,$(call ~symbol-name,$(call ^n,$n,$1)))!=$(call ^d,!:EDefn2 $(call ^d,$4) - $(if $(call ~eq?,S,$(word $n,$2)),!:IL3 ^n $(call ^d,!:IL0 $(call ^d,$(call ~1+,$n))) $(call ^d,$3),$(if $(call ~eq?,W,$(word $n,$2)),!:IL2 word $(call ^d,!:IL0 $(call ^d,$(call ~1+,$n))) $(call ^d,$3),!:IL2 wordlist $(call ^d,!:IL0 $(call ^d,$(call ~1+,$n))) $(call ^d,!:IL0 99999999) $(call ^d,$3)))))
~c0-clauses = $(foreach c,$1,$(call ^d,$(if $(filter !:P0,$(word 1,$(call ^u,$c))),$(if $(filter !:P2,$(word 1,$(call ^n,1,$(wordlist 3,99999999,$(call ^u,$c))))),$(call ~c0-block,$(wordlist 2,99999999,$(wordlist 3,99999999,$(call ^u,$c))),$(call ~append,$(call ^k,$(call ^n,3,$(call ^n,1,$(wordlist 3,99999999,$(call ^u,$c)))))!=$(call ^d,!:EDefn2 $(call ^d,$(call ~current-depth,$3)) - $2),$3)),$(if $(filter !:P0,$(word 1,$(call ^n,1,$(wordlist 3,99999999,$(call ^u,$c))))),$(or $(call ^Y,$(call ~resolve,$(call ^n,1,$(wordlist 3,99999999,$(call ^n,1,$(wordlist 3,99999999,$(call ^u,$c))))),$3),$2,$(wordlist 2,99999999,$(wordlist 3,99999999,$(call ^n,1,$(wordlist 3,99999999,$(call ^u,$c))))),$(call ^n,1,$(wordlist 3,99999999,$(call ^n,1,$(wordlist 3,99999999,$(call ^u,$c))))),$(wordlist 2,99999999,$(wordlist 3,99999999,$(call ^u,$c))),,,,,$`(if $`(filter !:EDefn4,$`(word 1,$`1)),$`(or $`(call ~check-argc,$`(words $`(call ^n,2,$`1)),$`3,$`4),!:IL2 if $`(call ^d,!:IL2 filter $`(call ^d,!:IL0 $`(call ^d,$`(call ^n,4,$`1))) $`(call ^d,!:IL2 word $`(call ^d,!:IL0 1) $`(call ^d,$`2))) $`(call ^d,$`(call ~c0-block,$`5,$`(call ~append,$`(call ~arg-bindings,$`3,$`(call ^n,2,$`1),$`2,$`(call ~current-depth,$(call ^E,$3))),$(call ^E,$3))))))),$(if $(filter !:P2,$(word 1,$(call ^n,1,$(wordlist 3,99999999,$(call ^n,1,$(wordlist 3,99999999,$(call ^u,$c))))))),$(call ~gen-error,$(call ^n,1,$(wordlist 3,99999999,$(call ^n,1,$(wordlist 3,99999999,$(call ^u,$c))))),symbol %q does not identify a record type,$(call ^n,3,$(call ^n,1,$(wordlist 3,99999999,$(call ^n,1,$(wordlist 3,99999999,$(call ^u,$c))))))),$(call ~err-expected,S,$(call ^n,1,$(wordlist 3,99999999,$(call ^n,1,$(wordlist 3,99999999,$(call ^u,$c))))),$(call ^n,1,$(wordlist 3,99999999,$(call ^u,$c))),CTOR,$(~case-where)))),$(call ~err-expected,L S,$(call ^n,1,$(wordlist 3,99999999,$(call ^u,$c))),$(call ^u,$c),PATTERN,$(~case-where)))),$(call ~err-expected,L,$(call ^u,$c),,(PATTERN BODY),$(~case-where)))))
~case-append-arg = $(if $(filter !:IL2,$(word 1,$1)),!:IL2 $(word 2,$1) $(call ~conj,$(wordlist 3,99999999,$1),$2),$1)
~case-fold = $(if $(word 2,$1),$(call ~foldr,$(value ~case-append-arg),$(call ^u,$(lastword $1)),$(call ~butlast,$1)),$(call ^n,1,$1))
~clause-pvt = $(if $(filter !:IL2,$(word 1,$1)),$(if $(filter !:IL2,$(word 1,$(call ^n,1,$(wordlist 3,99999999,$1)))),$(call ^Y,$(wordlist 3,99999999,$1),$(wordlist 3,99999999,$(call ^n,1,$(wordlist 3,99999999,$1))),$(word 2,$1),$(word 2,$(call ^n,1,$(wordlist 3,99999999,$1))),,,,,,$`(and $`(filter if,$`3),$`(if $`(word 3,$`1),,1),$`(filter filter,$`4),$`(if $`(filter !:IL0,$`(word 1,$`(call ^n,1,$`2))),$`(call ^d,$`(call ^n,2,$`(call ^n,1,$`2))) $`(call ^d,$`(call ^n,2,$`2)) $`(call ^d,$`(call ^n,2,$`1)))))))
~clauses-merge-loop = $(if $2,$(call ^Y,$(call ~clause-pvt,$1),$(call ~clause-pvt,$(call ^n,1,$2)),$1,$(call ^n,1,$2),$(wordlist 2,99999999,$2),$3,,,,$`(if $`(and $`1,$`(call ~eq?,$`(wordlist 2,99999999,$`1),$`(wordlist 2,99999999,$`2))),$`(call ~clauses-merge-loop,!:IL2 if $`(call ^d,!:IL2 filter $`(call ^d,!:IL0 $`(call ^d,$`(call ^n,1,$`1) $`(call ^n,1,$`2))) $`(call ^d,$`(call ^n,2,$`1))) $`(call ^d,$`(call ^n,3,$`1)),$`5,$`6),$`(call ~clauses-merge-loop,$`4,$`5,$`(call ~conj,$`6,$`3)))),$(call ~conj,$3,$1))
~clauses-merge = $(if $1,$(call ~clauses-merge-loop,$(call ^n,1,$1),$(wordlist 2,99999999,$1),))
~ml.special-case = $(if $(call ^n,1,$3),$(call ^Y,$(call ~c0,$(call ^n,1,$3),$1),$3,$1,,,,,,,$`(if $`(filter !:P8,$`(word 1,$`1)),$`1,$`(call ~case-fold,$`(call ~clauses-merge,$`(call ~c0-clauses,$`(wordlist 2,99999999,$`2),$`1,$`3))))),$(call ~err-expected,,$(call ^n,1,$3),$2,VALUE,$(~case-where)))

endef

define [mod-utf8]
# Requires: core math
# Exports: utf8-decode#utf8-encode}1
$(call ^R,core)
$(call ^R,math)
~utf-seq = $(if $2,$(call ^Y,$(call ~binop,fdiv,$1,64),$(wordlist 2,99999999,$2),$(word 1,$2),,,,,,,$`(call ~append,$`(call ~utf-seq,$`1,$`2),$`(call ~binop,add,$`3,$`(call ~binop,sub,$(call ^E,$1),$`(call ~binop,mul,$`1,64))))))
~utf8-encode = $(foreach c,$1,$(if $(findstring 1,$(call ~math-cmp,128,$c)),$c,$(if $(findstring 1,$(call ~math-cmp,2048,$c)),$(call ~utf-seq,$c,128 192),$(if $(findstring 1,$(call ~math-cmp,65536,$c)),$(call ~utf-seq,$c,128 128 224),$(if $(findstring 1,$(call ~math-cmp,1114112,$c)),$(call ~utf-seq,$c,128 128 128 240),?)))))
~plex2 = $(foreach a,$1,$(foreach b,$1,$a$b))
~byte-to-bin-a := $(wordlist 2,99999999,$(call ~plex2,$(call ~plex2,00 01 10 11)))
~byte-to-bin = $(if $(subst 0,,$1),$(word $1,$(~byte-to-bin-a)))
~b2d-loop = $(if $(word 2,$1),$(call ~binop,add,$(lastword $1),$(call ~binop,mul,2,$(call ~b2d-loop,$(call ~butlast,$1)))),$1)
~utf8-decode = $(foreach num,$(subst b 10,,$(foreach dec,$1,$(or $(filter 1%,$(call ~byte-to-bin,$(dec))b),$(dec)))),$(if $(filter %b,$(num)),$(call ~b2d-loop,$(subst 0,0 ,$(subst 1,1 ,$(or $(subst $  ,,$(wordlist 2,99999999,$(subst 0,0 ,$(subst b,,$(num))))),0)))),$(num)))

endef

define [mod-string]
# Requires: core
# Exports: string-repeat"string-from-bytes#strings-from-bytes#string-to-bytes#string-lower#string-upper#string-slice}3 string-len#string-to-chars}1
$(call ^R,core)
~all-bytes :=           !+ $'                        !0   !1 " \# $` % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~                                                                                                                                 
~gen-polysub = $(if $1,$(call ~gen-polysub,$(wordlist 2,99999999,$1),$(wordlist 2,99999999,$2),$`(subst $(subst $(if ,,,),$`&,$(subst $],$`],$(subst $[,$`[,$(subst $`,$`$`,$(call ^n,1,$1))))),$(subst $(if ,,,),$`&,$(subst $],$`],$(subst $[,$`[,$(subst $`,$`$`,$(call ^n,1,$2))))),$(or $3,$`1))),$3)
~vdemote = $(subst !0, ,$(call ^d,$1))
~gen-split = $(call ~gen-polysub,$(call ~vdemote,$1),$(patsubst %,$2,$(call ~vdemote,$1)))
$(call ^fset,~split-ascii,$(call ~gen-split,$(wordlist 1,127,$(~all-bytes)),%!0))
$(call ^fset,~split-utf8-esc,$(call ~gen-split,$(wordlist 194,244,$(~all-bytes)),%!0))
$(call ^fset,~split-utf8-cont,$(call ~gen-split,$(wordlist 128,191,$(~all-bytes)),!1.%!0))
~utf8-group-if = $(if $(word 2,$1),$(subst !., ,$(subst $  !.,,$(call ~split-utf8-cont,$1))),$1)
~string-to-chars = $(filter %,$(call ~split-ascii,$(call ~utf8-group-if,$(call ~split-utf8-esc,$(subst $ 	,!+,$(subst $  ,!0,$(subst !,!1,$1)))))))
~string-len = $(words $(call ~string-to-chars,$1))
~string-slice = $(call ^u,$(subst $  ,,$(wordlist $1,$2,$(call ~string-to-chars,$3))))
$(call ^fset,~string-upper,$(call ~gen-polysub,$(wordlist 97,122,$(~all-bytes)),$(wordlist 65,90,$(~all-bytes))))
$(call ^fset,~string-lower,$(call ~gen-polysub,$(wordlist 65,90,$(~all-bytes)),$(wordlist 97,122,$(~all-bytes))))
~string-to-bytes = $(and $(if $(if $(value ~s2b-sub),,1),$(and $(call ^fset,~num-enc,$(call ~gen-polysub,/ 0 1 2 3 4 5 6 7 8 9 !1/1 !1/0,/@ /0 /1 /2 /3 /4 /5 /6 /7 /8 /9 !11 !10))1,$(call ^fset,~s2b-sub,$(call ~gen-polysub,$(call ~vdemote,$(call ~num-enc,$(~all-bytes))),$(addsuffix !0,$(call ~indices-a,$(words $(~all-bytes))))))))1,$(filter %,$(call ~s2b-sub,$(call ~num-enc,$(call ^d,$1)))))
~strings-from-bytes = $(foreach n,$1,$(if $(filter 0,$n),!.,$(word $n,$(~all-bytes))))
~string-from-bytes = $(call ~concat-vec,$(call ~strings-from-bytes,$1))
~nwords = $(if $(word $1,$2),$(wordlist 1,$1,$2),$(call ~nwords,$1,$2 $2 $2))
~string-repeat = $(subst .,$1,$(subst $  ,,$(if $(filter-out -%,$(subst 0,,$2)),$(call ~nwords,$2,. . .))))

endef

define [mod-math0]
# Requires: core
# Exports: 
$(call ^R,core)
~d2u = $(subst 3,0111,$(subst 6,3111,$(subst 8,611,$(subst 9,81,$(subst 7,61,$(subst 5,311,$(subst 4,31,$(subst 2,011,$(subst 1,01,$(or $1,?))))))))))
~u2d = $(subst 01,1,$(subst 011,2,$(subst 31,4,$(subst 311,5,$(subst 61,7,$(subst 81,9,$(subst 611,8,$(subst 3111,6,$(subst 0111,3,$1)))))))))
~uf-get-lz = $(subst :, ,$(filter-out 01%,$(subst :01, 01,$(subst $  ,:,$1))))
~uf-trim-lz = $(subst :, ,$(filter 01%,$(subst :01, 01,$(subst $  ,:,$1))))
~u-carry-fn = $(subst $21,1$3,$(if $(findstring $2$21,$1),$(call ~u-carry-fn,$1,$2$2,$3$3),$1))
~borrow-n = $(if $(findstring $2~,$1),$(subst 1~,,$(subst $2~,~$(subst 0,0111111111,$2),$(call ~borrow-n,$1,$2$2))),$1)
~u-sub-unsigned = $(foreach u,$(subst $  ,,$(subst 1~,,$(subst 11~~,,$(subst 111~~~,,$(subst 111111~~~~~~,,$(subst 00,0,$(subst 10,1,$(join $(subst 0, 0,$(subst 1,,$2)$1),$(subst 0, 0,$(subst 1,,$1)$(subst 1,~,$2)))))))))),$(if $(findstring ~,$u),$(patsubst -0,0,$(subst $  ,,$(patsubst 0%,0,$(subst 01,0 1,$(call ~borrow-n,$(subst 1~,,$(subst 11~~,,$(subst 111~~~,,$(subst 111111~~~~~~,,$(subst 0~,~0111111111,$(if $(filter ~%,$(subst 0,,$u)),- $(subst *,1,$(subst 1,~,$(subst ~,*,$u))),$u)))))),0))))),0$(subst $  ,,$(wordlist 2,99999999,$(subst 01,0 1,$u)))))
~u-add-unsigned-fn = 0$(subst $  ,,$(wordlist 2,99999999,$(subst 01,0 1,$(foreach w,$(subst 01111111111,10,$(subst $  ,,$(subst 00,0,$(subst 10,1,$(join $(subst 0, 0,$(subst 1,,$1)$2),$(subst 0, 0,$(subst 1,,$2)$1)))))),$(if $(findstring 01111111111,$w),$(call ~u-carry-fn,$w,0111111111,0),$w)))))
~u-add = $(if $(findstring -,$1$2),$(if $(findstring 1,$1$2),$(if $(findstring -,$1),$(if $(findstring -,$2),-$(call ~u-add-unsigned-fn,$(subst -,,$1),$(subst -,,$2)),$(call ~u-sub-unsigned,$2,$(subst -,,$1))),$(call ~u-sub-unsigned,$1,$(subst -,,$2))),0),0$(subst $  ,,$(wordlist 2,99999999,$(subst 01,0 1,$(foreach w,$(subst 01111111111,10,$(subst $  ,,$(subst 00,0,$(subst 10,1,$(join $(subst 0, 0,$(subst 1,,$1)$2),$(subst 0, 0,$(subst 1,,$2)$1)))))),$(if $(findstring 01111111111,$w),$(call ~u-carry-fn,$w,0111111111,0),$w))))))
~u-cmp = $(if $(findstring -,$1$2),$(if $(findstring 1,$1$2),$(if $(findstring -,$1),$(if $(findstring -,$2),$(call ~u-cmp,$(subst -,,$2),$(subst -,,$1)),~),1)),$(word 1,$(subst 0,,$(subst 1~,,$(subst 11~~,,$(subst 10~,,$(subst 111110~~~~~,0,$(join $(subst 0, 0,$(subst 1,,$2)$1),$(subst 0, 0,$(subst 1,,$1)$(subst 1,~,$2))))))))))
~uf-cmp = $(word 1,$(subst 0,,$(subst 1~,,$(subst 11~~,,$(subst 10~,,$(subst 111110~~~~~,0,$(join $1,$(subst 1,~,$2))))))))
~uf-sign-sub = $(foreach u,$(subst $  ,,$(subst 00,0,$(subst 10,1,$(subst 1~,,$(subst 11~~,,$(subst 10~,,$(subst 111110~~~~~,0,$(join $1,$(subst 1,~,$2))))))))),$(if $(findstring ~,$u),$(strip $(subst 0, 0,$(call ~borrow-n,$(subst 1~,,$(subst 11~~,,$(subst 111~~~,,$(subst 111111~~~~~~,,$(subst 0~,~0111111111,$(if $(filter ~%,$(subst 0,,$u)),$(if $3,+,-) $(subst *,1,$(subst 1,~,$(subst ~,*,$u))),$(if $3,-,+) $u)))))),0))),$(if $3,-,+) $(strip $(subst 0, 0,$u))))
~u-carry-all = $(if $(findstring 01111111111,$1),$(call ~u-carry-all,$(patsubst -1%,-01%,$(patsubst 1%,01%,$(subst 0X,1,$(subst 1111111111,X0,$1))))),$1)
~u-add-ones = $(or $(filter-out -% %1111111111,$1$2),$(call ~u-add,$1,$(call ~u-carry-all,0$2)))
~u-1 = $(or $(patsubst %1,%,$(filter-out -% %0,$1)),$(filter-out 0% %1111111111,$11),$(call ~u-add,$1,-01))
~fix-native-var = $(call ^fset,$1,$(subst $(if ,,$`$[call native-var,),$`$[,$(value $1)),)
~A*0 = 
~A*01 = $2
~A*011 = $3
~A*0111 = $4
~A*01111 = $5
~A*011111 = $6
~A*0111111 = $(subst $  01111111111,1 0,$(subst 1,11,$4))
~A*01111111 = $7
~A*011111111 = $(subst $  01111111111,1 0,$(subst 1,11,$5))
~A*0111111111 = $8
~vmul-9 = 0$(subst $  , 0,$(subst $  X,1,$(subst 1111111111,X ,$(subst 0,,$(join $(join $(join $(call native-var,~A*$(word 1,$1)),0 $(call native-var,~A*$(word 2,$1))),0 0 $(join $(call native-var,~A*$(word 3,$1)),0 $(call native-var,~A*$(word 4,$1)))),0 0 0 0 $(join $(join $(call native-var,~A*$(word 5,$1)),0 $(call native-var,~A*$(word 6,$1))),0 0 $(join $(call native-var,~A*$(word 7,$1)),0 $(join $(call native-var,~A*$(word 8,$1)),0 $(call native-var,~A*$(word 9,$1))))))))))
~vmul-loop = $(if $(word 10,$1),$(subst $  011111111111111111111,11 0,$(filter 0%,$(subst 0, 0,$(foreach w,$(subst 01111111111,10,$(subst $  ,,$(subst 00,0,$(subst 10,1,$(join 0 0 0 0 0 0 0 0 0 $(call ~vmul-loop,$(wordlist 10,99999999,$1),$2,$3,$4,$5,$6,$7,$8),$(call native-var,~vmul-9)))))),$(if $(findstring 01111111111,$w),$(call ~u-carry-fn,$w,0111111111,0),$w))))),$(call native-var,~vmul-9))
$(if $(call ~fix-native-var,~vmul-loop),)
$(if $(call ~fix-native-var,~vmul-9),)
~vmul-0 = $(if $(findstring 1,$2),$(call ~vmul,$1,$(subst ., ,$(filter-out %0,$(subst 0 ,0.,$2)))) $(subst ., ,$(filter %0,$(subst 0 ,0.,$2))),$(patsubst %,0,$1) $2)
~vmul = $(if $(filter 09,$29),$(call ~vmul-0,$1,$2),$(call ~vmul-loop,$2,0 $1,$(subst $  01111111111,1 0,$(subst 1,11,0 $1)),$(subst $  01111111111,1 0,$(subst $  01111111111,1 0,0 $(subst 1,111,$1))),$(subst x,11,$(subst $  0xxxxx,1 0,$(subst 1,xx,$(subst $  011111,x 0,0 $1)))),$(subst 2,1,$(subst 1 0, 011111,$(subst 11,2,$1 0))),$(subst $  01111111111,1 0,$(subst $  0X,1,$(subst 1111111111,X 0,0 $(subst 1,1111111,$1)))),$(subst $  01111111111,1 0,$(subst $  0X,1,$(subst 1111111111,X 0,0 $(subst 1,111111111,$1))))))
~uf*b1 = $(subst $  011111111111111111111,11 0,$(subst $  01111111111111111111111111111111111111111,1111 0,0 $(subst 1,$(subst 0,,$2),$1)))
~uf*b2 = 0$(subst $  , 0,$(subst $  X,1,$(subst 1111111111,X ,$(subst 0,,$(join 0 $(subst 1,$(subst 0,,$(word 1,$2)),$1),0 0 $(subst 1,$(subst 0,,$(word 2,$2)),$1))))))
~uf*b3 = $(subst $  01111111111,1 0,0$(subst $  , 0,$(subst $  X,1,$(subst 1111111111,X ,$(subst 0,,$(join $(join 0 $(subst 1,$(subst 0,,$(word 1,$2)),$1),0 0 $(subst 1,$(subst 0,,$(word 2,$2)),$1)),0 0 $(join 0 $(subst 1,$(subst 0,,$(word 3,$2)),$1),0 $3)))))))
~uf*b4 = $(call ~uf*b3,$1,$2,$(call ~uf*b1,$1,$(word 4,$2)))
~uf*b5 = $(call ~uf*b3,$1,$2,$(call ~uf*b2,$1,$(wordlist 4,99999999,$2)))
~uf*b6 = $(call ~uf*b3,$1,$2,$(call ~uf*b3,$1,$(wordlist 4,99999999,$2)))
~uf*b7 = $(call ~uf*b3,$1,$2,$(call ~uf*b4,$1,$(wordlist 4,99999999,$2)))
~uf*b8 = $(call ~uf*b3,$1,$2,$(call ~uf*b5,$1,$(wordlist 4,99999999,$2)))
~uf-mul = $(if $(word $(words 1 $1),$2),$(call ~uf-mul,$2,$1),$(filter 0%,$(subst 0, 0,$(foreach w,$(subst 01111111111,10,$(subst $  ,,$(or $(call native-var,~uf*b$(words $2)),$(call ~vmul,$1,$2)))),$(if $(findstring 01111111111,$w),$(call ~u-carry-fn,$w,0111111111,0),$w)))))
$(if $(call ~fix-native-var,~uf-mul),)
~div-post = $(if $(if $(filter 2 3,$1),$(findstring 1,$(if $(filter 3,$1),$3,$(or $(call ~uf-cmp,$3,$(subst 2,1,$(subst 1 0, 011111,$(subst 11,2,$4 0)))),$(subst 11,,$(lastword $2)))))),$(filter 0%,$(subst 0, 0,$(foreach w,$(subst 01111111111,10,$(subst $  ,,$21)),$(if $(findstring 01111111111,$w),$(call ~u-carry-fn,$w,0111111111,0),$w)))),$(if $(filter 4,$1),$3,$2))
~div-loop = $(if $(findstring 1,$(word 1,$1)),$(call ~div-loop,0 $(filter 0%,$(subst 0, 0,$(foreach w,$(subst 01111111111,10,$(subst $  ,,$(subst 00,0,$(subst 10,1,$(join $(wordlist 2,99999999,$1),$2))))),$(if $(findstring 01111111111,$w),$(call ~u-carry-fn,$w,0111111111,0),$w)))),$2,$3,$4,$5,$(subst 1x,,$6x)),$(if $(word $4,$6),$(call ~div-post,$5,0 $6,$(wordlist 2,99999999,$1),$2),$(foreach d,0$(subst 1111111111,111111111,$(subst x,1,$(subst 1,,$(subst $3,x,$(subst 0,,$(subst 1,1111111111,$(subst 1,1111111111,$(word 1,$(wordlist 2,99999999,$1)))$(word 2,$(wordlist 2,99999999,$1)))$(word 3,$(wordlist 2,99999999,$1))))))),$(call ~div-loop,$(filter 0%,$(subst 0, 0,$(foreach w,$(subst 01111111111,10,$(subst $  ,,$(subst 00,0,$(subst 10,1,$(join $(wordlist 2,99999999,$1),$(subst 101,0,$(subst 11011,0,$(subst 1110111,0,$(patsubst 0%,%0111111111,$(patsubst 0111111%,%101111,$(filter 0%,$(subst 0, 0,$(foreach w,$(subst 01111111111,10,$(subst $  ,,$(subst $  011111111111111111111,11 0,$(subst $  01111111111111111111111111111111111111111,1111 0,0 $(subst 1,$(subst 0,,$d),$2))))),$(if $(findstring 01111111111,$w),$(call ~u-carry-fn,$w,0111111111,0),$w)))))))))1))))),$(if $(findstring 01111111111,$w),$(call ~u-carry-fn,$w,0111111111,0),$w)))),$2,$3,$4,$5,$6$(if $6, )$d))))
~uf*3 = $(filter 0%,$(subst 0, 0,$(foreach w,$(subst 01111111111,10,$(subst $  ,,$(subst 1,111,$1))),$(if $(findstring 01111111111,$w),$(call ~u-carry-fn,$w,0111111111,0),$w))))
~power-seq-1 = $(if $(word $4,$(wordlist $3,99999999,$2)),$(wordlist 1,$(words $2),$(filter 0%,$(subst 0, 0,$(foreach w,$(subst 01111111111,10,$(subst $  ,,$(subst 00,0,$(subst 10,1,$(join $1,$21))))),$(if $(findstring 01111111111,$w),$(call ~u-carry-fn,$w,0111111111,0),$w))))),$(call ~power-seq-1,$(subst $  01111111111,1 0,$(subst 00,0,$(subst 10,1,$(join $1,$2 $1)))),$2 $2,$3,$4))
~uf-round = $(if $(if $(filter 2,$2),$(findstring 0111111,$(or $(filter-out 011111,$(or $(word 2,$(wordlist $1,99999999,$3)),0)),$(if $(or $(findstring 1,$(wordlist 3,99999999,$(wordlist $1,99999999,$3))),$(findstring 1,$(subst 11,,$(word $1,$3)))),0111111))),$(if $(filter 3,$2),$(findstring $  01,$(wordlist $1,99999999,$3)))),$(filter 0%,$(subst 0, 0,$(foreach w,$(subst 01111111111,10,$(subst $  ,,0 $(wordlist 1,$1,$3)1)),$(if $(findstring 01111111111,$w),$(call ~u-carry-fn,$w,0111111111,0),$w)))),0 $(wordlist 1,$1,$3))
~uf-div1 = $(call ~uf-round,$3,$4,$(if $(filter 0111 0111111 01111111 0111111111,$2),$(call ~power-seq-1,$(if $(filter 0111 0111111,$2),$(if $(filter 0111,$2),$(call ~uf*3,$1),$(filter 0%,$(subst 0, 0,$(foreach w,$(subst 01111111111,10,$(subst $  ,,$(subst x,111,$(subst 1 0, 0xxxxx,$(subst 11,x,$1 0))))),$(if $(findstring 01111111111,$w),$(call ~u-carry-fn,$w,0111111111,0),$w))))),$(if $(filter 01111111,$2),$(wordlist 2,99999999,$(call ~uf-mul,$1,01 01111 011 011111111 011111 01111111)),$1)),$(if $(filter 01111111,$2),0 0 0 0 0 0,0),$(if $(word $3,$1),$(words $1),$3),$(words $2 1 1 1)),$(if $(filter 01 011 01111 011111111,$2),$(wordlist 2,99999999,$(if $(findstring 01111,$2),$(subst 2 0, 011111,$(subst 22,1,$(subst 1 0, 0112,$(subst 11,2,$(if $(filter 01111,$2),$1,$(subst 2,1,$(subst 1 0, 011111,$(subst 11,2,$1 0)))) 0 0)))),$(if $(filter 011,$2),$(subst 2,1,$(subst 1 0, 011111,$(subst 11,2,$1 0))),$1))),$(subst $  01111111111,1 0,$(subst 1,11,$1)))))
~recip-loop = $(subst 1,,$2)$(if $(filter 1 %x1,$2),, $(call ~recip-loop,$1,$(subst $1,x,$(subst 1,1111111111,$(subst x,,$2)))))
~recip2 = $(strip $(subst $  , 0,$(subst x,1,$(call ~recip-loop,$(subst 0,,$(subst 1,1111111111,$(word 1,$1))$(word 2,$1)),1111111111))))
$(if $(call ~memoize,~recip2),)
~recip-div2 = $(wordlist 2,99999999,$(call ~power-seq-1,$(call ~uf-mul,$1,$4),0 $(patsubst %,0,$4),$(if $(word $3,$1),$(words $1),$3),$(words $2 1 1 1)))
~uf-div2 = $(if $(filter 0,$(word 1,$2)),$(call ~uf-div1,$(wordlist 2,99999999,$1),$(wordlist 2,99999999,$2),$3,$4),$(if $(filter 0 011 01111 011111 0111111 011111111,$(word 2,$2)),$(if $(filter 0 011111,$(word 2,$2)),$(if $(filter 011111,$(word 2,$2)),$(call ~uf-div2,$(subst $  01111111111,1 0,$(subst 1,11,0 $1)),$(wordlist 1,2,$(subst $  01111111111,1 0,$(subst 1,11,0 $2))),$3,$4),$(call ~uf-div1,$1,$(word 1,$2),$3,$4)),$(call ~uf-div2,$(subst 2,1,$(subst 1 0, 011111,$(subst 11,2,$1 0))),$(subst 2,1,$(subst 1 0, 011111,$(subst 11,2,$2))),$3,$4)),$(call ~uf-round,$3,$4,$(call ~recip-div2,$1,$2,$3,$(call ~recip2,$2)))))
~sdiv-done = $(subst 01, ,0$21)$(findstring 1,$3)
~sdiv-loop = $(subst 1,,$2) $(call $(if $(word $4,$5),~sdiv-done,~sdiv-loop),$1,$(subst $1,0,$(subst 0,,$(subst 1,1111111111,$2)$(word 1,$3))),$(wordlist 2,99999999,$3),$4,$5 0)
~uf-div3 = $(call ~uf-round,$3,$4,$(strip $(subst $  , 0,$(subst 0,1,$(call ~sdiv-loop,$(subst 0,,$(subst 1,1111111111,$(subst 1,1111111111,$(word 1,$2))$(word 2,$2))$(word 3,$2)),$(subst 0,,$(subst 1,1111111111,$(subst 1,1111111111,$(word 1,$1))$(word 2,$1))$(word 3,$1)),$(wordlist 4,99999999,$1),$3)))))
~uf-remainder = $(or $(wordlist 2,99999999,$(wordlist $3,99999999,$(filter 0%,$(subst 0, 0,$(foreach w,$(subst 01111111111,10,$(subst $  ,,$(subst 00,0,$(subst 10,1,$(join $1,$(subst 101,0,$(subst 11011,0,$(subst 1110111,0,$(patsubst 0%,%0111111111,$(patsubst 0111111%,%101111,$(call ~uf-mul,$2,$(wordlist 2,99999999,$(call ~uf-div,$1,$2,$3,1))))))))1))))),$(if $(findstring 01111111111,$w),$(call ~u-carry-fn,$w,0111111111,0),$w)))))),0)
~uf-div = $(if $(filter 09,$29),$(call ~uf-div,$1,$(subst ., ,$(filter-out %0,$(subst 0 ,0.,$2))),$3,$4),$(if $(filter 0 -%,$3),$(call ~div-post,$4,0,$1,$2),$(if $(if $(findstring 1,$1),,1),0,$(if $(word 4,$2),$(call ~div-loop,0 $1,$2,$(subst 0,,$(subst 1,1111111111,$(word 1,$2))$(word 2,$2)),$3,$4,),$(if $(filter 4,$4),$(call ~uf-remainder,$1,$2,$3),$(call ~uf-div$(words $2),$1,$2,$3,$4))))))
~u-fdiv = $(if $(filter 00%,$1 $2),$(call ~u-fdiv,$(patsubst 00%,0%,$1),$(patsubst 00%,0%,$2),$3),$(if $(and $1,$(findstring 1,$2)),0$(subst $  ,,$(wordlist 2,99999999,$(subst 01,0 1,$(subst $  ,,$(foreach num-digits,$(words $(wordlist $(words $(subst 0, 0,$2)),99999999,$(subst 0, 0,$1))),$(if $(filter 0,$(num-digits)),$(if $(filter 4,$3),$1,0),$(call ~uf-div,0$(subst 0, 0,$1),$(strip $(subst 0, 0,$2)),$(num-digits),$3)))))))))

endef

define [mod-math1]
# Requires: core math0
# Exports: 
$(call ^R,core)
$(call ^R,math0)
~fp-norm = $(if $(filter 0,$(word 3,$1)),$(foreach zeros,$(word 1,$(subst 001,0 01,$(subst $  ,,$(wordlist 3,99999999,$1)))),$(call ~u-add,$(word 1,$1),$(subst --,,-$(call ~u-add-ones,0,$(subst 0,1,$(zeros))))) $(word 2,$1)$(or $(subst 9$(subst 0, 0,$(zeros)),,9 $(wordlist 3,99999999,$1)),$(if ,, 0))),$1)
~u2fp-exp = $(foreach s,$(lastword $(subst E, E,$1)),$(foreach en,$(subst E,,$(subst E+,E,$(subst +-,X,$s))),$(if $(subst 1,,$(subst 0,,$(patsubst -%,%,$(en)))),,$(call ~u2fp,$(subst E,X,$(subst $s2,,$12)),$(en)))))
~u2fp = $(if $(if $(subst 1,,$(subst 0,,$1)),,1),$(if $1,$(if $(or $2,$(word 10,$(subst 0, 0,$1)),$(filter 00%,$10)),$(call ~fp-norm,$(call ~u-add-ones,$(or $2,0),$(subst 0,1,$(subst 1,,$1))) $(or $3,+)$(subst 0, 0,$1)$4),0$(subst 0,1,$(subst 1,,$1)) $(or $3,+)$(subst 0, 0,$1)$4)),$(if $(findstring E,$(subst e,E,$1)),$(call ~u2fp-exp,$(subst e,E,$1)),$(if $(findstring 2-0,2$1),$(call ~u2fp,$(subst 2-,,2$1),$2,-),$(if $(findstring .,$1),$(foreach f,$(lastword $(subst ., ,$1)),$(if $(subst 1,,$(subst 0,,$f)),,$(call ~u2fp,$(subst .,x,$(subst .$f2,,$12)),$2,$3,$(subst 0, 0,$f))))))))
~fp2u = $(if $(findstring 1,$(word 3,$1)),$(findstring -,$(word 2,$1))$(subst $  ,,$(subst . ,,$(subst . 0,.0,$(filter-out %0,$(subst 0 ,0,$(foreach et,$(or $(subst 0,,$(subst 10,91,$(subst 10,091,$(word 1,$1)))),-),$(if $(findstring $(et),-11111 91911 91111111111),$(if $(filter -%,$(et)),0. $(subst -,,$(subst 1,0 ,$(et)))$(wordlist 3,99999999,$1),$(subst 00,0,$(subst 10,1,$(join $(wordlist 3,99999999,$1),$(subst 1, 0,$(subst 9,111111111,$(et))).)))),$(word 3,$1). $(wordlist 4,99999999,$1)  e$(subst +-,-,+$(call ~u-1,$(word 1,$1))).)))) ))),$(if $(findstring 1,$(wordlist 3,99999999,$1)),$(call ~fp2u,$(call ~u-1,$(word 1,$1)) $(word 2,$1) $(wordlist 4,99999999,$1)),$(if $1,0,NaN)))
~prec-to-pod = $(if $1,$(if $(filter +% -%,$1),$(foreach w,$(call ~d2u,$(findstring $1,$(word 1,$1))),$(if $(filter-out + -,$(subst 1,,$(subst 0,,$w))),,$(subst +,-,$(subst -,,$w)))),$(if $(call ~word-index?,$1),$(if $(filter 0%,$1),$(call ~prec-to-pod,$(patsubst 0%,%,$1)),$1))),16)
~make-fp<<1 = $(if $(filter 0,$(word 1,$3)),$1 $2 $(or $(wordlist 2,99999999,$3),0),$(or $(filter-out -% %1111111111,$11),$(call ~u-add,$1,01)) $2 $3)
~tally = $(if $(word 2,$1),$(call ~tally,$(subst 1,1111111111,$(word 1,$1))$(wordlist 2,99999999,$1)),$(subst 0,,$1))
~fp-add-x = $(if $(findstring $2,$5),$(call ~make-fp<<1,$1,$2,$(filter 0%,$(subst 0, 0,$(foreach w,$(subst 01111111111,10,$(subst $  ,,$(subst 00,0,$(subst 10,1,$(join 0 $3,0 $(and $(filter-out $1,$4),$(subst 1,0 ,$(call ~tally,$(subst 0, 0,$(call ~u-add,$1,$(subst --,,-$4))))))$6))))),$(if $(findstring 01111111111,$w),$(call ~u-carry-fn,$w,0111111111,0),$w))))),$1 $(call ~uf-sign-sub,$3,$(and $(filter-out $1,$4),$(subst 1,0 ,$(call ~tally,$(subst 0, 0,$(call ~u-add,$1,$(subst --,,-$4))))))$6,$(findstring -,$2)))
~fp-add = $(and $1,$2,$(if $(findstring 1,$(call ~u-cmp,$(word 1,$2),$(word 1,$1))),$(call ~fp-add-x,$(word 1,$2),$(word 2,$2),$(wordlist 3,99999999,$2),$(word 1,$1),$(word 2,$1),$(wordlist 3,99999999,$1)),$(call ~fp-add-x,$(word 1,$1),$(word 2,$1),$(wordlist 3,99999999,$1),$(word 1,$2),$(word 2,$2),$(wordlist 3,99999999,$2))))
~fp-mul = $(and $1,$2,$(call ~u-add,$(word 1,$1),$(word 1,$2)) $(if $(findstring $(word 2,$1),$(word 2,$2)),+,-) $(call ~uf-mul,$(wordlist 3,99999999,$1),$(wordlist 3,99999999,$2)))
~fp-mulp-x = $1 $2 $(wordlist 1,$5,$3)$(if $(and $(filter-out -0% 0%,$4),$(filter 0,$(word 1,$3))),$(addprefix $  ,$(word 2,$(wordlist $5,99999999,$3))))
~fp-mulp = $(if $(and $3,$1,$2),$(foreach exp,$(call ~u-add,$(word 1,$1),$(word 1,$2)),$(foreach num-digits,$(if $(filter 0% -0%,$3),$(call ~u2d,$(call ~u-add,$(exp),$3)),$3),$(if $(filter -% 0,$(num-digits)),0 + 0,$(call ~fp-mulp-x,$(exp),$(if $(findstring $(word 2,$1),$(word 2,$2)),+,-),$(call ~uf-mul,$(word 3,$1)$(if $(word 4,$1), $(wordlist 1,$(num-digits),$(wordlist 4,99999999,$1))),$(word 3,$2)$(if $(word 4,$2), $(wordlist 1,$(num-digits),$(wordlist 4,99999999,$2)))),$3,$(num-digits))))))
~fp-div-x = $(foreach num-digits,$(if $(filter 0% -0%,$6),$(call ~u2d,$(call ~u-add,$1,$6)),$6),$(if $(filter -%,$(num-digits)),$(if $(filter 3,$(if $5,2,$(if $(filter +,$2),1,3))),$(call ~u-add,01,$(subst --,,-$6)) $2 01,0 + 0),$(call ~make-fp<<1,$1,$2,$(call ~uf-div,$3,$4,$(num-digits),$(if $5,2,$(if $(filter +,$2),1,3))))))
~fp-div = $(if $(if $(findstring 101,$(word 3,$1)$(word 3,$2)),,1),$(if $(findstring 1,$(wordlist 3,99999999,$2)),$(if $(findstring 1,$(wordlist 3,99999999,$1)),$(call ~fp-div,$(call ~fp-norm,$1),$(call ~fp-norm,$2),$3,$4),$(if $1,0 + 0,)),),$(if $3,$(if $(findstring 1,$(call ~uf-cmp,$(wordlist 3,99999999,$2),$(wordlist 3,99999999,$1))),$(call ~fp-div-x,$(call ~u-add,$(word 1,$1),$(subst --,,-$(word 1,$2))),$(if $(findstring $(word 2,$1),$(word 2,$2)),+,-),$(wordlist 3,99999999,$1),$(wordlist 3,99999999,$2),$4,$3),$(call ~fp-div-x,$(call ~u-add,$(or $(filter-out -% %1111111111,$(word 1,$1)1),$(call ~u-add,$(word 1,$1),01)),$(subst --,,-$(word 1,$2))),$(if $(findstring $(word 2,$1),$(word 2,$2)),+,-),0 $(wordlist 3,99999999,$1),$(wordlist 3,99999999,$2),$4,$3))))
~fp-mod = $(if $(if $(findstring 101,$(word 3,$1)$(word 3,$2)),,1),$(if $(findstring 1,$(wordlist 3,99999999,$2)),$(if $(findstring 1,$(wordlist 3,99999999,$1)),$(call ~fp-mod,$(call ~fp-norm,$1),$(call ~fp-norm,$2)),$(if $1,0 + 0,)),),$(if $(if $(findstring $(word 2,$1),$(word 2,$2)),,1),$(call ^Y,$(call ~fp-mod,$1,$(subst !,-,$(subst $  -, +,$(subst $  +, !,$2)))),$2,,,,,,,,$`(if $`(findstring 1,$`(wordlist 3,99999999,$`1)),$`(call ~fp-add,$`2,$`1),$`1)),$(if $(findstring 1,$(call ~u-cmp,$(word 1,$2),$(word 1,$1))),$1,$(word 1,$2) $(word 2,$1) $(call ~uf-div,0 $(wordlist 3,99999999,$1),$(wordlist 3,99999999,$2),$(call ~u2d,$(call ~u-add,$(or $(filter-out -% %1111111111,$(word 1,$1)1),$(call ~u-add,$(word 1,$1),01)),$(subst --,,-$(word 1,$2)))),4))))
~fp-round = $(if $(findstring 1,$(word 3,$1)),$(foreach num-digits,$(if $(filter 0% -0%,$2),$(call ~u2d,$(call ~u-add,$(word 1,$1),$2)),$2),$(if $(filter -%,$(num-digits)),$(if $(filter 3,$(or $(filter 2 1,$3),$(if $(findstring $(word 2,$1),$(if $(filter 3,$3),+,-)),3,1))),$(call ~u-add,01,$(subst --,,-$2)) $(word 2,$1) 01,0 + 0),$(call ~make-fp<<1,$(word 1,$1),$(word 2,$1),$(if $(filter 0,$(num-digits)),$(wordlist 2,99999999,$(call ~uf-round,1,$(or $(filter 2 1,$3),$(if $(findstring $(word 2,$1),$(if $(filter 3,$3),+,-)),3,1)),0 $(wordlist 3,99999999,$1))),$(call ~uf-round,$(num-digits),$(or $(filter 2 1,$3),$(if $(findstring $(word 2,$1),$(if $(filter 3,$3),+,-)),3,1)),$(wordlist 3,99999999,$1)))))),$(if $(findstring 1,$(wordlist 3,99999999,$1)),$(call ~fp-round,$(call ~fp-norm,$1),$2,$3),$(if $1,0 + 0)))
~fp-trunc = $(if $(subst 0,,$(filter-out -%,$(word 1,$1))),$(if $(word 9,$(subst 0, 0,$(word 1,$1))),$1,$(wordlist 1,$(call ~u2d,$(call ~u-add-ones,$(word 1,$1),11)),$1)),$(if $1,0 + 0))
~fp-mag-ceiling = $(if $(subst 0,,$(filter-out -%,$(word 1,$1))),$(call ^Y,$(call ~fp-trunc,$1),$1,,,,,,,,$`(if $`(findstring 1,$`(subst $`1,,$`2)),$`(call ~make-fp<<1,$`(word 1,$`1),$`(word 2,$`1),$`(filter 0%,$`(subst 0, 0,$`(foreach w,$`(subst 01111111111,10,$`(subst $`  ,,0 $`(wordlist 3,99999999,$`1)1)),$`(if $`(findstring 01111111111,$`w),$`(call ~u-carry-fn,$`w,0111111111,0),$`w))))),$`1)),$(if $(findstring 1,$(wordlist 3,99999999,$1)),01 $(word 2,$1) 01,$(if $1,0 + 0)))
~fp-floor = $(if $(findstring $  -,$1),$(call ~fp-mag-ceiling,$1),$(if $1,$(call ~fp-trunc,$1)))
~fp-ceil = $(if $(findstring $  +,$1),$(call ~fp-mag-ceiling,$1),$(if $1,$(call ~fp-trunc,$1)))
~fp-cmp = $(if $(findstring $(findstring + 01,$1),$2),$(or $(call ~u-cmp,$(word 1,$1),$(word 1,$2)),$(call ~uf-cmp,$(wordlist 3,99999999,$1),$(wordlist 3,99999999,$2))),$(if $(if $(and $1,$2),,1),$(if $1,1,$(if $2,~)),$(if $(if $(findstring 1,$(word 3,$1)),,1),$(if $(findstring 1,$(word 3,$2)),$(if $(filter -,$(word 2,$2)),1,~),),$(if $(if $(findstring 1,$(word 3,$2)),,1),$(if $(filter -,$(word 2,$1)),~,1),$(if $(findstring - 01,$(filter-out 0,.$1)),$(if $(findstring - 01,$(filter-out 0,.$2)),$(call ~fp-cmp,$(subst !,-,$(subst $  -, +,$(subst $  +, !,$2))),$(subst !,-,$(subst $  -, +,$(subst $  +, !,$1)))),~),1)))))
~fp-sq = $(call ~fp-mul,$1,$1)
~fp-pwr = $(foreach n/2,$(subst 10,022222,$(subst 11,2,$2)),$(if $(findstring 2,$(n/2)),$(if $(findstring 1,$(n/2)),$(call ~fp-mul,$(call ~fp-sq,$(call ~fp-norm,$(call ~fp-pwr,$1,$(subst 2,1,$(subst 1,,$(n/2)))))),$1),$(call ~fp-sq,$(call ~fp-norm,$(call ~fp-pwr,$1,$(subst 2,1,$(n/2)))))),$(if $(findstring 1,$2),$1,01 + 01)))
~extend-fn = $(if $(subst 0,,$2),$(if $(word $2,$1$3),$(wordlist 1,$2,$1$3),$(call ~extend-fn,$1$3$3,$2,$3$3)))
~zero-pad = $(strip $(if $2,$(wordlist $(words $1 0),99999999,$(call ~extend-fn,0,$2, 0 0 0 0))) $1)
~ltrimz = $(if $(filter 00% 0n% 0-%,$1),$(foreach lz,$(word 1,$(subst 0-,0 ,$(subst 0n,0 ,$(subst 0., ,$(subst 01, ,$(patsubst %0,% 0,$1)))))),$(subst <$(lz),$(subst 0, ,$(lz)),<$1)),$1)
~fp-fix = $(call ~u2d,$(call ~ltrimz,$(subst $  ,,$(call ~zero-pad,$(if $1,$(filter -,$1) $(foreach e,$(call ~u2d,$(word 1,$1)),$(if $(subst 0,,$(filter-out -%,$e)),$(call ~extend-fn,$(wordlist 3,99999999,$1),$e, 0 0 0 0),0)$(if $3, . $(call ~extend-fn,$(if $(subst 0,,$(filter-out -%,$e)),$(wordlist $e,99999999,$(wordlist 4,99999999,$1)),$(if $(findstring 1,$(call ~u-cmp,$4,$(patsubst -%,%,$(word 1,$e)))),$(call ~extend-fn,0,$(patsubst -%,%,$e), 0 0 0 0) $(wordlist 3,99999999,$1))),$3, 0 0 0 0))),n a n),$2))))

endef

define [mod-math2]
# Requires: core math0 math1
# Exports: 
$(call ^R,core)
$(call ^R,math0)
$(call ^R,math1)
~u-zeros = $(if $(filter-out -%,$1),$(subst 1, 0,$(if $(findstring 10,$1),$(call ~tally,$(subst 0, 0,$1)),$(subst 0,,$1))))
~round-uf-const = $(foreach r,$(subst $  ,,$(wordlist $(words 0 $2),99999999,$1)),$(and $(subst 0111111111,,$(subst .01111,,.$r)),$(subst 0,,$(subst .011111,,.$r)),$(if $(filter 011111%,$r),$(filter 0%,$(subst 0, 0,$(foreach w,$(subst 01111111111,10,$(subst $  ,,$(wordlist 1,$(words $2),$1)1)),$(if $(findstring 01111111111,$w),$(call ~u-carry-fn,$w,0111111111,0),$w)))),$(wordlist 1,$(words $2),$1))))
~get-uf-const = $(or $(call ~round-uf-const,$(value $1/v),$2),$(if $(word 1,$2),$(and $(call ^set,$1/c,$(patsubst %,0,0 0 0 0 0 $(join $2,$(value $1/c))),)1,$(call ^set,$1/v,$(wordlist 2,99999999,$(call ~uf-round,$(words $(value $1/c)),2,$(call $1,$(value $1/c)))),)1,$(call ~get-uf-const,$1,$2))))
~uf-addsub = $(if $2,$(filter 0%,$(subst 0, 0,$(foreach w,$(subst 01111111111,10,$(subst $  ,,$(subst 00,0,$(subst 10,1,$(join $1,$(if $3,$(subst 101,0,$(subst 11011,0,$(subst 1110111,0,$(patsubst 0%,%0111111111,$(patsubst 0111111%,%101111,$2)))))1,$2)))))),$(if $(findstring 01111111111,$w),$(call ~u-carry-fn,$w,0111111111,0),$w)))),$1)
~uf-atan-loop = $(if $6,$(if $(filter 0,$(word 1,$1)),$(if $(filter 0,$(word 2,$1)),0 0 $(call ~uf-atan-loop,$(wordlist 3,99999999,$1),$2,$3,$4,$5,$(wordlist 3,99999999,$6)),0 $(call ~uf-atan-loop,$(wordlist 2,99999999,$1),$2,$3,$4,$5,$(wordlist 2,99999999,$6))),$(call ~uf-addsub,$(wordlist 3,99999999,$(subst 0,0 ,$(subst 1,,$5))$(call ~uf-div,0 $1,$(strip $(subst 0, 0,$5)),$(words 0 $6),2)),$(if $(word $(words 0 $2),$6),$2 $(call ~uf-atan-loop,$(foreach n,$(words $(wordlist $(words 0 $2),99999999,$6)),$(wordlist 1,$n,$(call ~uf-mul,$(or $(wordlist 1,$n,$3),0),$(or $(wordlist 1,$n,$1),0)))),$2,$3,$4,$(call ~u-add-ones,$5,11),$(wordlist $(words 0 $2),99999999,$6))),$4)))
~uf-atanh-3 = $(filter 0%,$(subst 0, 0,$(foreach w,$(subst 01111111111,10,$(subst $  ,,$(subst 00,0,$(subst 10,1,$(join $2 $(call ~uf-atan-loop,$(foreach n,$(words $4),$(wordlist 1,$n,$(call ~uf-mul,$(or $(wordlist 1,$n,$1),0),$(or $(wordlist 1,$n,$3),0)))),$2,$3,,0111,$(wordlist $(words 0 $2),99999999,$4)),$1))))),$(if $(findstring 01111111111,$w),$(call ~u-carry-fn,$w,0111111111,0),$w))))
~uf-atanh-2 = $(if $2,$(strip $1 $(call ~uf-atanh-3,$2,$(call ~uf-get-lz,$3),$(call ~uf-trim-lz,$3),$(wordlist $(words 0 $1),99999999,$4))),0)
~uf-atanh = $(call ~uf-atanh-2,$(call ~uf-get-lz,$1),$(call ~uf-trim-lz,$1),$(call ~uf-mul,$1,$1),$2)
~uf-log = $(subst $  01111111111,1 0,$(subst 1,11,$(call ~uf-atanh,$(call ~uf-div,$(or $1,0),$2,$(words $3),2),$3)))
~log-M = $(call ~uf-log,0 011,011 0 011,0 0 $1)
~calc-m-powers = $(if $(findstring 1,$(word 1,$1)),$(call ^set,~m-powers,$2,$2),$(call ~calc-m-powers,$(wordlist 2,99999999,$(call ~uf-mul,$1,01 0 011)),$2$(if $2, )$(patsubst 00%,0%,$(subst $  ,,$1))))
~calc-m-powers-r = $(and $(call ^set,~m-powers-r,$(patsubst 00%,0%,$(foreach u,$(or $(~m-powers),$(call ~calc-m-powers,0 01 0 011,)),$(subst $  ,,$(call ~uf-div,01 0 01,$(wordlist 1,6,$(subst 0, 0,$u)),4,2)))))1,$(~m-powers-r))
~psrch = $(if $(call ~eq?,$2,$3),$(words $3),$(foreach ndx,$(words $(subst 0 0,0,$(patsubst %,0,$2 $3))),$(if $(findstring 1,$(call ~uf-cmp,$(subst 0, 0,$(word $(ndx),$2)),$1)),$(call ~psrch,$1,$2,$(wordlist 1,$(ndx),$2)),$(call ~psrch,$1,$(wordlist 2,$(ndx),0 $2),$3))))
~uf-log-fr2 = $(if $(filter 01%,$(word 1,$1)),$(filter 0%,$(subst 0, 0,$(foreach w,$(subst 01111111111,10,$(subst $  ,,$(subst 00,0,$(subst 10,1,$(join $(wordlist $(words $2),99999999,$(call ~uf-mul,$(call ~get-uf-const,~log-M,$3 0 $2),$2)),$(subst 101,0,$(subst 11011,0,$(subst 1110111,0,$(patsubst 0%,%0111111111,$(patsubst 0111111%,%101111,0 $(call ~uf-log,$(wordlist 2,99999999,$1),011 $(wordlist 2,99999999,$1),$3 0 $(word 75,$3)))))))1))))),$(if $(findstring 01111111111,$w),$(call ~u-carry-fn,$w,0111111111,0),$w)))),$(filter 0%,$(subst 0, 0,$(foreach w,$(subst 01111111111,10,$(subst $  ,,$(subst 00,0,$(subst 10,1,$(join $(wordlist $(words $2),99999999,$(call ~uf-mul,$(call ~get-uf-const,~log-M,$3 0 $2),$2)),0 $(call ~uf-log,$(filter 0%,$(subst 0, 0,$(foreach w,$(subst 01111111111,10,$(subst $  ,,$(subst 101,0,$(subst 11011,0,$(subst 1110111,0,$(patsubst 0%,%0111111111,$(patsubst 0111111%,%101111,$(wordlist 2,99999999,$1))))))1)),$(if $(findstring 01111111111,$w),$(call ~u-carry-fn,$w,0111111111,0),$w)))),01 $(wordlist 2,99999999,$1),$3 0 $(word 75,$3))))))),$(if $(findstring 01111111111,$w),$(call ~u-carry-fn,$w,0111111111,0),$w)))))
~uf-log-fr = $(foreach dp,$(call ~psrch,$1,$(or $(~m-powers-r),$(call ~calc-m-powers-r)),),$(call ~uf-log-fr2,$(if $(filter 0,$(dp)),0 $1,$(foreach n,$(words 0 0 $2),$(wordlist 1,$n,$(call ~uf-mul,$(or $(wordlist 1,$n,$(strip $(subst 0, 0,$(word $(dp),$(or $(~m-powers),$(call ~calc-m-powers,0 01 0 011,)))))),0),$(or $(wordlist 1,$n,$1),0))))),$(strip $(subst 0, 0,$(call ~d2u,$(dp)))),$2))
~log-10 = $(call ~uf-log-fr,01,0 0 $1)
~log-size-x = $(if $(filter -01111 -0111 -011 -01 011 0111 01111 011111,$1),01,$(if $(filter 01,$1),$(if $(findstring 11,$(wordlist 1,2,$2)),0,-0$(subst 0,1,$(word 1,$(subst 01, ,$(subst 001000,000100,$(subst $  ,,$2000)))))),$(if $(filter 0,$1),$(if $(findstring 111,$(word 1,$2)),$(if $(findstring 111111111,$(word 1,$2)),-0$(word 1,$(subst $  1,1,$(subst 0111111111,1,$2))),0),01),0$(subst 0,1,$(subst 1,,$(patsubst 011111%,00%,$(subst -,,$1)))))))
~fp-log2 = $(if $(findstring 1,$(call ~uf-cmp,$2,01 0 011)),$(call ~fp-add,$(if $(findstring 1,$1),$(call ~fp-mul,01 + $(call ~get-uf-const,~log-10,$3 0 0 $(subst 0, 0,$(patsubst -%,%,$1))),$(call ~u2fp,$1)),0 + 0),01 - $(call ^Y,,,,,,,,,,$(call ~uf-log-fr,$2,$3))),$(call ~fp-add,$(call ~fp-mul,01 + $(call ~get-uf-const,~log-10,$3 0 0 $(subst 0, 0,$(patsubst -%,%,$1))),$(call ~u2fp,$(call ~u-add,$1,$(subst --,,-01)))),0 - $(call ~uf-log,$(wordlist 2,99999999,$2),011 $(wordlist 2,99999999,$2),0 $3)))
~adjust-digit-count = $(if $(filter -%,$2),$1$(subst 1, 1,$(subst -0,,$2)),$(wordlist $(words $(subst 1, 1,$2)),99999999,$1))
~fp-log = $(and $(findstring + 01,$(filter-out 0,.$1)),$2,$(call ~fp-round,$(call ~fp-log2,$(word 1,$1),$(wordlist 3,99999999,$1),$(if $(filter 0% -0%,$2),$(call ~u-zeros,$2),$(call ~adjust-digit-count,$(call ~extend-fn,0,$2, 0 0 0 0),$(call ~log-size-x,$(word 1,$1),$(wordlist 3,99999999,$1))))),$(or $(~result-pod),$2),2))
~fp-log-x-b = $(and $3,$(findstring + 01,$(filter-out 0,.$1)),$(findstring + 01,$(filter-out 0,.$2)),$(foreach x-size,$(call ~log-size-x,$(word 1,$1),$(wordlist 3,99999999,$1)),$(foreach b-size,$(call ~log-size-x,$(word 1,$2),$(wordlist 3,99999999,$2)),$(call ^Y,$(if $(filter 0% -0%,$3),$(call ~adjust-digit-count,$(call ~adjust-digit-count,0 0 $(call ~u-zeros,$3),$(subst --,,-$(x-size))),$(b-size)),0  $(call ~extend-fn,0,$3, 0 0 0 0)),$1,$2,$3,,,,,,$`(call ~fp-div,$`(call ~fp-log2,$`(word 1,$`2),$`(wordlist 3,99999999,$`2),$`(call ~adjust-digit-count,$`1,$`(x-size))),$`(call ~fp-log2,$`(word 1,$`3),$`(wordlist 3,99999999,$`3),$`(call ~adjust-digit-count,$`1,$`(b-size))),$`(or $`(~result-pod),$`4),1)))))
~uf-exp-loop = $(if $4,$(if $(findstring 1,$(word 1,$1)),$(filter 0%,$(subst 0, 0,$(foreach w,$(subst 01111111111,10,$(subst $  ,,$(subst 00,0,$(subst 10,1,$(join $(foreach n,$(words $4),$(if $(filter-out 0,$n),$(call ~uf-exp-loop,$(wordlist 3,99999999,$(subst 0,0 ,$(subst 1,,$3))$(call ~uf-div,0 $(wordlist 1,$n,$(call ~uf-mul,$(or $(wordlist 1,$n,$2),0),$(or $(wordlist 1,$n,$1),0))),$(strip $(subst 0, 0,$3)),$n,2)),$2,$(call ~u-add-ones,$3,1),$4))),0 $1))))),$(if $(findstring 01111111111,$w),$(call ~u-carry-fn,$w,0111111111,0),$w)))),$(if $(filter 0,$(word 2,$1)),0 0 $(call ~uf-exp-loop,$(wordlist 3,99999999,$1),$2,$3,$(wordlist 3,99999999,$4)),0 $(call ~uf-exp-loop,$(wordlist 2,99999999,$1),$2,$3,$(wordlist 2,99999999,$4)))))
~uf-exp-small = $(filter 0%,$(subst 0, 0,$(foreach w,$(subst 01111111111,10,$(subst $  ,,$(subst 00,0,$(subst 10,1,$(join 01,$(call ~uf-exp-loop,$1,$1,011,$2)))))),$(if $(findstring 01111111111,$w),$(call ~u-carry-fn,$w,0111111111,0),$w))))
~uf-exp-med-2 = $(foreach wp,$(patsubst 0:%,%,$(patsubst 0:0:%,%,$(subst $  ,:,$(call ~uf-div,0 $1,$(wordlist 2,99999999,$3),3,1)))),$(if $(findstring 1,$(wp)),$(foreach wm,$(word $(call ~u2d,$(subst :,,$(wp))),$(or $(~m-powers),$(call ~calc-m-powers,0 01 0 011,))),$(call ~uf-mul,$(call ~uf-exp-small,$(wordlist 2,99999999,$(filter 0%,$(subst 0, 0,$(foreach w,$(subst 01111111111,10,$(subst $  ,,$(subst 00,0,$(subst 10,1,$(join $1,$(subst 101,0,$(subst 11011,0,$(subst 1110111,0,$(patsubst 0%,%0111111111,$(patsubst 0111111%,%101111,$(wordlist $(words $(subst :, ,$(wp))),99999999,$(call ~uf-mul,$3,$(subst :, ,$(wp)))))))))1))))),$(if $(findstring 01111111111,$w),$(call ~u-carry-fn,$w,0111111111,0),$w))))),$2$(if $(filter 0111%,$(wm)), 0)),$(wordlist 1,$(words 0 $2),$(subst 0, 0,$(wm))))),0 $(call ~uf-exp-small,$(wordlist 2,99999999,$1),$2)))
~fp2su = $(if $(subst 0,,$(filter-out -%,$(word 1,$1))),$(findstring -,$(word 2,$1))$(subst $  ,,$(call ~extend-fn,$(wordlist 3,99999999,$1),$(call ~u2d,$(word 1,$1)), 0 0 0 0)),0)
~fp2uf = $(or $(foreach pos,$(if $(filter 0,$2),$(word 1,$1),$(call ~u-add,$(word 1,$1),$(subst --,,-$2))),$(if $(subst 0,,$(filter-out -%,$(pos))),$(if $(word 9,$(subst 0, 0,$(pos))),,$(wordlist $(call ~u2d,$(pos)),99999999,$(wordlist 4,99999999,$1))),$(strip $(if $(findstring 1,$(pos)),$(call ~u-zeros,$(patsubst -%,%,$(pos)))) $(wordlist 3,99999999,$1)))),0)
~exp-4 = $(call ~u-add-ones,$(call ~fp2su,$4),11) + $(call ~uf-exp-med-2,$(call ~fp2uf,$(call ~fp-add,$1,$(subst !,-,$(subst $  -, +,$(subst $  +, !,$(call ~fp-mul,$4,$3))))),01),0 $2,$(call ~get-uf-const,~log-M,0 0 0 $2))
~exp-3 = $(call ~exp-4,$1,$2,$3,$(call ~fp-div,$1,$3,0,))
~exp-2 = $(if $2,$(call ~exp-3,$1,$2,01 + $(call ~get-uf-const,~log-10,$2 0 0 $(call ~u-zeros,$(word 1,$1)))),0 + 0)
~fp-exp = $(and $1,$2,$(call ~fp-round,$(call ~exp-2,$1,$(if $(filter 0% -0%,$2),0 $(call ~u-zeros,$(call ~u-add,$2,$(call ~fp2su,$(call ~fp-div,$1,01 + 011 0111,0,)))),$(call ~extend-fn,0,$2, 0 0 0 0))),$(or $(~result-pod),$2),2))
~fp-pow = $(and $1,$2,$3,$(if $(findstring 101,$(word 3,$1)$(word 3,$2)),$(foreach ud,$(if $(filter 0% -0%,$3),$(call ~u-add,$(or $(filter-out -% %1111111111,$31),$(call ~u-add,$3,01)),$(call ~fp2su,$(call ~fp-mul,$2,$(call ~u2fp,$(or $(filter-out -% %1111111111,$(word 1,$1)1),$(call ~u-add,$(word 1,$1),01)))))),$(call ~d2u,$3)),$(if $(filter -% 0,$(ud)),0 + 0,$(call ~fp-exp,$(call ~fp-mul,$2,$(call ^set,~result-pod,$(call ^set,~result-pod,,$(~result-pod)),$(call ~fp-log,$1,$(call ~u2d,$(call ~u-add,$(ud),$(call ~u-add,$(call ~u-carry-all,$(call ~log-size-x,$(word 1,$1),$(wordlist 3,99999999,$1))),$(word 1,$2))))))),$3))),$(if $(findstring 1,$(word 3,$1)),01 + 01,$(if $(findstring 1,$(word 3,$2)),0 + 0))))
~uf-atan = $(call ^Y,$(call ~uf-get-lz,$1),$(call ~uf-trim-lz,$1),$(call ~uf-mul,$1,$1),$2,,,,,,$`(if $`2,$`(strip $`1 $`(call ~uf-atan-loop,$`2,$`(call ~uf-get-lz,$`3),$`(call ~uf-trim-lz,$`3),-,01,$`(wordlist $`(words 0 $`1),99999999,$`4))),0))
~uf-pi = $(subst x,11,$(subst $  0xxxxx,1 0,$(subst 1,xx,$(subst $  011111,x 0,0 $(filter 0%,$(subst 0, 0,$(foreach w,$(subst 01111111111,10,$(subst $  ,,$(subst 00,0,$(subst 10,1,$(join $(subst x,11,$(subst $  0xxxxx,1 0,$(subst 1,xx,$(subst $  011111,x 0,$(call ~uf-atan,011,$1))))),$(subst 101,0,$(subst 11011,0,$(subst 1110111,0,$(patsubst 0%,%0111111111,$(patsubst 0111111%,%101111,$(call ~uf-atan,$(call ~extend-fn,,$(words $1), 0 0 01111 01 011111111 01111 01),$1))))))1))))),$(if $(findstring 01111111111,$w),$(call ~u-carry-fn,$w,0111111111,0),$w))))))))
~uf-sin-loop = $(if $(findstring 1,$(word 1,$2)),$(filter 0%,$(subst 0, 0,$(foreach w,$(subst 01111111111,10,$(subst $  ,,$(subst 00,0,$(subst 10,1,$(join $2,$(subst 101,0,$(subst 11011,0,$(subst 1110111,0,$(patsubst 0%,%0111111111,$(patsubst 0111111%,%101111,$(call ~uf-sin-loop,$(call ~u-add-ones,$1,11),$(foreach n,$(words 0 $4),$(wordlist 3,99999999,$(subst 0,0 ,$(subst 1,,$(call ~u-add-ones,$1,1)))$(call ~uf-div,0 $(wordlist 3,99999999,$(subst 0,0 ,$(subst 1,,$1))$(call ~uf-div,0 $(call ~uf-mul,$2,$3),$(strip $(subst 0, 0,$1)),$n,2)),$(strip $(subst 0, 0,$(call ~u-add-ones,$1,1))),$n,2))),$3,$4))))))1))))),$(if $(findstring 01111111111,$w),$(call ~u-carry-fn,$w,0111111111,0),$w)))),$(if $4,0 $(call ~uf-sin-loop,$1,$(wordlist 2,99999999,$2),$3,$(wordlist 2,99999999,$4))))
~xsin-reduce = $(if $(findstring $  -,$1),$(call ~xsin-reduce,$(subst $  -, +,$1),$2,$(call ~xor,$2,$3),$4,$5,$6,$7,$8),$(if $(findstring 1,$(call ~fp-cmp,0 + 011111111,$1)),$(call $5,$1,$2,$3,$4,$6,$7,$8),$(if $(findstring 1,$(call ~fp-cmp,01 + 011 0111 0111111,$1)),$(call ~xsin-reduce,$(call ~fp-add,01 + $(subst 2,1,$(subst 1 0, 011111,$(subst 11,2,$(call ~get-uf-const,~uf-pi,0 $4) 0))),$(subst !,-,$(subst $  -, +,$(subst $  +, !,$1)))),$(if $2,,1),$3,$4,$5,$6,$7,$8),$(if $(findstring 1,$(call ~fp-cmp,01 + 011111 011111,$1)),$(call ~xsin-reduce,$(call ~fp-add,$1,$(subst !,-,$(subst $  -, +,$(subst $  +, !,01 + $(call ~get-uf-const,~uf-pi,0 $4))))),$2,$(if $3,,1),$4,$5,$6,$7,$8),$(call ~xsin-reduce,$(call ~fp-norm,$(call ~fp-add,$(call ~fp-mod,$(call ~fp-add,0 + 011111111,$1),01 + $(subst $  01111111111,1 0,$(subst 1,11,$(call ~get-uf-const,~uf-pi,$(call ~u-zeros,$(word 1,$1)) 0 $4)))),$(subst !,-,$(subst $  -, +,$(subst $  +, !,0 + 011111111))))),$2,$3,$4,$5,$6,$7,$8)))))
~xsin-small = $(or $(and $7,$2,$(if $(findstring 1,$(wordlist 1,$(words $(wordlist 2,99999999,$(wordlist $7,99999999,$4))),$(call ~fp2uf,$1,0))),,1),$(call ~xsin-reduce,$5,$6,,$(if $(findstring 1,$(wordlist 3,99999999,$1)),$4,$(call ~uf-get-lz,$(call ~fp2uf,$1,0))) 0 $(wordlist 1,$7,$4),~xsin-small,$5,$6,$7)),01 $(if $3,-,+) $(if $2,0 $(call ~uf-sin-loop,011,$(call ~fp2uf,$1,0),$(foreach n,$(words $4),$(wordlist 1,$n,$(call ~uf-mul,$(or $(wordlist 1,$n,$(call ~fp2uf,$1,0)),0),$(or $(wordlist 1,$n,$(call ~fp2uf,$1,0)),0)))),$4),$(call ^Y,$(foreach n,$(words $4),$(wordlist 1,$n,$(call ~uf-mul,$(or $(wordlist 1,$n,$(call ~fp2uf,$1,0)),0),$(or $(wordlist 1,$n,$(call ~fp2uf,$1,0)),0)))),,,,,,,,,$`(filter 0%,$`(subst 0, 0,$`(foreach w,$`(subst 01111111111,10,$`(subst $`  ,,$`(subst 00,0,$`(subst 10,1,$`(join 01,$`(subst 101,0,$`(subst 11011,0,$`(subst 1110111,0,$`(patsubst 0%,%0111111111,$`(patsubst 0111111%,%101111,0 $`(call ~uf-sin-loop,0111,$`(subst 2,1,$`(subst 1 0, 011111,$`(subst 11,2,$`1 0))),$`1,$(call ^E,$4)))))))1))))),$`(if $`(findstring 01111111111,$`w),$`(call ~u-carry-fn,$`w,0111111111,0),$`w)))))))
~fp-xsin = $(and $2,$3,$(call ~fp-round,$(if $(findstring 1,$(wordlist 3,99999999,$2)),$(call ~xsin-reduce,$2,$1,,0 $(if $(filter 0% -0%,$3),$(call ~u-zeros,$3),$(call ~extend-fn,0,$3, 0 0 0 0)),~xsin-small,$2,$1,$(filter-out 0% -0%,$3)),$(if $1,0 + 0,01 + 01)),$(or $(~result-pod),$3),2))
~xsin = $(call ~u2d,$(call ~fp2u,$(call ~fp-xsin,$1,$(call ~u2fp,$(call ~d2u,$2)),$(call ~prec-to-pod,$3))))
~fp-atan-unflip = $(if $2,$(call ~fp-add,$(if $(filter | /,$2),$(subst $  +, -,$1),$1),01 + $(if $(filter |,$2),$(call ~get-uf-const,~uf-pi,$3 $(if $4,$(call ~uf-get-lz,$(call ~fp2uf,$1,0)))),$(subst 2,1,$(subst 1 0, 011111,$(subst 11,2,$(call ~get-uf-const,~uf-pi,$3 $(if $4,$(call ~uf-get-lz,$(call ~fp2uf,$1,0)))) 0))))),$1)
~fp-atan-tiny = 0 + $(call ~uf-atan,$1,$2 $(if $3,$(call ~uf-get-lz,$1)))
~fp-atan-small = $(call ~fp-atan-unflip,$(if $(findstring 1,$(call ~fp-cmp,0 + 01111 011,$1)),$(call ~fp-atan-tiny,$(call ~fp2uf,$1,0),$4,$(filter-out 0% -0%,$3)),$(call ~fp-add,01 + $(subst 2 0, 011111,$(subst 22,1,$(subst 1 0, 0112,$(subst 11,2,$(call ~get-uf-const,~uf-pi,$4) 0 0)))),$(subst !,-,$(subst $  -, +,$(subst $  +, !,$(call ~fp-atan-tiny,$(call ~fp2uf,$(call ~fp-div,$(call ~fp-add,01 + 01,$(subst !,-,$(subst $  -, +,$(subst $  +, !,$1)))),$(call ~fp-add,$1,01 + 01),$(if $(filter 0% -0%,$3),$(or $(filter-out -% %1111111111,$31),$(call ~u-add,$3,01)),$(call ~1+,$3)),2),0),$4,)))))),$2,$4,$(filter-out 0% -0%,$3))
~fp-atan2 = $(if $(findstring $  -,$1),$(subst !,-,$(subst $  -, +,$(subst $  +, !,$(call ~fp-atan2,$(subst $  -, +,$1),$2,$3)))),$(if $(findstring - 01,$(filter-out 0,.$2)),$(call ~fp-atan2,$1,$(subst $  -, +,$2),$3,|),$(if $(findstring 1,$(call ~fp-cmp,$1,$2)),$(call ~fp-atan2,$2,$1,$3,$4/),$(if $(and $(findstring 1,$(wordlist 3,99999999,$2)),$2,$1),$(call ~fp-atan-small,$(call ~fp-div,$1,$2,$(if $(filter 0% -0%,$3),$(or $(filter-out -% %1111111111,$31),$(call ~u-add,$3,01)),$(call ~1+,$3)),2),$4,$3,0 $(if $(filter 0% -0%,$3),$(call ~u-zeros,$3),$(call ~extend-fn,0,$3, 0 0 0 0)))))))

endef

define [mod-escape]
# Requires: core
# Exports: protect-define#protect-rhs#protect-lhs#protect-expr#protect-arg#protect-trim#protect-ltrim#escape&1;!1.;!1:IL2;subst[|'$[|'$`[@'1'0
$(call ^R,core)
define ~protect-hash2
$(if $(findstring \.#,$1),$(call ~protect-hash2,$(subst \.#,.#\\,$1)),$(subst .#,,$1))
endef
define ~quote-hash
$(if $(findstring #,$1),$(call ~protect-hash2,$(subst #,.#\#,$1)),$1)
endef
~protect-ltrim = $(if $(findstring $(word 1,0$10),0),$` )$1
define ~protect-trim
$(if $(and $(findstring $1,$(wordlist 1,99999999,$1)),$(filter-out 
%,$(word 1,$1)),$(filter-out %
,$(lastword $1))),$1,$(if $1,$`(if ,,$1)))
endef
~balance2 = $(call ^u,$(if $(findstring !C,$1),$`(if ,,$(subst !C,,$1)),$1))
~balance-match-r = $(if $1,$(call ~balance-match-r,$(word 1,$2),$(wordlist 2,99999999,$2),$(if $(filter !L%,$1),$3 $1,$(if $(and $(filter !R,$1),$(word 2,$3)),$(filter-out %!,$3!)($(subst !L,,$(subst !C,,$(lastword $3)))),$3$1))),$3)
~balance-match = $(call ~balance-match-r,$(word 1,$1),$(wordlist 2,99999999,$1),!.)
~check-balance-r = $(if $(word 2,$1),$(call ~check-balance-r,$(subst $  ,,$(filter-out !L%!R,$(subst !L, !L,$(word 1,$1))))$(wordlist 2,99999999,$1)),$1)
~check-balance = $(call ~check-balance-r,$(subst $],!R .,$(subst $[,!L,$(subst !,,$(subst $ 	,,$(subst $  ,,$1))))))
~make-balanced = $(if $(findstring !,$2),$(call ~balance2,$(subst !L,$`[,$(subst !R,$`],$(subst $  ,,$(call ~balance-match,$(subst $[, !L,$(subst $], !R ,$(subst $(if ,,,),$(if ,,!C,),$(call ^d,$1))))))))),$(if $(findstring $(if ,,,),$2),$`(if ,,$1),$1))
~protect-arg = $(if $(or $(findstring $[,$1),$(findstring $],$1),$(findstring $(if ,,,),$1)),$(call ~make-balanced,$1,$(call ~check-balance,$1)),$1)
define ~protect-expr
$(subst 
,$`',$1)
endef
define ~protect-lhs
$(subst #,$`",$(subst X,$(subst 
,$`',$(call ~protect-arg,$1)),$(if $(or $(findstring :,$1),$(findstring =,$1),$(if $(findstring $1,$(wordlist 1,99999999,$1)),,1),$(filter ifeq ifneq ifdef ifndef else endif define endef override include sinclude -include export unexport private undefine vpath,$1)),$`(if ,,X),X)))
endef
define ~protect-rhs
$(call ~quote-hash,$(call ~protect-ltrim,$(subst 
,$`',$1)))
endef
define ~protect-define
$(if $(or $(findstring define,$1),$(findstring endef,$1),$(findstring \,$1)),$(subst |1,|,$(subst |0, ,$(subst $  ,
,$(foreach w,$(call ~split,
,$1),$(subst $  ,|0,$(subst |,|1,$(if $(filter define endef,$(word 1,$(call ^u,$w))),$` )$(call ^u,$w)$(if $(filter %\,$(call ^d,$(call ^u,$w))),$` ))))))),$1)
endef

endef
$(eval $(value [mod-runtime]))

# bin/scam holds the "golden" compiler executable, which bootstraps compiler
# generation.  From the source files we build to three different sets of
# exectuable code:
#
#    Compiler  Output  Runtime used by the code
#    --------  ------  -----------------------------
#    golden     $A     golden (bundled in bin/scam)
#    $A         $B     current ($B/runtime.min)
#    $B         $C     current (bundled in $B/scam)
#
# Generated code will implicitly depend on a runtime, because the compiler's
# code generation phase emits references to runtime functions.  When we
# modify the compiler sources we can change the runtime code as long as we
# change the corresponding code generation code.  However, to support this
# we need to avoid mismatches at run time.  Code generated by the golden
# compiler must use the golden runtime, and code generates by a current
# compiler (e.g. a/scam) must use a runtime compiled from current sources.
# The combinations are summarized above, and these imply some complications
# that should be called out:
#
#  1. $A/scam contains and uses the golden runtime.  However, code that IT
#     GENERATES must use a current runtime.  This means that the `scam -x
#     ...` cannot be supported by the a compiler, so we do not run those
#     tests against the a compiler.
#
#  2. In order to support `scam -o ...`, the a compiler must bundle a
#     current runtime into the generated program ... NOT the one bundled
#     within itself.  We name `runtime.scm` on the command line as a source
#     file, which tells the program to build, test, and bundle THAT runtime,
#     not its own bundled one.
#
#  3. runtime.scm presents its own potential conflict: it cannot use any
#     other runtime because of symbol conflicts, and so building the current
#     runtime sources with a golden compiler would be problematic.  As a
#     result, we do not build and run $A/runtime.min or $A/runtime-q.min.
#     Instead, we generate `b` binaries for these using the `a` compiler.

_@ = @
A = .out/a
B = .out/b
C = .out/c

expect = grep $1 $2 > /dev/null && echo $2 ok || (echo '$2:1: looking for '"$1" && false)

.PHONY: a b c aok bok cok promote install clean

cok:

$A/scam: *.scm bin/scam ; $(_@) bin/scam -o $@ scam.scm
$B/scam: *.scm $A/scam  ; $(_@) SCAM_NS='~' $A/scam -o $@ --symbols scam.scm --boot
$C/scam: *.scm $B/scam  ; $(_@) SCAM_NS='~' $B/scam -o $@ --symbols scam.scm


a: $A/scam
b: aok $B/scam
c: bok $C/scam


# v1 tests:
#  run: validates code generation
#
aok: $A/scam
	$(_@) $A/scam -o .out/ta/run test/run.scm --boot
	$(_@) .out/ta/run

# v2 tests:
#   dash-o: test program generated with "scam -o EXE"
#     Uses a bundled file, so $A/scam will not always work.
#   dash-x: compile and execute source file, passing arguments

bok: b
	@echo bok...
	$(_@) $B/scam -o .out/tb/using test/using.scm
	$(_@) .out/tb/using
	$(_@) $B/scam -o .out/tb/dash-o test/dash-o.scm
	$(_@) $(call expect,'require.dup',.out/tb/dash-o.min)
	$(_@) .out/tb/dash-o 1 2 > .out/tb/dash-o.out
	$(_@) $(call expect,'result=11:2',.out/tb/dash-o.out)
	$(_@) SCAM_TRACE='%conc:c' $B/scam -x test/dash-x.scm 3 'a b' > .out/tb/dash-x.out
	$(_@) $(call expect,'9:3:a b',.out/tb/dash-x.out)
	$(_@) $(call expect,' 4 : .*conc',.out/tb/dash-x.out)


# To verify the compiler, we ensure that $B/scam and $C/scam are identical.
# $A/scam differs from bin/scam because it is built from newer source files.
# $A and $B differ because they are built by different compilers, but they
# should *behave* the same because they share the same sources ... so $B and
# $C should be identical, unless there is a bug.  We exclude exports from
# the comparison because they mention file paths, which always differ.
#
cok: c
	@echo cok...
	$(_@)grep -v Exports $B/scam > $B/scam.e
	$(_@)grep -v Exports $C/scam > $C/scam.e
	$(_@)diff -q $B/scam.e $C/scam.e

# Replace the "golden" compiler with a newer one.
#
promote: cok
	$(_@)cp $B/scam bin/scam

install:
	cp bin/scam `which scam`

clean:
	rm -rf .out

$$%:
	@true $(info $$$* --> "$(call if,,,$$$*)")

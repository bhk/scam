# bin/scam holds the "golden" compiler executable, which bootstraps compiler
# generation.  From the source files we build to three different sets of
# exectuable code:
#
#  Code   Compiler      Runtime used by the code
#  ----   --------      -----------------------------
#   v1    golden        golden (bundled in bin/scam)
#   v2    v1            current (.v2/runtime.min)
#   v3    v2            current (bundled in .v2/scam)
#
# Generated code will implicitly depend on a runtime, because the compiler's
# code generation phase emits references to runtime functions.  When we
# modify the compiler sources we can change the runtime code as long as we
# change the corresponding code generation code.  However, to support this
# we need to avoid mismatches at run time.  Code generated by the golden
# compiler must use the golden runtime, and code generates by a current
# compiler (e.g. v1./scam) must use a runtime compiled from current sources.
# The combinations are summarized above, and these imply some complications
# that should be called out:
#
#  1. .v1/scam contains and uses the golden runtime.  However, code that IT
#     GENERATES must use a current runtime.  This means that the `scam -x
#     ...` cannot be supported by the v1 compiler, so we do not run those
#     tests against the v1 compiler.
#
#  2. In order to support `scam -o ...`, the v1 compiler must bundle a
#     current runtime into the generated program ... NOT the one bundled
#     within itself.  We name `runtime.scm` on the command line as a source
#     file, which tells the program to build, test, and bundle THAT runtime,
#     not its own bundled one.
#
#  3. runtime.scm presents its own potential conflict: it cannot use any
#     other runtime because of symbol conflicts, and so building the current
#     runtime sources with a golden compiler would be problematic.  As a
#     result, we do not build and run .v1/runtime.min or .v1/runtime-q.min.
#     Instead, we generate v2 binaries for these using the v1 compiler.


_@=@
expect = grep $1 $2 > /dev/null && echo $2 ok || (echo '$2:1: looking for '"$1" && false)
compile = $2/scam -o $3/$(basename $(notdir $1)) $1 runtime.scm
v1compile = $(call compile,$1,.v1,.v2)
v2compile = $(call compile,$1,.v2,.v3)


.PHONY: v1 v2 v3 v1ok v3ok promote install clean


v1:      ; $(_@)bin/scam -o .v1/scam --symbols scam.scm
v2: v1ok ; $(_@).v1/scam -o .v2/scam --symbols scam.scm runtime.scm
v3: v2ok ; $(_@).v2/scam -o .v3/scam --symbols scam.scm


# v1 tests:
#  dash-o: test program generated with "scam -o EXE"
#  test-gen: validates code generation
#
v1ok: v1
	$(_@) $(call v1compile,test/dash-o.scm)
	$(_@) $(call expect,'require.dup',.v2/dash-o.min)
	$(_@) .v2/dash-o 1 2 > .v2/dash-o.out
	$(_@) $(call expect,'result=11:2',.v2/dash-o.out)
	$(_@) $(call v1compile,gen-test.scm)
	$(_@) .v2/gen-test

# v2 tests:
#   dash-x: compile and execute source file, passing arguments

v2ok: v2
	$(_@) SCAM_TRACE='conc:c' .v2/scam -x test/dash-x.scm 3 'a b' > .v2/dash-x.out
	$(_@) $(call expect,'9:3:a b',.v2/dash-x.out)
	$(_@) $(call expect,' 4 : conc',.v2/dash-x.out)


# To verify the compiler, we ensure that .v2/scam and .v3/scam are
# identical.  .v1/scam may differ from bin/scam because it is built from
# newer source files.  v1 and v2 may differ because they are built by
# different compilers, but they should *behave* the same because they share
# the same sources ... so v2 and v3 should be identical, unless there is a
# bug.  We exclude exports from the comparison because they mention file
# paths, which always differ.
#
v3ok: v1 v2 v3
	$(_@)grep -v Exports .v2/scam > .v2/scam.e
	$(_@)grep -v Exports .v3/scam > .v3/scam.e
	$(_@)diff -q .v2/scam.e .v3/scam.e

# Replace the "golden" compiler with a newer one.
#
promote: v3ok
	$(_@)cp .v2/scam bin/scam

install:
	cp bin/scam `which scam`

clean:
	rm -rf .v1 .v2 .v3

$$%:
	@true $(info $$$* --> "$(call if,,,$$$*)")
